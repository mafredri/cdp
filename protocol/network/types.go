// Code generated by cdpgen. DO NOT EDIT.

package network

import (
	"encoding/json"
	"errors"
	"time"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/protocol/io"
	"github.com/mafredri/cdp/protocol/runtime"
	"github.com/mafredri/cdp/protocol/security"
)

// ResourceType Resource type as it was perceived by the rendering engine.
type ResourceType string

// ResourceType as enums.
const (
	ResourceTypeNotSet             ResourceType = ""
	ResourceTypeDocument           ResourceType = "Document"
	ResourceTypeStylesheet         ResourceType = "Stylesheet"
	ResourceTypeImage              ResourceType = "Image"
	ResourceTypeMedia              ResourceType = "Media"
	ResourceTypeFont               ResourceType = "Font"
	ResourceTypeScript             ResourceType = "Script"
	ResourceTypeTextTrack          ResourceType = "TextTrack"
	ResourceTypeXHR                ResourceType = "XHR"
	ResourceTypeFetch              ResourceType = "Fetch"
	ResourceTypePrefetch           ResourceType = "Prefetch"
	ResourceTypeEventSource        ResourceType = "EventSource"
	ResourceTypeWebSocket          ResourceType = "WebSocket"
	ResourceTypeManifest           ResourceType = "Manifest"
	ResourceTypeSignedExchange     ResourceType = "SignedExchange"
	ResourceTypePing               ResourceType = "Ping"
	ResourceTypeCSPViolationReport ResourceType = "CSPViolationReport"
	ResourceTypePreflight          ResourceType = "Preflight"
	ResourceTypeFedCM              ResourceType = "FedCM"
	ResourceTypeOther              ResourceType = "Other"
)

func (e ResourceType) Valid() bool {
	switch e {
	case "Document", "Stylesheet", "Image", "Media", "Font", "Script", "TextTrack", "XHR", "Fetch", "Prefetch", "EventSource", "WebSocket", "Manifest", "SignedExchange", "Ping", "CSPViolationReport", "Preflight", "FedCM", "Other":
		return true
	default:
		return false
	}
}

func (e ResourceType) String() string {
	return string(e)
}

// LoaderID Unique loader identifier.
type LoaderID string

// RequestID Unique network request identifier. Note that this does not
// identify individual HTTP requests that are part of a network request.
type RequestID string

// InterceptionID Unique intercepted request identifier.
type InterceptionID string

// ErrorReason Network level fetch failure reason.
type ErrorReason string

// ErrorReason as enums.
const (
	ErrorReasonNotSet               ErrorReason = ""
	ErrorReasonFailed               ErrorReason = "Failed"
	ErrorReasonAborted              ErrorReason = "Aborted"
	ErrorReasonTimedOut             ErrorReason = "TimedOut"
	ErrorReasonAccessDenied         ErrorReason = "AccessDenied"
	ErrorReasonConnectionClosed     ErrorReason = "ConnectionClosed"
	ErrorReasonConnectionReset      ErrorReason = "ConnectionReset"
	ErrorReasonConnectionRefused    ErrorReason = "ConnectionRefused"
	ErrorReasonConnectionAborted    ErrorReason = "ConnectionAborted"
	ErrorReasonConnectionFailed     ErrorReason = "ConnectionFailed"
	ErrorReasonNameNotResolved      ErrorReason = "NameNotResolved"
	ErrorReasonInternetDisconnected ErrorReason = "InternetDisconnected"
	ErrorReasonAddressUnreachable   ErrorReason = "AddressUnreachable"
	ErrorReasonBlockedByClient      ErrorReason = "BlockedByClient"
	ErrorReasonBlockedByResponse    ErrorReason = "BlockedByResponse"
)

func (e ErrorReason) Valid() bool {
	switch e {
	case "Failed", "Aborted", "TimedOut", "AccessDenied", "ConnectionClosed", "ConnectionReset", "ConnectionRefused", "ConnectionAborted", "ConnectionFailed", "NameNotResolved", "InternetDisconnected", "AddressUnreachable", "BlockedByClient", "BlockedByResponse":
		return true
	default:
		return false
	}
}

func (e ErrorReason) String() string {
	return string(e)
}

// TimeSinceEpoch UTC time in seconds, counted from January 1, 1970.
type TimeSinceEpoch = internal.NetworkTimeSinceEpoch

// MonotonicTime Monotonically increasing time in seconds since an arbitrary
// point in the past.
type MonotonicTime float64

// String calls (time.Time).String().
func (t MonotonicTime) String() string {
	return t.Time().String()
}

// Time parses the Unix time.
func (t MonotonicTime) Time() time.Time {
	ts := float64(t) / 1
	secs := int64(ts)
	nsecs := int64((ts - float64(secs)) * 1000000000)
	return time.Unix(secs, nsecs)
}

// MarshalJSON implements json.Marshaler. Encodes to null if t is zero.
func (t MonotonicTime) MarshalJSON() ([]byte, error) {
	if t == 0 {
		return []byte("null"), nil
	}
	f := float64(t)
	return json.Marshal(&f)
}

// UnmarshalJSON implements json.Unmarshaler.
func (t *MonotonicTime) UnmarshalJSON(data []byte) error {
	*t = 0
	if len(data) == 0 {
		return nil
	}
	var f float64
	if err := json.Unmarshal(data, &f); err != nil {
		return errors.New("network.MonotonicTime: " + err.Error())
	}
	*t = MonotonicTime(f)
	return nil
}

var _ json.Marshaler = (*MonotonicTime)(nil)
var _ json.Unmarshaler = (*MonotonicTime)(nil)

// Headers Request / response headers as keys / values of JSON object.
type Headers []byte

// MarshalJSON copies behavior of json.RawMessage.
func (h Headers) MarshalJSON() ([]byte, error) {
	if h == nil {
		return []byte("null"), nil
	}
	return h, nil
}

// UnmarshalJSON copies behavior of json.RawMessage.
func (h *Headers) UnmarshalJSON(data []byte) error {
	if h == nil {
		return errors.New("network.Headers: UnmarshalJSON on nil pointer")
	}
	*h = append((*h)[0:0], data...)
	return nil
}

var _ json.Marshaler = (*Headers)(nil)
var _ json.Unmarshaler = (*Headers)(nil)

// ConnectionType The underlying connection technology that the browser is
// supposedly using.
type ConnectionType string

// ConnectionType as enums.
const (
	ConnectionTypeNotSet     ConnectionType = ""
	ConnectionTypeNone       ConnectionType = "none"
	ConnectionTypeCellular2g ConnectionType = "cellular2g"
	ConnectionTypeCellular3g ConnectionType = "cellular3g"
	ConnectionTypeCellular4g ConnectionType = "cellular4g"
	ConnectionTypeBluetooth  ConnectionType = "bluetooth"
	ConnectionTypeEthernet   ConnectionType = "ethernet"
	ConnectionTypeWifi       ConnectionType = "wifi"
	ConnectionTypeWimax      ConnectionType = "wimax"
	ConnectionTypeOther      ConnectionType = "other"
)

func (e ConnectionType) Valid() bool {
	switch e {
	case "none", "cellular2g", "cellular3g", "cellular4g", "bluetooth", "ethernet", "wifi", "wimax", "other":
		return true
	default:
		return false
	}
}

func (e ConnectionType) String() string {
	return string(e)
}

// CookieSameSite Represents the cookie's 'SameSite' status:
// https://tools.ietf.org/html/draft-west-first-party-cookies
type CookieSameSite string

// CookieSameSite as enums.
const (
	CookieSameSiteNotSet CookieSameSite = ""
	CookieSameSiteStrict CookieSameSite = "Strict"
	CookieSameSiteLax    CookieSameSite = "Lax"
	CookieSameSiteNone   CookieSameSite = "None"
)

func (e CookieSameSite) Valid() bool {
	switch e {
	case "Strict", "Lax", "None":
		return true
	default:
		return false
	}
}

func (e CookieSameSite) String() string {
	return string(e)
}

// CookiePriority Represents the cookie's 'Priority' status:
// https://tools.ietf.org/html/draft-west-cookie-priority-00
//
// Note: This type is experimental.
type CookiePriority string

// CookiePriority as enums.
const (
	CookiePriorityNotSet CookiePriority = ""
	CookiePriorityLow    CookiePriority = "Low"
	CookiePriorityMedium CookiePriority = "Medium"
	CookiePriorityHigh   CookiePriority = "High"
)

func (e CookiePriority) Valid() bool {
	switch e {
	case "Low", "Medium", "High":
		return true
	default:
		return false
	}
}

func (e CookiePriority) String() string {
	return string(e)
}

// CookieSourceScheme Represents the source scheme of the origin that
// originally set the cookie. A value of "Unset" allows protocol clients to
// emulate legacy cookie scope for the scheme. This is a temporary ability and
// it will be removed in the future.
//
// Note: This type is experimental.
type CookieSourceScheme string

// CookieSourceScheme as enums.
const (
	CookieSourceSchemeNotSet    CookieSourceScheme = ""
	CookieSourceSchemeUnset     CookieSourceScheme = "Unset"
	CookieSourceSchemeNonSecure CookieSourceScheme = "NonSecure"
	CookieSourceSchemeSecure    CookieSourceScheme = "Secure"
)

func (e CookieSourceScheme) Valid() bool {
	switch e {
	case "Unset", "NonSecure", "Secure":
		return true
	default:
		return false
	}
}

func (e CookieSourceScheme) String() string {
	return string(e)
}

// ResourceTiming Timing information for the request.
type ResourceTiming struct {
	RequestTime  float64 `json:"requestTime"`  // Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime.
	ProxyStart   float64 `json:"proxyStart"`   // Started resolving proxy.
	ProxyEnd     float64 `json:"proxyEnd"`     // Finished resolving proxy.
	DNSStart     float64 `json:"dnsStart"`     // Started DNS address resolve.
	DNSEnd       float64 `json:"dnsEnd"`       // Finished DNS address resolve.
	ConnectStart float64 `json:"connectStart"` // Started connecting to the remote host.
	ConnectEnd   float64 `json:"connectEnd"`   // Connected to the remote host.
	SSLStart     float64 `json:"sslStart"`     // Started SSL handshake.
	SSLEnd       float64 `json:"sslEnd"`       // Finished SSL handshake.
	// WorkerStart Started running ServiceWorker.
	//
	// Note: This property is experimental.
	WorkerStart float64 `json:"workerStart"`
	// WorkerReady Finished Starting ServiceWorker.
	//
	// Note: This property is experimental.
	WorkerReady float64 `json:"workerReady"`
	// WorkerFetchStart Started fetch event.
	//
	// Note: This property is experimental.
	WorkerFetchStart float64 `json:"workerFetchStart"`
	// WorkerRespondWithSettled Settled fetch event respondWith promise.
	//
	// Note: This property is experimental.
	WorkerRespondWithSettled float64 `json:"workerRespondWithSettled"`
	// WorkerRouterEvaluationStart Started ServiceWorker static routing
	// source evaluation.
	//
	// Note: This property is experimental.
	WorkerRouterEvaluationStart *float64 `json:"workerRouterEvaluationStart,omitempty"`
	// WorkerCacheLookupStart Started cache lookup when the source was
	// evaluated to `cache`.
	//
	// Note: This property is experimental.
	WorkerCacheLookupStart *float64 `json:"workerCacheLookupStart,omitempty"`
	SendStart              float64  `json:"sendStart"` // Started sending request.
	SendEnd                float64  `json:"sendEnd"`   // Finished sending request.
	// PushStart Time the server started pushing request.
	//
	// Note: This property is experimental.
	PushStart float64 `json:"pushStart"`
	// PushEnd Time the server finished pushing request.
	//
	// Note: This property is experimental.
	PushEnd float64 `json:"pushEnd"`
	// ReceiveHeadersStart Started receiving response headers.
	//
	// Note: This property is experimental.
	ReceiveHeadersStart float64 `json:"receiveHeadersStart"`
	ReceiveHeadersEnd   float64 `json:"receiveHeadersEnd"` // Finished receiving response headers.
}

// ResourcePriority Loading priority of a resource request.
type ResourcePriority string

// ResourcePriority as enums.
const (
	ResourcePriorityNotSet   ResourcePriority = ""
	ResourcePriorityVeryLow  ResourcePriority = "VeryLow"
	ResourcePriorityLow      ResourcePriority = "Low"
	ResourcePriorityMedium   ResourcePriority = "Medium"
	ResourcePriorityHigh     ResourcePriority = "High"
	ResourcePriorityVeryHigh ResourcePriority = "VeryHigh"
)

func (e ResourcePriority) Valid() bool {
	switch e {
	case "VeryLow", "Low", "Medium", "High", "VeryHigh":
		return true
	default:
		return false
	}
}

func (e ResourcePriority) String() string {
	return string(e)
}

// PostDataEntry Post data entry for HTTP request
type PostDataEntry struct {
	Bytes *string `json:"bytes,omitempty"` // No description.
}

// Request HTTP request data.
type Request struct {
	URL         string  `json:"url"`                   // Request URL (without fragment).
	URLFragment *string `json:"urlFragment,omitempty"` // Fragment of the requested URL starting with hash, if present.
	Method      string  `json:"method"`                // HTTP request method.
	Headers     Headers `json:"headers"`               // HTTP request headers.
	// PostData is deprecated.
	//
	// Deprecated: HTTP POST request data. Use postDataEntries instead.
	PostData    *string `json:"postData,omitempty"`
	HasPostData *bool   `json:"hasPostData,omitempty"` // True when the request has POST data. Note that postData might still be omitted when this flag is true when the data is too long.
	// PostDataEntries Request body elements (post data broken into
	// individual entries).
	//
	// Note: This property is experimental.
	PostDataEntries  []PostDataEntry            `json:"postDataEntries,omitempty"`
	MixedContentType *security.MixedContentType `json:"mixedContentType,omitempty"` // The mixed content type of the request.
	InitialPriority  ResourcePriority           `json:"initialPriority"`            // Priority of the resource request at the time request is sent.
	// ReferrerPolicy The referrer policy of the request, as defined in
	// https://www.w3.org/TR/referrer-policy/
	//
	// Values: "unsafe-url", "no-referrer-when-downgrade", "no-referrer", "origin", "origin-when-cross-origin", "same-origin", "strict-origin", "strict-origin-when-cross-origin".
	ReferrerPolicy string `json:"referrerPolicy"`
	IsLinkPreload  *bool  `json:"isLinkPreload,omitempty"` // Whether is loaded via link preload.
	// TrustTokenParams Set for requests when the TrustToken API is used.
	// Contains the parameters passed by the developer (e.g. via "fetch")
	// as understood by the backend.
	//
	// Note: This property is experimental.
	TrustTokenParams *TrustTokenParams `json:"trustTokenParams,omitempty"`
	// IsSameSite True if this resource request is considered to be the
	// 'same site' as the request corresponding to the main frame.
	//
	// Note: This property is experimental.
	IsSameSite *bool `json:"isSameSite,omitempty"`
	// IsAdRelated True when the resource request is ad-related.
	//
	// Note: This property is experimental.
	IsAdRelated *bool `json:"isAdRelated,omitempty"`
}

// SignedCertificateTimestamp Details of a signed certificate timestamp (SCT).
type SignedCertificateTimestamp struct {
	Status             string  `json:"status"`             // Validation status.
	Origin             string  `json:"origin"`             // Origin.
	LogDescription     string  `json:"logDescription"`     // Log name / description.
	LogID              string  `json:"logId"`              // Log ID.
	Timestamp          float64 `json:"timestamp"`          // Issuance date. Unlike TimeSinceEpoch, this contains the number of milliseconds since January 1, 1970, UTC, not the number of seconds.
	HashAlgorithm      string  `json:"hashAlgorithm"`      // Hash algorithm.
	SignatureAlgorithm string  `json:"signatureAlgorithm"` // Signature algorithm.
	SignatureData      string  `json:"signatureData"`      // Signature data.
}

// SecurityDetails Security details about a request.
type SecurityDetails struct {
	Protocol                          string                            `json:"protocol"`                           // Protocol name (e.g. "TLS 1.2" or "QUIC").
	KeyExchange                       string                            `json:"keyExchange"`                        // Key Exchange used by the connection, or the empty string if not applicable.
	KeyExchangeGroup                  *string                           `json:"keyExchangeGroup,omitempty"`         // (EC)DH group used by the connection, if applicable.
	Cipher                            string                            `json:"cipher"`                             // Cipher name.
	MAC                               *string                           `json:"mac,omitempty"`                      // TLS MAC. Note that AEAD ciphers do not have separate MACs.
	CertificateID                     security.CertificateID            `json:"certificateId"`                      // Certificate ID value.
	SubjectName                       string                            `json:"subjectName"`                        // Certificate subject name.
	SanList                           []string                          `json:"sanList"`                            // Subject Alternative Name (SAN) DNS names and IP addresses.
	Issuer                            string                            `json:"issuer"`                             // Name of the issuing CA.
	ValidFrom                         TimeSinceEpoch                    `json:"validFrom"`                          // Certificate valid from date.
	ValidTo                           TimeSinceEpoch                    `json:"validTo"`                            // Certificate valid to (expiration) date
	SignedCertificateTimestampList    []SignedCertificateTimestamp      `json:"signedCertificateTimestampList"`     // List of signed certificate timestamps (SCTs).
	CertificateTransparencyCompliance CertificateTransparencyCompliance `json:"certificateTransparencyCompliance"`  // Whether the request complied with Certificate Transparency policy
	ServerSignatureAlgorithm          *int                              `json:"serverSignatureAlgorithm,omitempty"` // The signature algorithm used by the server in the TLS server signature, represented as a TLS SignatureScheme code point. Omitted if not applicable or not known.
	EncryptedClientHello              bool                              `json:"encryptedClientHello"`               // Whether the connection used Encrypted ClientHello
}

// CertificateTransparencyCompliance Whether the request complied with
// Certificate Transparency policy.
type CertificateTransparencyCompliance string

// CertificateTransparencyCompliance as enums.
const (
	CertificateTransparencyComplianceNotSet       CertificateTransparencyCompliance = ""
	CertificateTransparencyComplianceUnknown      CertificateTransparencyCompliance = "unknown"
	CertificateTransparencyComplianceNotCompliant CertificateTransparencyCompliance = "not-compliant"
	CertificateTransparencyComplianceCompliant    CertificateTransparencyCompliance = "compliant"
)

func (e CertificateTransparencyCompliance) Valid() bool {
	switch e {
	case "unknown", "not-compliant", "compliant":
		return true
	default:
		return false
	}
}

func (e CertificateTransparencyCompliance) String() string {
	return string(e)
}

// BlockedReason The reason why request was blocked.
type BlockedReason string

// BlockedReason as enums.
const (
	BlockedReasonNotSet                                                  BlockedReason = ""
	BlockedReasonOther                                                   BlockedReason = "other"
	BlockedReasonCSP                                                     BlockedReason = "csp"
	BlockedReasonMixedContent                                            BlockedReason = "mixed-content"
	BlockedReasonOrigin                                                  BlockedReason = "origin"
	BlockedReasonInspector                                               BlockedReason = "inspector"
	BlockedReasonIntegrity                                               BlockedReason = "integrity"
	BlockedReasonSubresourceFilter                                       BlockedReason = "subresource-filter"
	BlockedReasonContentType                                             BlockedReason = "content-type"
	BlockedReasonCOEPFrameResourceNeedsCOEPHeader                        BlockedReason = "coep-frame-resource-needs-coep-header"
	BlockedReasonCOOPSandboxedIframeCannotNavigateToCOOPPage             BlockedReason = "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
	BlockedReasonCORPNotSameOrigin                                       BlockedReason = "corp-not-same-origin"
	BlockedReasonCORPNotSameOriginAfterDefaultedToSameOriginByCOEP       BlockedReason = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
	BlockedReasonCORPNotSameOriginAfterDefaultedToSameOriginByDIP        BlockedReason = "corp-not-same-origin-after-defaulted-to-same-origin-by-dip"
	BlockedReasonCORPNotSameOriginAfterDefaultedToSameOriginByCOEPAndDIP BlockedReason = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip"
	BlockedReasonCORPNotSameSite                                         BlockedReason = "corp-not-same-site"
	BlockedReasonSriMessageSignatureMismatch                             BlockedReason = "sri-message-signature-mismatch"
)

func (e BlockedReason) Valid() bool {
	switch e {
	case "other", "csp", "mixed-content", "origin", "inspector", "integrity", "subresource-filter", "content-type", "coep-frame-resource-needs-coep-header", "coop-sandboxed-iframe-cannot-navigate-to-coop-page", "corp-not-same-origin", "corp-not-same-origin-after-defaulted-to-same-origin-by-coep", "corp-not-same-origin-after-defaulted-to-same-origin-by-dip", "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip", "corp-not-same-site", "sri-message-signature-mismatch":
		return true
	default:
		return false
	}
}

func (e BlockedReason) String() string {
	return string(e)
}

// CORSError The reason why request was blocked.
type CORSError string

// CORSError as enums.
const (
	CORSErrorNotSet                                    CORSError = ""
	CORSErrorDisallowedByMode                          CORSError = "DisallowedByMode"
	CORSErrorInvalidResponse                           CORSError = "InvalidResponse"
	CORSErrorWildcardOriginNotAllowed                  CORSError = "WildcardOriginNotAllowed"
	CORSErrorMissingAllowOriginHeader                  CORSError = "MissingAllowOriginHeader"
	CORSErrorMultipleAllowOriginValues                 CORSError = "MultipleAllowOriginValues"
	CORSErrorInvalidAllowOriginValue                   CORSError = "InvalidAllowOriginValue"
	CORSErrorAllowOriginMismatch                       CORSError = "AllowOriginMismatch"
	CORSErrorInvalidAllowCredentials                   CORSError = "InvalidAllowCredentials"
	CORSErrorCORSDisabledScheme                        CORSError = "CorsDisabledScheme"
	CORSErrorPreflightInvalidStatus                    CORSError = "PreflightInvalidStatus"
	CORSErrorPreflightDisallowedRedirect               CORSError = "PreflightDisallowedRedirect"
	CORSErrorPreflightWildcardOriginNotAllowed         CORSError = "PreflightWildcardOriginNotAllowed"
	CORSErrorPreflightMissingAllowOriginHeader         CORSError = "PreflightMissingAllowOriginHeader"
	CORSErrorPreflightMultipleAllowOriginValues        CORSError = "PreflightMultipleAllowOriginValues"
	CORSErrorPreflightInvalidAllowOriginValue          CORSError = "PreflightInvalidAllowOriginValue"
	CORSErrorPreflightAllowOriginMismatch              CORSError = "PreflightAllowOriginMismatch"
	CORSErrorPreflightInvalidAllowCredentials          CORSError = "PreflightInvalidAllowCredentials"
	CORSErrorPreflightMissingAllowExternal             CORSError = "PreflightMissingAllowExternal"
	CORSErrorPreflightInvalidAllowExternal             CORSError = "PreflightInvalidAllowExternal"
	CORSErrorPreflightMissingAllowPrivateNetwork       CORSError = "PreflightMissingAllowPrivateNetwork"
	CORSErrorPreflightInvalidAllowPrivateNetwork       CORSError = "PreflightInvalidAllowPrivateNetwork"
	CORSErrorInvalidAllowMethodsPreflightResponse      CORSError = "InvalidAllowMethodsPreflightResponse"
	CORSErrorInvalidAllowHeadersPreflightResponse      CORSError = "InvalidAllowHeadersPreflightResponse"
	CORSErrorMethodDisallowedByPreflightResponse       CORSError = "MethodDisallowedByPreflightResponse"
	CORSErrorHeaderDisallowedByPreflightResponse       CORSError = "HeaderDisallowedByPreflightResponse"
	CORSErrorRedirectContainsCredentials               CORSError = "RedirectContainsCredentials"
	CORSErrorInsecurePrivateNetwork                    CORSError = "InsecurePrivateNetwork"
	CORSErrorInvalidPrivateNetworkAccess               CORSError = "InvalidPrivateNetworkAccess"
	CORSErrorUnexpectedPrivateNetworkAccess            CORSError = "UnexpectedPrivateNetworkAccess"
	CORSErrorNoCORSRedirectModeNotFollow               CORSError = "NoCorsRedirectModeNotFollow"
	CORSErrorPreflightMissingPrivateNetworkAccessID    CORSError = "PreflightMissingPrivateNetworkAccessId"
	CORSErrorPreflightMissingPrivateNetworkAccessName  CORSError = "PreflightMissingPrivateNetworkAccessName"
	CORSErrorPrivateNetworkAccessPermissionUnavailable CORSError = "PrivateNetworkAccessPermissionUnavailable"
	CORSErrorPrivateNetworkAccessPermissionDenied      CORSError = "PrivateNetworkAccessPermissionDenied"
	CORSErrorLocalNetworkAccessPermissionDenied        CORSError = "LocalNetworkAccessPermissionDenied"
)

func (e CORSError) Valid() bool {
	switch e {
	case "DisallowedByMode", "InvalidResponse", "WildcardOriginNotAllowed", "MissingAllowOriginHeader", "MultipleAllowOriginValues", "InvalidAllowOriginValue", "AllowOriginMismatch", "InvalidAllowCredentials", "CorsDisabledScheme", "PreflightInvalidStatus", "PreflightDisallowedRedirect", "PreflightWildcardOriginNotAllowed", "PreflightMissingAllowOriginHeader", "PreflightMultipleAllowOriginValues", "PreflightInvalidAllowOriginValue", "PreflightAllowOriginMismatch", "PreflightInvalidAllowCredentials", "PreflightMissingAllowExternal", "PreflightInvalidAllowExternal", "PreflightMissingAllowPrivateNetwork", "PreflightInvalidAllowPrivateNetwork", "InvalidAllowMethodsPreflightResponse", "InvalidAllowHeadersPreflightResponse", "MethodDisallowedByPreflightResponse", "HeaderDisallowedByPreflightResponse", "RedirectContainsCredentials", "InsecurePrivateNetwork", "InvalidPrivateNetworkAccess", "UnexpectedPrivateNetworkAccess", "NoCorsRedirectModeNotFollow", "PreflightMissingPrivateNetworkAccessId", "PreflightMissingPrivateNetworkAccessName", "PrivateNetworkAccessPermissionUnavailable", "PrivateNetworkAccessPermissionDenied", "LocalNetworkAccessPermissionDenied":
		return true
	default:
		return false
	}
}

func (e CORSError) String() string {
	return string(e)
}

// CORSErrorStatus
type CORSErrorStatus struct {
	CORSError       CORSError `json:"corsError"`       // No description.
	FailedParameter string    `json:"failedParameter"` // No description.
}

// ServiceWorkerResponseSource Source of serviceworker response.
type ServiceWorkerResponseSource string

// ServiceWorkerResponseSource as enums.
const (
	ServiceWorkerResponseSourceNotSet       ServiceWorkerResponseSource = ""
	ServiceWorkerResponseSourceCacheStorage ServiceWorkerResponseSource = "cache-storage"
	ServiceWorkerResponseSourceHTTPCache    ServiceWorkerResponseSource = "http-cache"
	ServiceWorkerResponseSourceFallbackCode ServiceWorkerResponseSource = "fallback-code"
	ServiceWorkerResponseSourceNetwork      ServiceWorkerResponseSource = "network"
)

func (e ServiceWorkerResponseSource) Valid() bool {
	switch e {
	case "cache-storage", "http-cache", "fallback-code", "network":
		return true
	default:
		return false
	}
}

func (e ServiceWorkerResponseSource) String() string {
	return string(e)
}

// TrustTokenParams Determines what type of Trust Token operation is executed
// and depending on the type, some additional parameters. The values are
// specified in third_party/blink/renderer/core/fetch/trust_token.idl.
//
// Note: This type is experimental.
type TrustTokenParams struct {
	Operation TrustTokenOperationType `json:"operation"` // No description.
	// RefreshPolicy Only set for "token-redemption" operation and
	// determine whether to request a fresh SRR or use a still valid cached
	// SRR.
	//
	// Values: "UseCached", "Refresh".
	RefreshPolicy string   `json:"refreshPolicy"`
	Issuers       []string `json:"issuers,omitempty"` // Origins of issuers from whom to request tokens or redemption records.
}

// TrustTokenOperationType
//
// Note: This type is experimental.
type TrustTokenOperationType string

// TrustTokenOperationType as enums.
const (
	TrustTokenOperationTypeNotSet     TrustTokenOperationType = ""
	TrustTokenOperationTypeIssuance   TrustTokenOperationType = "Issuance"
	TrustTokenOperationTypeRedemption TrustTokenOperationType = "Redemption"
	TrustTokenOperationTypeSigning    TrustTokenOperationType = "Signing"
)

func (e TrustTokenOperationType) Valid() bool {
	switch e {
	case "Issuance", "Redemption", "Signing":
		return true
	default:
		return false
	}
}

func (e TrustTokenOperationType) String() string {
	return string(e)
}

// AlternateProtocolUsage The reason why Chrome uses a specific transport
// protocol for HTTP semantics.
//
// Note: This type is experimental.
type AlternateProtocolUsage string

// AlternateProtocolUsage as enums.
const (
	AlternateProtocolUsageNotSet                       AlternateProtocolUsage = ""
	AlternateProtocolUsageAlternativeJobWonWithoutRace AlternateProtocolUsage = "alternativeJobWonWithoutRace"
	AlternateProtocolUsageAlternativeJobWonRace        AlternateProtocolUsage = "alternativeJobWonRace"
	AlternateProtocolUsageMainJobWonRace               AlternateProtocolUsage = "mainJobWonRace"
	AlternateProtocolUsageMappingMissing               AlternateProtocolUsage = "mappingMissing"
	AlternateProtocolUsageBroken                       AlternateProtocolUsage = "broken"
	AlternateProtocolUsageDNSAlpnH3JobWonWithoutRace   AlternateProtocolUsage = "dnsAlpnH3JobWonWithoutRace"
	AlternateProtocolUsageDNSAlpnH3JobWonRace          AlternateProtocolUsage = "dnsAlpnH3JobWonRace"
	AlternateProtocolUsageUnspecifiedReason            AlternateProtocolUsage = "unspecifiedReason"
)

func (e AlternateProtocolUsage) Valid() bool {
	switch e {
	case "alternativeJobWonWithoutRace", "alternativeJobWonRace", "mainJobWonRace", "mappingMissing", "broken", "dnsAlpnH3JobWonWithoutRace", "dnsAlpnH3JobWonRace", "unspecifiedReason":
		return true
	default:
		return false
	}
}

func (e AlternateProtocolUsage) String() string {
	return string(e)
}

// ServiceWorkerRouterSource Source of service worker router.
type ServiceWorkerRouterSource string

// ServiceWorkerRouterSource as enums.
const (
	ServiceWorkerRouterSourceNotSet                     ServiceWorkerRouterSource = ""
	ServiceWorkerRouterSourceNetwork                    ServiceWorkerRouterSource = "network"
	ServiceWorkerRouterSourceCache                      ServiceWorkerRouterSource = "cache"
	ServiceWorkerRouterSourceFetchEvent                 ServiceWorkerRouterSource = "fetch-event"
	ServiceWorkerRouterSourceRaceNetworkAndFetchHandler ServiceWorkerRouterSource = "race-network-and-fetch-handler"
	ServiceWorkerRouterSourceRaceNetworkAndCache        ServiceWorkerRouterSource = "race-network-and-cache"
)

func (e ServiceWorkerRouterSource) Valid() bool {
	switch e {
	case "network", "cache", "fetch-event", "race-network-and-fetch-handler", "race-network-and-cache":
		return true
	default:
		return false
	}
}

func (e ServiceWorkerRouterSource) String() string {
	return string(e)
}

// ServiceWorkerRouterInfo
//
// Note: This type is experimental.
type ServiceWorkerRouterInfo struct {
	RuleIDMatched     *int                      `json:"ruleIdMatched,omitempty"`     // ID of the rule matched. If there is a matched rule, this field will be set, otherwiser no value will be set.
	MatchedSourceType ServiceWorkerRouterSource `json:"matchedSourceType,omitempty"` // The router source of the matched rule. If there is a matched rule, this field will be set, otherwise no value will be set.
	ActualSourceType  ServiceWorkerRouterSource `json:"actualSourceType,omitempty"`  // The actual router source used.
}

// Response HTTP response data.
type Response struct {
	URL        string  `json:"url"`        // Response URL. This URL can be different from CachedResource.url in case of redirect.
	Status     int     `json:"status"`     // HTTP response status code.
	StatusText string  `json:"statusText"` // HTTP response status text.
	Headers    Headers `json:"headers"`    // HTTP response headers.
	// HeadersText is deprecated.
	//
	// Deprecated: HTTP response headers text. This has been replaced by
	// the headers in Network.responseReceivedExtraInfo.
	HeadersText    *string `json:"headersText,omitempty"`
	MimeType       string  `json:"mimeType"`                 // Resource mimeType as determined by the browser.
	Charset        string  `json:"charset"`                  // Resource charset as determined by the browser (if applicable).
	RequestHeaders Headers `json:"requestHeaders,omitempty"` // Refined HTTP request headers that were actually transmitted over the network.
	// RequestHeadersText is deprecated.
	//
	// Deprecated: HTTP request headers text. This has been replaced by
	// the headers in Network.requestWillBeSentExtraInfo.
	RequestHeadersText *string `json:"requestHeadersText,omitempty"`
	ConnectionReused   bool    `json:"connectionReused"`            // Specifies whether physical connection was actually reused for this request.
	ConnectionID       float64 `json:"connectionId"`                // Physical connection id that was actually used for this request.
	RemoteIPAddress    *string `json:"remoteIPAddress,omitempty"`   // Remote IP address.
	RemotePort         *int    `json:"remotePort,omitempty"`        // Remote port.
	FromDiskCache      *bool   `json:"fromDiskCache,omitempty"`     // Specifies that the request was served from the disk cache.
	FromServiceWorker  *bool   `json:"fromServiceWorker,omitempty"` // Specifies that the request was served from the ServiceWorker.
	FromPrefetchCache  *bool   `json:"fromPrefetchCache,omitempty"` // Specifies that the request was served from the prefetch cache.
	FromEarlyHints     *bool   `json:"fromEarlyHints,omitempty"`    // Specifies that the request was served from the prefetch cache.
	// ServiceWorkerRouterInfo Information about how ServiceWorker Static
	// Router API was used. If this field is set with `matchedSourceType`
	// field, a matching rule is found. If this field is set without
	// `matchedSource`, no matching rule is found. Otherwise, the API is
	// not used.
	//
	// Note: This property is experimental.
	ServiceWorkerRouterInfo     *ServiceWorkerRouterInfo    `json:"serviceWorkerRouterInfo,omitempty"`
	EncodedDataLength           float64                     `json:"encodedDataLength"`                     // Total number of bytes received for this request so far.
	Timing                      *ResourceTiming             `json:"timing,omitempty"`                      // Timing information for the given request.
	ServiceWorkerResponseSource ServiceWorkerResponseSource `json:"serviceWorkerResponseSource,omitempty"` // Response source of response from ServiceWorker.
	ResponseTime                TimeSinceEpoch              `json:"responseTime,omitempty"`                // The time at which the returned response was generated.
	CacheStorageCacheName       *string                     `json:"cacheStorageCacheName,omitempty"`       // Cache Storage Cache Name.
	Protocol                    *string                     `json:"protocol,omitempty"`                    // Protocol used to fetch this request.
	// AlternateProtocolUsage The reason why Chrome uses a specific
	// transport protocol for HTTP semantics.
	//
	// Note: This property is experimental.
	AlternateProtocolUsage AlternateProtocolUsage `json:"alternateProtocolUsage,omitempty"`
	SecurityState          security.State         `json:"securityState"`             // Security state of the request resource.
	SecurityDetails        *SecurityDetails       `json:"securityDetails,omitempty"` // Security details for the request.
}

// WebSocketRequest WebSocket request data.
type WebSocketRequest struct {
	Headers Headers `json:"headers"` // HTTP request headers.
}

// WebSocketResponse WebSocket response data.
type WebSocketResponse struct {
	Status             int     `json:"status"`                       // HTTP response status code.
	StatusText         string  `json:"statusText"`                   // HTTP response status text.
	Headers            Headers `json:"headers"`                      // HTTP response headers.
	HeadersText        *string `json:"headersText,omitempty"`        // HTTP response headers text.
	RequestHeaders     Headers `json:"requestHeaders,omitempty"`     // HTTP request headers.
	RequestHeadersText *string `json:"requestHeadersText,omitempty"` // HTTP request headers text.
}

// WebSocketFrame WebSocket message data. This represents an entire WebSocket
// message, not just a fragmented frame as the name suggests.
type WebSocketFrame struct {
	Opcode      float64 `json:"opcode"`      // WebSocket message opcode.
	Mask        bool    `json:"mask"`        // WebSocket message mask.
	PayloadData string  `json:"payloadData"` // WebSocket message payload data. If the opcode is 1, this is a text message and payloadData is a UTF-8 string. If the opcode isn't 1, then payloadData is a base64 encoded string representing binary data.
}

// CachedResource Information about the cached resource.
type CachedResource struct {
	URL      string       `json:"url"`                // Resource URL. This is the url of the original network request.
	Type     ResourceType `json:"type"`               // Type of this resource.
	Response *Response    `json:"response,omitempty"` // Cached response data.
	BodySize float64      `json:"bodySize"`           // Cached response body size.
}

// Initiator Information about the request initiator.
type Initiator struct {
	// Type Type of this initiator.
	//
	// Values: "parser", "script", "preload", "SignedExchange", "preflight", "FedCM", "other".
	Type         string              `json:"type"`
	Stack        *runtime.StackTrace `json:"stack,omitempty"`        // Initiator JavaScript stack trace, set for Script only. Requires the Debugger domain to be enabled.
	URL          *string             `json:"url,omitempty"`          // Initiator URL, set for Parser type or for Script type (when script is importing module) or for SignedExchange type.
	LineNumber   *float64            `json:"lineNumber,omitempty"`   // Initiator line number, set for Parser type or for Script type (when script is importing module) (0-based).
	ColumnNumber *float64            `json:"columnNumber,omitempty"` // Initiator column number, set for Parser type or for Script type (when script is importing module) (0-based).
	RequestID    *RequestID          `json:"requestId,omitempty"`    // Set if another request triggered this request (e.g. preflight).
}

// CookiePartitionKey cookiePartitionKey object The representation of the
// components of the key that are created by the cookiePartitionKey class
// contained in net/cookies/cookie_partition_key.h.
//
// Note: This type is experimental.
type CookiePartitionKey struct {
	TopLevelSite         string `json:"topLevelSite"`         // The site of the top-level URL the browser was visiting at the start of the request to the endpoint that set the cookie.
	HasCrossSiteAncestor bool   `json:"hasCrossSiteAncestor"` // Indicates if the cookie has any ancestors that are cross-site to the topLevelSite.
}

// Cookie Cookie object
type Cookie struct {
	Name     string         `json:"name"`               // Cookie name.
	Value    string         `json:"value"`              // Cookie value.
	Domain   string         `json:"domain"`             // Cookie domain.
	Path     string         `json:"path"`               // Cookie path.
	Expires  float64        `json:"expires"`            // Cookie expiration date as the number of seconds since the UNIX epoch. The value is set to -1 if the expiry date is not set. The value can be null for values that cannot be represented in JSON (Â±Inf).
	Size     int            `json:"size"`               // Cookie size.
	HTTPOnly bool           `json:"httpOnly"`           // True if cookie is http-only.
	Secure   bool           `json:"secure"`             // True if cookie is secure.
	Session  bool           `json:"session"`            // True in case of session cookie.
	SameSite CookieSameSite `json:"sameSite,omitempty"` // Cookie SameSite type.
	// Priority Cookie Priority
	//
	// Note: This property is experimental.
	Priority CookiePriority `json:"priority"`
	// SameParty is deprecated.
	//
	// Deprecated: True if cookie is SameParty.
	//
	// Note: This property is experimental.
	SameParty bool `json:"sameParty"`
	// SourceScheme Cookie source scheme type.
	//
	// Note: This property is experimental.
	SourceScheme CookieSourceScheme `json:"sourceScheme"`
	// SourcePort Cookie source port. Valid values are {-1, [1, 65535]},
	// -1 indicates an unspecified port. An unspecified port value allows
	// protocol clients to emulate legacy cookie scope for the port. This
	// is a temporary ability and it will be removed in the future.
	//
	// Note: This property is experimental.
	SourcePort int `json:"sourcePort"`
	// PartitionKey Cookie partition key.
	//
	// Note: This property is experimental.
	PartitionKey *CookiePartitionKey `json:"partitionKey,omitempty"`
	// PartitionKeyOpaque True if cookie partition key is opaque.
	//
	// Note: This property is experimental.
	PartitionKeyOpaque *bool `json:"partitionKeyOpaque,omitempty"`
}

// SetCookieBlockedReason Types of reasons why a cookie may not be stored from
// a response.
//
// Note: This type is experimental.
type SetCookieBlockedReason string

// SetCookieBlockedReason as enums.
const (
	SetCookieBlockedReasonNotSet                                   SetCookieBlockedReason = ""
	SetCookieBlockedReasonSecureOnly                               SetCookieBlockedReason = "SecureOnly"
	SetCookieBlockedReasonSameSiteStrict                           SetCookieBlockedReason = "SameSiteStrict"
	SetCookieBlockedReasonSameSiteLax                              SetCookieBlockedReason = "SameSiteLax"
	SetCookieBlockedReasonSameSiteUnspecifiedTreatedAsLax          SetCookieBlockedReason = "SameSiteUnspecifiedTreatedAsLax"
	SetCookieBlockedReasonSameSiteNoneInsecure                     SetCookieBlockedReason = "SameSiteNoneInsecure"
	SetCookieBlockedReasonUserPreferences                          SetCookieBlockedReason = "UserPreferences"
	SetCookieBlockedReasonThirdPartyPhaseout                       SetCookieBlockedReason = "ThirdPartyPhaseout"
	SetCookieBlockedReasonThirdPartyBlockedInFirstPartySet         SetCookieBlockedReason = "ThirdPartyBlockedInFirstPartySet"
	SetCookieBlockedReasonSyntaxError                              SetCookieBlockedReason = "SyntaxError"
	SetCookieBlockedReasonSchemeNotSupported                       SetCookieBlockedReason = "SchemeNotSupported"
	SetCookieBlockedReasonOverwriteSecure                          SetCookieBlockedReason = "OverwriteSecure"
	SetCookieBlockedReasonInvalidDomain                            SetCookieBlockedReason = "InvalidDomain"
	SetCookieBlockedReasonInvalidPrefix                            SetCookieBlockedReason = "InvalidPrefix"
	SetCookieBlockedReasonUnknownError                             SetCookieBlockedReason = "UnknownError"
	SetCookieBlockedReasonSchemefulSameSiteStrict                  SetCookieBlockedReason = "SchemefulSameSiteStrict"
	SetCookieBlockedReasonSchemefulSameSiteLax                     SetCookieBlockedReason = "SchemefulSameSiteLax"
	SetCookieBlockedReasonSchemefulSameSiteUnspecifiedTreatedAsLax SetCookieBlockedReason = "SchemefulSameSiteUnspecifiedTreatedAsLax"
	SetCookieBlockedReasonSamePartyFromCrossPartyContext           SetCookieBlockedReason = "SamePartyFromCrossPartyContext"
	SetCookieBlockedReasonSamePartyConflictsWithOtherAttributes    SetCookieBlockedReason = "SamePartyConflictsWithOtherAttributes"
	SetCookieBlockedReasonNameValuePairExceedsMaxSize              SetCookieBlockedReason = "NameValuePairExceedsMaxSize"
	SetCookieBlockedReasonDisallowedCharacter                      SetCookieBlockedReason = "DisallowedCharacter"
	SetCookieBlockedReasonNoCookieContent                          SetCookieBlockedReason = "NoCookieContent"
)

func (e SetCookieBlockedReason) Valid() bool {
	switch e {
	case "SecureOnly", "SameSiteStrict", "SameSiteLax", "SameSiteUnspecifiedTreatedAsLax", "SameSiteNoneInsecure", "UserPreferences", "ThirdPartyPhaseout", "ThirdPartyBlockedInFirstPartySet", "SyntaxError", "SchemeNotSupported", "OverwriteSecure", "InvalidDomain", "InvalidPrefix", "UnknownError", "SchemefulSameSiteStrict", "SchemefulSameSiteLax", "SchemefulSameSiteUnspecifiedTreatedAsLax", "SamePartyFromCrossPartyContext", "SamePartyConflictsWithOtherAttributes", "NameValuePairExceedsMaxSize", "DisallowedCharacter", "NoCookieContent":
		return true
	default:
		return false
	}
}

func (e SetCookieBlockedReason) String() string {
	return string(e)
}

// CookieBlockedReason Types of reasons why a cookie may not be sent with a
// request.
//
// Note: This type is experimental.
type CookieBlockedReason string

// CookieBlockedReason as enums.
const (
	CookieBlockedReasonNotSet                                   CookieBlockedReason = ""
	CookieBlockedReasonSecureOnly                               CookieBlockedReason = "SecureOnly"
	CookieBlockedReasonNotOnPath                                CookieBlockedReason = "NotOnPath"
	CookieBlockedReasonDomainMismatch                           CookieBlockedReason = "DomainMismatch"
	CookieBlockedReasonSameSiteStrict                           CookieBlockedReason = "SameSiteStrict"
	CookieBlockedReasonSameSiteLax                              CookieBlockedReason = "SameSiteLax"
	CookieBlockedReasonSameSiteUnspecifiedTreatedAsLax          CookieBlockedReason = "SameSiteUnspecifiedTreatedAsLax"
	CookieBlockedReasonSameSiteNoneInsecure                     CookieBlockedReason = "SameSiteNoneInsecure"
	CookieBlockedReasonUserPreferences                          CookieBlockedReason = "UserPreferences"
	CookieBlockedReasonThirdPartyPhaseout                       CookieBlockedReason = "ThirdPartyPhaseout"
	CookieBlockedReasonThirdPartyBlockedInFirstPartySet         CookieBlockedReason = "ThirdPartyBlockedInFirstPartySet"
	CookieBlockedReasonUnknownError                             CookieBlockedReason = "UnknownError"
	CookieBlockedReasonSchemefulSameSiteStrict                  CookieBlockedReason = "SchemefulSameSiteStrict"
	CookieBlockedReasonSchemefulSameSiteLax                     CookieBlockedReason = "SchemefulSameSiteLax"
	CookieBlockedReasonSchemefulSameSiteUnspecifiedTreatedAsLax CookieBlockedReason = "SchemefulSameSiteUnspecifiedTreatedAsLax"
	CookieBlockedReasonSamePartyFromCrossPartyContext           CookieBlockedReason = "SamePartyFromCrossPartyContext"
	CookieBlockedReasonNameValuePairExceedsMaxSize              CookieBlockedReason = "NameValuePairExceedsMaxSize"
	CookieBlockedReasonPortMismatch                             CookieBlockedReason = "PortMismatch"
	CookieBlockedReasonSchemeMismatch                           CookieBlockedReason = "SchemeMismatch"
	CookieBlockedReasonAnonymousContext                         CookieBlockedReason = "AnonymousContext"
)

func (e CookieBlockedReason) Valid() bool {
	switch e {
	case "SecureOnly", "NotOnPath", "DomainMismatch", "SameSiteStrict", "SameSiteLax", "SameSiteUnspecifiedTreatedAsLax", "SameSiteNoneInsecure", "UserPreferences", "ThirdPartyPhaseout", "ThirdPartyBlockedInFirstPartySet", "UnknownError", "SchemefulSameSiteStrict", "SchemefulSameSiteLax", "SchemefulSameSiteUnspecifiedTreatedAsLax", "SamePartyFromCrossPartyContext", "NameValuePairExceedsMaxSize", "PortMismatch", "SchemeMismatch", "AnonymousContext":
		return true
	default:
		return false
	}
}

func (e CookieBlockedReason) String() string {
	return string(e)
}

// CookieExemptionReason Types of reasons why a cookie should have been
// blocked by 3PCD but is exempted for the request.
//
// Note: This type is experimental.
type CookieExemptionReason string

// CookieExemptionReason as enums.
const (
	CookieExemptionReasonNotSet                       CookieExemptionReason = ""
	CookieExemptionReasonNone                         CookieExemptionReason = "None"
	CookieExemptionReasonUserSetting                  CookieExemptionReason = "UserSetting"
	CookieExemptionReasonTPCDMetadata                 CookieExemptionReason = "TPCDMetadata"
	CookieExemptionReasonTPCDDeprecationTrial         CookieExemptionReason = "TPCDDeprecationTrial"
	CookieExemptionReasonTopLevelTPCDDeprecationTrial CookieExemptionReason = "TopLevelTPCDDeprecationTrial"
	CookieExemptionReasonTPCDHeuristics               CookieExemptionReason = "TPCDHeuristics"
	CookieExemptionReasonEnterprisePolicy             CookieExemptionReason = "EnterprisePolicy"
	CookieExemptionReasonStorageAccess                CookieExemptionReason = "StorageAccess"
	CookieExemptionReasonTopLevelStorageAccess        CookieExemptionReason = "TopLevelStorageAccess"
	CookieExemptionReasonScheme                       CookieExemptionReason = "Scheme"
	CookieExemptionReasonSameSiteNoneCookiesInSandbox CookieExemptionReason = "SameSiteNoneCookiesInSandbox"
)

func (e CookieExemptionReason) Valid() bool {
	switch e {
	case "None", "UserSetting", "TPCDMetadata", "TPCDDeprecationTrial", "TopLevelTPCDDeprecationTrial", "TPCDHeuristics", "EnterprisePolicy", "StorageAccess", "TopLevelStorageAccess", "Scheme", "SameSiteNoneCookiesInSandbox":
		return true
	default:
		return false
	}
}

func (e CookieExemptionReason) String() string {
	return string(e)
}

// BlockedSetCookieWithReason A cookie which was not stored from a response
// with the corresponding reason.
//
// Note: This type is experimental.
type BlockedSetCookieWithReason struct {
	BlockedReasons []SetCookieBlockedReason `json:"blockedReasons"`   // The reason(s) this cookie was blocked.
	CookieLine     string                   `json:"cookieLine"`       // The string representing this individual cookie as it would appear in the header. This is not the entire "cookie" or "set-cookie" header which could have multiple cookies.
	Cookie         *Cookie                  `json:"cookie,omitempty"` // The cookie object which represents the cookie which was not stored. It is optional because sometimes complete cookie information is not available, such as in the case of parsing errors.
}

// ExemptedSetCookieWithReason A cookie should have been blocked by 3PCD but
// is exempted and stored from a response with the corresponding reason. A
// cookie could only have at most one exemption reason.
//
// Note: This type is experimental.
type ExemptedSetCookieWithReason struct {
	ExemptionReason CookieExemptionReason `json:"exemptionReason"` // The reason the cookie was exempted.
	CookieLine      string                `json:"cookieLine"`      // The string representing this individual cookie as it would appear in the header.
	Cookie          Cookie                `json:"cookie"`          // The cookie object representing the cookie.
}

// AssociatedCookie A cookie associated with the request which may or may not
// be sent with it. Includes the cookies itself and reasons for blocking or
// exemption.
//
// Note: This type is experimental.
type AssociatedCookie struct {
	Cookie          Cookie                `json:"cookie"`                    // The cookie object representing the cookie which was not sent.
	BlockedReasons  []CookieBlockedReason `json:"blockedReasons"`            // The reason(s) the cookie was blocked. If empty means the cookie is included.
	ExemptionReason CookieExemptionReason `json:"exemptionReason,omitempty"` // The reason the cookie should have been blocked by 3PCD but is exempted. A cookie could only have at most one exemption reason.
}

// CookieParam Cookie parameter object
type CookieParam struct {
	Name     string         `json:"name"`               // Cookie name.
	Value    string         `json:"value"`              // Cookie value.
	URL      *string        `json:"url,omitempty"`      // The request-URI to associate with the setting of the cookie. This value can affect the default domain, path, source port, and source scheme values of the created cookie.
	Domain   *string        `json:"domain,omitempty"`   // Cookie domain.
	Path     *string        `json:"path,omitempty"`     // Cookie path.
	Secure   *bool          `json:"secure,omitempty"`   // True if cookie is secure.
	HTTPOnly *bool          `json:"httpOnly,omitempty"` // True if cookie is http-only.
	SameSite CookieSameSite `json:"sameSite,omitempty"` // Cookie SameSite type.
	Expires  TimeSinceEpoch `json:"expires,omitempty"`  // Cookie expiration date, session cookie if not set
	// Priority Cookie Priority.
	//
	// Note: This property is experimental.
	Priority CookiePriority `json:"priority,omitempty"`
	// SameParty True if cookie is SameParty.
	//
	// Note: This property is experimental.
	SameParty *bool `json:"sameParty,omitempty"`
	// SourceScheme Cookie source scheme type.
	//
	// Note: This property is experimental.
	SourceScheme CookieSourceScheme `json:"sourceScheme,omitempty"`
	// SourcePort Cookie source port. Valid values are {-1, [1, 65535]},
	// -1 indicates an unspecified port. An unspecified port value allows
	// protocol clients to emulate legacy cookie scope for the port. This
	// is a temporary ability and it will be removed in the future.
	//
	// Note: This property is experimental.
	SourcePort *int `json:"sourcePort,omitempty"`
	// PartitionKey Cookie partition key. If not set, the cookie will be
	// set as not partitioned.
	//
	// Note: This property is experimental.
	PartitionKey *CookiePartitionKey `json:"partitionKey,omitempty"`
}

// AuthChallenge Authorization challenge for HTTP status code 401 or 407.
//
// Note: This type is experimental.
type AuthChallenge struct {
	// Source Source of the authentication challenge.
	//
	// Values: "Server", "Proxy".
	Source *string `json:"source,omitempty"`
	Origin string  `json:"origin"` // Origin of the challenger.
	Scheme string  `json:"scheme"` // The authentication scheme used, such as basic or digest
	Realm  string  `json:"realm"`  // The realm of the challenge. May be empty.
}

// AuthChallengeResponse Response to an AuthChallenge.
//
// Note: This type is experimental.
type AuthChallengeResponse struct {
	// Response The decision on what to do in response to the
	// authorization challenge. Default means deferring to the default
	// behavior of the net stack, which will likely either the Cancel
	// authentication or display a popup dialog box.
	//
	// Values: "Default", "CancelAuth", "ProvideCredentials".
	Response string  `json:"response"`
	Username *string `json:"username,omitempty"` // The username to provide, possibly empty. Should only be set if response is ProvideCredentials.
	Password *string `json:"password,omitempty"` // The password to provide, possibly empty. Should only be set if response is ProvideCredentials.
}

// InterceptionStage Stages of the interception to begin intercepting. Request
// will intercept before the request is sent. Response will intercept after the
// response is received.
//
// Note: This type is experimental.
type InterceptionStage string

// InterceptionStage as enums.
const (
	InterceptionStageNotSet          InterceptionStage = ""
	InterceptionStageRequest         InterceptionStage = "Request"
	InterceptionStageHeadersReceived InterceptionStage = "HeadersReceived"
)

func (e InterceptionStage) Valid() bool {
	switch e {
	case "Request", "HeadersReceived":
		return true
	default:
		return false
	}
}

func (e InterceptionStage) String() string {
	return string(e)
}

// RequestPattern Request pattern for interception.
//
// Note: This type is experimental.
type RequestPattern struct {
	URLPattern        *string           `json:"urlPattern,omitempty"`        // Wildcards (`'*'` -> zero or more, `'?'` -> exactly one) are allowed. Escape character is backslash. Omitting is equivalent to `"*"`.
	ResourceType      ResourceType      `json:"resourceType,omitempty"`      // If set, only requests for matching resource types will be intercepted.
	InterceptionStage InterceptionStage `json:"interceptionStage,omitempty"` // Stage at which to begin intercepting requests. Default is Request.
}

// SignedExchangeSignature Information about a signed exchange signature.
// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1
//
// Note: This type is experimental.
type SignedExchangeSignature struct {
	Label        string   `json:"label"`                  // Signed exchange signature label.
	Signature    string   `json:"signature"`              // The hex string of signed exchange signature.
	Integrity    string   `json:"integrity"`              // Signed exchange signature integrity.
	CertURL      *string  `json:"certUrl,omitempty"`      // Signed exchange signature cert Url.
	CertSha256   *string  `json:"certSha256,omitempty"`   // The hex string of signed exchange signature cert sha256.
	ValidityURL  string   `json:"validityUrl"`            // Signed exchange signature validity Url.
	Date         int      `json:"date"`                   // Signed exchange signature date.
	Expires      int      `json:"expires"`                // Signed exchange signature expires.
	Certificates []string `json:"certificates,omitempty"` // The encoded certificates.
}

// SignedExchangeHeader Information about a signed exchange header.
// https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation
//
// Note: This type is experimental.
type SignedExchangeHeader struct {
	RequestURL      string                    `json:"requestUrl"`      // Signed exchange request URL.
	ResponseCode    int                       `json:"responseCode"`    // Signed exchange response code.
	ResponseHeaders Headers                   `json:"responseHeaders"` // Signed exchange response headers.
	Signatures      []SignedExchangeSignature `json:"signatures"`      // Signed exchange response signature.
	HeaderIntegrity string                    `json:"headerIntegrity"` // Signed exchange header integrity hash in the form of `sha256-<base64-hash-value>`.
}

// SignedExchangeErrorField Field type for a signed exchange related error.
//
// Note: This type is experimental.
type SignedExchangeErrorField string

// SignedExchangeErrorField as enums.
const (
	SignedExchangeErrorFieldNotSet               SignedExchangeErrorField = ""
	SignedExchangeErrorFieldSignatureSig         SignedExchangeErrorField = "signatureSig"
	SignedExchangeErrorFieldSignatureIntegrity   SignedExchangeErrorField = "signatureIntegrity"
	SignedExchangeErrorFieldSignatureCertURL     SignedExchangeErrorField = "signatureCertUrl"
	SignedExchangeErrorFieldSignatureCertSha256  SignedExchangeErrorField = "signatureCertSha256"
	SignedExchangeErrorFieldSignatureValidityURL SignedExchangeErrorField = "signatureValidityUrl"
	SignedExchangeErrorFieldSignatureTimestamps  SignedExchangeErrorField = "signatureTimestamps"
)

func (e SignedExchangeErrorField) Valid() bool {
	switch e {
	case "signatureSig", "signatureIntegrity", "signatureCertUrl", "signatureCertSha256", "signatureValidityUrl", "signatureTimestamps":
		return true
	default:
		return false
	}
}

func (e SignedExchangeErrorField) String() string {
	return string(e)
}

// SignedExchangeError Information about a signed exchange response.
//
// Note: This type is experimental.
type SignedExchangeError struct {
	Message        string                   `json:"message"`                  // Error message.
	SignatureIndex *int                     `json:"signatureIndex,omitempty"` // The index of the signature which caused the error.
	ErrorField     SignedExchangeErrorField `json:"errorField,omitempty"`     // The field which caused the error.
}

// SignedExchangeInfo Information about a signed exchange response.
//
// Note: This type is experimental.
type SignedExchangeInfo struct {
	OuterResponse   Response              `json:"outerResponse"`             // The outer response of signed HTTP exchange which was received from network.
	HasExtraInfo    bool                  `json:"hasExtraInfo"`              // Whether network response for the signed exchange was accompanied by extra headers.
	Header          *SignedExchangeHeader `json:"header,omitempty"`          // Information about the signed exchange header.
	SecurityDetails *SecurityDetails      `json:"securityDetails,omitempty"` // Security details for the signed exchange header.
	Errors          []SignedExchangeError `json:"errors,omitempty"`          // Errors occurred while handling the signed exchange.
}

// ContentEncoding List of content encodings supported by the backend.
//
// Note: This type is experimental.
type ContentEncoding string

// ContentEncoding as enums.
const (
	ContentEncodingNotSet  ContentEncoding = ""
	ContentEncodingDeflate ContentEncoding = "deflate"
	ContentEncodingGzip    ContentEncoding = "gzip"
	ContentEncodingBR      ContentEncoding = "br"
	ContentEncodingZstd    ContentEncoding = "zstd"
)

func (e ContentEncoding) Valid() bool {
	switch e {
	case "deflate", "gzip", "br", "zstd":
		return true
	default:
		return false
	}
}

func (e ContentEncoding) String() string {
	return string(e)
}

// Conditions
//
// Note: This type is experimental.
type Conditions struct {
	URLPattern         string         `json:"urlPattern"`                  // Only matching requests will be affected by these conditions. Patterns use the URLPattern constructor string syntax (https://urlpattern.spec.whatwg.org/) and must be absolute. If the pattern is empty, all requests are matched (including p2p connections).
	Latency            float64        `json:"latency"`                     // Minimum latency from request sent to response headers received (ms).
	DownloadThroughput float64        `json:"downloadThroughput"`          // Maximal aggregated download throughput (bytes/sec). -1 disables download throttling.
	UploadThroughput   float64        `json:"uploadThroughput"`            // Maximal aggregated upload throughput (bytes/sec). -1 disables upload throttling.
	ConnectionType     ConnectionType `json:"connectionType,omitempty"`    // Connection type if known.
	PacketLoss         *float64       `json:"packetLoss,omitempty"`        // WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets.
	PacketQueueLength  *int           `json:"packetQueueLength,omitempty"` // WebRTC packet queue length (packet). 0 removes any queue length limitations.
	PacketReordering   *bool          `json:"packetReordering,omitempty"`  // WebRTC packetReordering feature.
}

// BlockPattern
//
// Note: This type is experimental.
type BlockPattern struct {
	URLPattern string `json:"urlPattern"` // URL pattern to match. Patterns use the URLPattern constructor string syntax (https://urlpattern.spec.whatwg.org/) and must be absolute. Example: `*://*:*/*.css`.
	Block      bool   `json:"block"`      // Whether or not to block the pattern. If false, a matching request will not be blocked even if it matches a later `BlockPattern`.
}

// DirectSocketDNSQueryType
//
// Note: This type is experimental.
type DirectSocketDNSQueryType string

// DirectSocketDNSQueryType as enums.
const (
	DirectSocketDNSQueryTypeNotSet DirectSocketDNSQueryType = ""
	DirectSocketDNSQueryTypeIpv4   DirectSocketDNSQueryType = "ipv4"
	DirectSocketDNSQueryTypeIpv6   DirectSocketDNSQueryType = "ipv6"
)

func (e DirectSocketDNSQueryType) Valid() bool {
	switch e {
	case "ipv4", "ipv6":
		return true
	default:
		return false
	}
}

func (e DirectSocketDNSQueryType) String() string {
	return string(e)
}

// DirectTCPSocketOptions
//
// Note: This type is experimental.
type DirectTCPSocketOptions struct {
	NoDelay           bool                     `json:"noDelay"`                     // TCP_NODELAY option
	KeepAliveDelay    *float64                 `json:"keepAliveDelay,omitempty"`    // Expected to be unsigned integer.
	SendBufferSize    *float64                 `json:"sendBufferSize,omitempty"`    // Expected to be unsigned integer.
	ReceiveBufferSize *float64                 `json:"receiveBufferSize,omitempty"` // Expected to be unsigned integer.
	DNSQueryType      DirectSocketDNSQueryType `json:"dnsQueryType,omitempty"`      // No description.
}

// DirectUDPSocketOptions
//
// Note: This type is experimental.
type DirectUDPSocketOptions struct {
	RemoteAddr                   *string                  `json:"remoteAddr,omitempty"`                   // No description.
	RemotePort                   *int                     `json:"remotePort,omitempty"`                   // Unsigned int 16.
	LocalAddr                    *string                  `json:"localAddr,omitempty"`                    // No description.
	LocalPort                    *int                     `json:"localPort,omitempty"`                    // Unsigned int 16.
	DNSQueryType                 DirectSocketDNSQueryType `json:"dnsQueryType,omitempty"`                 // No description.
	SendBufferSize               *float64                 `json:"sendBufferSize,omitempty"`               // Expected to be unsigned integer.
	ReceiveBufferSize            *float64                 `json:"receiveBufferSize,omitempty"`            // Expected to be unsigned integer.
	MulticastLoopback            *bool                    `json:"multicastLoopback,omitempty"`            // No description.
	MulticastTimeToLive          *int                     `json:"multicastTimeToLive,omitempty"`          // Unsigned int 8.
	MulticastAllowAddressSharing *bool                    `json:"multicastAllowAddressSharing,omitempty"` // No description.
}

// DirectUDPMessage
//
// Note: This type is experimental.
type DirectUDPMessage struct {
	Data       string  `json:"data"`                 // No description.
	RemoteAddr *string `json:"remoteAddr,omitempty"` // Null for connected mode.
	RemotePort *int    `json:"remotePort,omitempty"` // Null for connected mode. Expected to be unsigned integer.
}

// PrivateNetworkRequestPolicy
//
// Note: This type is experimental.
type PrivateNetworkRequestPolicy string

// PrivateNetworkRequestPolicy as enums.
const (
	PrivateNetworkRequestPolicyNotSet                         PrivateNetworkRequestPolicy = ""
	PrivateNetworkRequestPolicyAllow                          PrivateNetworkRequestPolicy = "Allow"
	PrivateNetworkRequestPolicyBlockFromInsecureToMorePrivate PrivateNetworkRequestPolicy = "BlockFromInsecureToMorePrivate"
	PrivateNetworkRequestPolicyWarnFromInsecureToMorePrivate  PrivateNetworkRequestPolicy = "WarnFromInsecureToMorePrivate"
	PrivateNetworkRequestPolicyPermissionBlock                PrivateNetworkRequestPolicy = "PermissionBlock"
	PrivateNetworkRequestPolicyPermissionWarn                 PrivateNetworkRequestPolicy = "PermissionWarn"
)

func (e PrivateNetworkRequestPolicy) Valid() bool {
	switch e {
	case "Allow", "BlockFromInsecureToMorePrivate", "WarnFromInsecureToMorePrivate", "PermissionBlock", "PermissionWarn":
		return true
	default:
		return false
	}
}

func (e PrivateNetworkRequestPolicy) String() string {
	return string(e)
}

// IPAddressSpace
//
// Note: This type is experimental.
type IPAddressSpace string

// IPAddressSpace as enums.
const (
	IPAddressSpaceNotSet   IPAddressSpace = ""
	IPAddressSpaceLoopback IPAddressSpace = "Loopback"
	IPAddressSpaceLocal    IPAddressSpace = "Local"
	IPAddressSpacePublic   IPAddressSpace = "Public"
	IPAddressSpaceUnknown  IPAddressSpace = "Unknown"
)

func (e IPAddressSpace) Valid() bool {
	switch e {
	case "Loopback", "Local", "Public", "Unknown":
		return true
	default:
		return false
	}
}

func (e IPAddressSpace) String() string {
	return string(e)
}

// ConnectTiming
//
// Note: This type is experimental.
type ConnectTiming struct {
	RequestTime float64 `json:"requestTime"` // Timing's requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime. Matches ResourceTiming's requestTime for the same request (but not for redirected requests).
}

// ClientSecurityState
//
// Note: This type is experimental.
type ClientSecurityState struct {
	InitiatorIsSecureContext    bool                        `json:"initiatorIsSecureContext"`    // No description.
	InitiatorIPAddressSpace     IPAddressSpace              `json:"initiatorIPAddressSpace"`     // No description.
	PrivateNetworkRequestPolicy PrivateNetworkRequestPolicy `json:"privateNetworkRequestPolicy"` // No description.
}

// CrossOriginOpenerPolicyValue
//
// Note: This type is experimental.
type CrossOriginOpenerPolicyValue string

// CrossOriginOpenerPolicyValue as enums.
const (
	CrossOriginOpenerPolicyValueNotSet                     CrossOriginOpenerPolicyValue = ""
	CrossOriginOpenerPolicyValueSameOrigin                 CrossOriginOpenerPolicyValue = "SameOrigin"
	CrossOriginOpenerPolicyValueSameOriginAllowPopups      CrossOriginOpenerPolicyValue = "SameOriginAllowPopups"
	CrossOriginOpenerPolicyValueRestrictProperties         CrossOriginOpenerPolicyValue = "RestrictProperties"
	CrossOriginOpenerPolicyValueUnsafeNone                 CrossOriginOpenerPolicyValue = "UnsafeNone"
	CrossOriginOpenerPolicyValueSameOriginPlusCOEP         CrossOriginOpenerPolicyValue = "SameOriginPlusCoep"
	CrossOriginOpenerPolicyValueRestrictPropertiesPlusCOEP CrossOriginOpenerPolicyValue = "RestrictPropertiesPlusCoep"
	CrossOriginOpenerPolicyValueNoopenerAllowPopups        CrossOriginOpenerPolicyValue = "NoopenerAllowPopups"
)

func (e CrossOriginOpenerPolicyValue) Valid() bool {
	switch e {
	case "SameOrigin", "SameOriginAllowPopups", "RestrictProperties", "UnsafeNone", "SameOriginPlusCoep", "RestrictPropertiesPlusCoep", "NoopenerAllowPopups":
		return true
	default:
		return false
	}
}

func (e CrossOriginOpenerPolicyValue) String() string {
	return string(e)
}

// CrossOriginOpenerPolicyStatus
//
// Note: This type is experimental.
type CrossOriginOpenerPolicyStatus struct {
	Value                       CrossOriginOpenerPolicyValue `json:"value"`                                 // No description.
	ReportOnlyValue             CrossOriginOpenerPolicyValue `json:"reportOnlyValue"`                       // No description.
	ReportingEndpoint           *string                      `json:"reportingEndpoint,omitempty"`           // No description.
	ReportOnlyReportingEndpoint *string                      `json:"reportOnlyReportingEndpoint,omitempty"` // No description.
}

// CrossOriginEmbedderPolicyValue
//
// Note: This type is experimental.
type CrossOriginEmbedderPolicyValue string

// CrossOriginEmbedderPolicyValue as enums.
const (
	CrossOriginEmbedderPolicyValueNotSet         CrossOriginEmbedderPolicyValue = ""
	CrossOriginEmbedderPolicyValueNone           CrossOriginEmbedderPolicyValue = "None"
	CrossOriginEmbedderPolicyValueCredentialless CrossOriginEmbedderPolicyValue = "Credentialless"
	CrossOriginEmbedderPolicyValueRequireCORP    CrossOriginEmbedderPolicyValue = "RequireCorp"
)

func (e CrossOriginEmbedderPolicyValue) Valid() bool {
	switch e {
	case "None", "Credentialless", "RequireCorp":
		return true
	default:
		return false
	}
}

func (e CrossOriginEmbedderPolicyValue) String() string {
	return string(e)
}

// CrossOriginEmbedderPolicyStatus
//
// Note: This type is experimental.
type CrossOriginEmbedderPolicyStatus struct {
	Value                       CrossOriginEmbedderPolicyValue `json:"value"`                                 // No description.
	ReportOnlyValue             CrossOriginEmbedderPolicyValue `json:"reportOnlyValue"`                       // No description.
	ReportingEndpoint           *string                        `json:"reportingEndpoint,omitempty"`           // No description.
	ReportOnlyReportingEndpoint *string                        `json:"reportOnlyReportingEndpoint,omitempty"` // No description.
}

// ContentSecurityPolicySource
//
// Note: This type is experimental.
type ContentSecurityPolicySource string

// ContentSecurityPolicySource as enums.
const (
	ContentSecurityPolicySourceNotSet ContentSecurityPolicySource = ""
	ContentSecurityPolicySourceHTTP   ContentSecurityPolicySource = "HTTP"
	ContentSecurityPolicySourceMeta   ContentSecurityPolicySource = "Meta"
)

func (e ContentSecurityPolicySource) Valid() bool {
	switch e {
	case "HTTP", "Meta":
		return true
	default:
		return false
	}
}

func (e ContentSecurityPolicySource) String() string {
	return string(e)
}

// ContentSecurityPolicyStatus
//
// Note: This type is experimental.
type ContentSecurityPolicyStatus struct {
	EffectiveDirectives string                      `json:"effectiveDirectives"` // No description.
	IsEnforced          bool                        `json:"isEnforced"`          // No description.
	Source              ContentSecurityPolicySource `json:"source"`              // No description.
}

// SecurityIsolationStatus
//
// Note: This type is experimental.
type SecurityIsolationStatus struct {
	COOP *CrossOriginOpenerPolicyStatus   `json:"coop,omitempty"` // No description.
	COEP *CrossOriginEmbedderPolicyStatus `json:"coep,omitempty"` // No description.
	CSP  []ContentSecurityPolicyStatus    `json:"csp,omitempty"`  // No description.
}

// ReportStatus The status of a Reporting API report.
//
// Note: This type is experimental.
type ReportStatus string

// ReportStatus as enums.
const (
	ReportStatusNotSet           ReportStatus = ""
	ReportStatusQueued           ReportStatus = "Queued"
	ReportStatusPending          ReportStatus = "Pending"
	ReportStatusMarkedForRemoval ReportStatus = "MarkedForRemoval"
	ReportStatusSuccess          ReportStatus = "Success"
)

func (e ReportStatus) Valid() bool {
	switch e {
	case "Queued", "Pending", "MarkedForRemoval", "Success":
		return true
	default:
		return false
	}
}

func (e ReportStatus) String() string {
	return string(e)
}

// ReportID
//
// Note: This type is experimental.
type ReportID string

// ReportingAPIReport An object representing a report generated by the
// Reporting API.
//
// Note: This type is experimental.
type ReportingAPIReport struct {
	ID                ReportID        `json:"id"`                // No description.
	InitiatorURL      string          `json:"initiatorUrl"`      // The URL of the document that triggered the report.
	Destination       string          `json:"destination"`       // The name of the endpoint group that should be used to deliver the report.
	Type              string          `json:"type"`              // The type of the report (specifies the set of data that is contained in the report body).
	Timestamp         TimeSinceEpoch  `json:"timestamp"`         // When the report was generated.
	Depth             int             `json:"depth"`             // How many uploads deep the related request was.
	CompletedAttempts int             `json:"completedAttempts"` // The number of delivery attempts made so far, not including an active attempt.
	Body              json.RawMessage `json:"body"`              // No description.
	Status            ReportStatus    `json:"status"`            // No description.
}

// ReportingAPIEndpoint
//
// Note: This type is experimental.
type ReportingAPIEndpoint struct {
	URL       string `json:"url"`       // The URL of the endpoint to which reports may be delivered.
	GroupName string `json:"groupName"` // Name of the endpoint group.
}

// LoadNetworkResourcePageResult An object providing the result of a network
// resource load.
//
// Note: This type is experimental.
type LoadNetworkResourcePageResult struct {
	Success        bool             `json:"success"`                  // No description.
	NetError       *float64         `json:"netError,omitempty"`       // Optional values used for error reporting.
	NetErrorName   *string          `json:"netErrorName,omitempty"`   // No description.
	HTTPStatusCode *float64         `json:"httpStatusCode,omitempty"` // No description.
	Stream         *io.StreamHandle `json:"stream,omitempty"`         // If successful, one of the following two fields holds the result.
	Headers        Headers          `json:"headers,omitempty"`        // Response headers.
}

// LoadNetworkResourceOptions An options object that may be extended later to
// better support CORS, CORB and streaming.
//
// Note: This type is experimental.
type LoadNetworkResourceOptions struct {
	DisableCache       bool `json:"disableCache"`       // No description.
	IncludeCredentials bool `json:"includeCredentials"` // No description.
}
