// Code generated by cdpgen. DO NOT EDIT.

// Package emulation implements the Emulation domain. This domain emulates
// different environments for the page.
package emulation

import (
	"context"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/rpcc"
)

// domainClient is a client for the Emulation domain. This domain emulates
// different environments for the page.
type domainClient struct{ conn *rpcc.Conn }

// NewClient returns a client for the Emulation domain with the connection set to conn.
func NewClient(conn *rpcc.Conn) *domainClient {
	return &domainClient{conn: conn}
}

// CanEmulate invokes the Emulation method. Tells whether emulation is
// supported.
func (d *domainClient) CanEmulate(ctx context.Context) (reply *CanEmulateReply, err error) {
	reply = new(CanEmulateReply)
	err = rpcc.Invoke(ctx, "Emulation.canEmulate", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "CanEmulate", Err: err}
	}
	return
}

// ClearDeviceMetricsOverride invokes the Emulation method. Clears the
// overridden device metrics.
func (d *domainClient) ClearDeviceMetricsOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Emulation.clearDeviceMetricsOverride", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "ClearDeviceMetricsOverride", Err: err}
	}
	return
}

// ClearGeolocationOverride invokes the Emulation method. Clears the
// overridden Geolocation Position and Error.
func (d *domainClient) ClearGeolocationOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Emulation.clearGeolocationOverride", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "ClearGeolocationOverride", Err: err}
	}
	return
}

// ResetPageScaleFactor invokes the Emulation method. Requests that page scale
// factor is reset to initial values.
func (d *domainClient) ResetPageScaleFactor(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Emulation.resetPageScaleFactor", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "ResetPageScaleFactor", Err: err}
	}
	return
}

// SetFocusEmulationEnabled invokes the Emulation method. Enables or disables
// simulating a focused and active page.
func (d *domainClient) SetFocusEmulationEnabled(ctx context.Context, args *SetFocusEmulationEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setFocusEmulationEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setFocusEmulationEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetFocusEmulationEnabled", Err: err}
	}
	return
}

// SetAutoDarkModeOverride invokes the Emulation method. Automatically render
// all web contents using a dark theme.
func (d *domainClient) SetAutoDarkModeOverride(ctx context.Context, args *SetAutoDarkModeOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setAutoDarkModeOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setAutoDarkModeOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetAutoDarkModeOverride", Err: err}
	}
	return
}

// SetCPUThrottlingRate invokes the Emulation method. Enables CPU throttling
// to emulate slow CPUs.
func (d *domainClient) SetCPUThrottlingRate(ctx context.Context, args *SetCPUThrottlingRateArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setCPUThrottlingRate", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setCPUThrottlingRate", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetCPUThrottlingRate", Err: err}
	}
	return
}

// SetDefaultBackgroundColorOverride invokes the Emulation method. Sets or
// clears an override of the default background color of the frame. This
// override is used if the content does not specify one.
func (d *domainClient) SetDefaultBackgroundColorOverride(ctx context.Context, args *SetDefaultBackgroundColorOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setDefaultBackgroundColorOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setDefaultBackgroundColorOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetDefaultBackgroundColorOverride", Err: err}
	}
	return
}

// SetDeviceMetricsOverride invokes the Emulation method. Overrides the values
// of device screen dimensions (window.screen.width, window.screen.height,
// window.innerWidth, window.innerHeight, and
// "device-width"/"device-height"-related CSS media query results).
func (d *domainClient) SetDeviceMetricsOverride(ctx context.Context, args *SetDeviceMetricsOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setDeviceMetricsOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setDeviceMetricsOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetDeviceMetricsOverride", Err: err}
	}
	return
}

// SetDevicePostureOverride invokes the Emulation method. Start reporting the
// given posture value to the Device Posture API. This override can also be set
// in setDeviceMetricsOverride().
func (d *domainClient) SetDevicePostureOverride(ctx context.Context, args *SetDevicePostureOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setDevicePostureOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setDevicePostureOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetDevicePostureOverride", Err: err}
	}
	return
}

// ClearDevicePostureOverride invokes the Emulation method. Clears a device
// posture override set with either setDeviceMetricsOverride() or
// setDevicePostureOverride() and starts using posture information from the
// platform again. Does nothing if no override is set.
func (d *domainClient) ClearDevicePostureOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Emulation.clearDevicePostureOverride", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "ClearDevicePostureOverride", Err: err}
	}
	return
}

// SetScrollbarsHidden invokes the Emulation method.
func (d *domainClient) SetScrollbarsHidden(ctx context.Context, args *SetScrollbarsHiddenArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setScrollbarsHidden", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setScrollbarsHidden", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetScrollbarsHidden", Err: err}
	}
	return
}

// SetDocumentCookieDisabled invokes the Emulation method.
func (d *domainClient) SetDocumentCookieDisabled(ctx context.Context, args *SetDocumentCookieDisabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setDocumentCookieDisabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setDocumentCookieDisabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetDocumentCookieDisabled", Err: err}
	}
	return
}

// SetEmitTouchEventsForMouse invokes the Emulation method.
func (d *domainClient) SetEmitTouchEventsForMouse(ctx context.Context, args *SetEmitTouchEventsForMouseArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setEmitTouchEventsForMouse", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setEmitTouchEventsForMouse", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetEmitTouchEventsForMouse", Err: err}
	}
	return
}

// SetEmulatedMedia invokes the Emulation method. Emulates the given media
// type or media feature for CSS media queries.
func (d *domainClient) SetEmulatedMedia(ctx context.Context, args *SetEmulatedMediaArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setEmulatedMedia", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setEmulatedMedia", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetEmulatedMedia", Err: err}
	}
	return
}

// SetEmulatedVisionDeficiency invokes the Emulation method. Emulates the
// given vision deficiency.
func (d *domainClient) SetEmulatedVisionDeficiency(ctx context.Context, args *SetEmulatedVisionDeficiencyArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setEmulatedVisionDeficiency", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setEmulatedVisionDeficiency", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetEmulatedVisionDeficiency", Err: err}
	}
	return
}

// SetGeolocationOverride invokes the Emulation method. Overrides the
// Geolocation Position or Error. Omitting any of the parameters emulates
// position unavailable.
func (d *domainClient) SetGeolocationOverride(ctx context.Context, args *SetGeolocationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setGeolocationOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setGeolocationOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetGeolocationOverride", Err: err}
	}
	return
}

// GetOverriddenSensorInformation invokes the Emulation method.
func (d *domainClient) GetOverriddenSensorInformation(ctx context.Context, args *GetOverriddenSensorInformationArgs) (reply *GetOverriddenSensorInformationReply, err error) {
	reply = new(GetOverriddenSensorInformationReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.getOverriddenSensorInformation", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.getOverriddenSensorInformation", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "GetOverriddenSensorInformation", Err: err}
	}
	return
}

// SetSensorOverrideEnabled invokes the Emulation method. Overrides a platform
// sensor of a given type. If |enabled| is true, calls to Sensor.start() will
// use a virtual sensor as backend rather than fetching data from a real
// hardware sensor. Otherwise, existing virtual sensor-backend Sensor objects
// will fire an error event and new calls to Sensor.start() will attempt to use
// a real sensor instead.
func (d *domainClient) SetSensorOverrideEnabled(ctx context.Context, args *SetSensorOverrideEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setSensorOverrideEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setSensorOverrideEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetSensorOverrideEnabled", Err: err}
	}
	return
}

// SetSensorOverrideReadings invokes the Emulation method. Updates the sensor
// readings reported by a sensor type previously overridden by
// setSensorOverrideEnabled.
func (d *domainClient) SetSensorOverrideReadings(ctx context.Context, args *SetSensorOverrideReadingsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setSensorOverrideReadings", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setSensorOverrideReadings", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetSensorOverrideReadings", Err: err}
	}
	return
}

// SetPressureSourceOverrideEnabled invokes the Emulation method. Overrides a
// pressure source of a given type, as used by the Compute Pressure API, so
// that updates to PressureObserver.observe() are provided via
// setPressureStateOverride instead of being retrieved from platform-provided
// telemetry data.
func (d *domainClient) SetPressureSourceOverrideEnabled(ctx context.Context, args *SetPressureSourceOverrideEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setPressureSourceOverrideEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setPressureSourceOverrideEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetPressureSourceOverrideEnabled", Err: err}
	}
	return
}

// SetPressureStateOverride invokes the Emulation method. Provides a given
// pressure state that will be processed and eventually be delivered to
// PressureObserver users. |source| must have been previously overridden by
// setPressureSourceOverrideEnabled.
func (d *domainClient) SetPressureStateOverride(ctx context.Context, args *SetPressureStateOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setPressureStateOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setPressureStateOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetPressureStateOverride", Err: err}
	}
	return
}

// SetIdleOverride invokes the Emulation method. Overrides the Idle state.
func (d *domainClient) SetIdleOverride(ctx context.Context, args *SetIdleOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setIdleOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setIdleOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetIdleOverride", Err: err}
	}
	return
}

// ClearIdleOverride invokes the Emulation method. Clears Idle state
// overrides.
func (d *domainClient) ClearIdleOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Emulation.clearIdleOverride", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "ClearIdleOverride", Err: err}
	}
	return
}

// SetNavigatorOverrides invokes the Emulation method. Overrides value
// returned by the javascript navigator object.
func (d *domainClient) SetNavigatorOverrides(ctx context.Context, args *SetNavigatorOverridesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setNavigatorOverrides", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setNavigatorOverrides", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetNavigatorOverrides", Err: err}
	}
	return
}

// SetPageScaleFactor invokes the Emulation method. Sets a specified page
// scale factor.
func (d *domainClient) SetPageScaleFactor(ctx context.Context, args *SetPageScaleFactorArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setPageScaleFactor", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setPageScaleFactor", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetPageScaleFactor", Err: err}
	}
	return
}

// SetScriptExecutionDisabled invokes the Emulation method. Switches script
// execution in the page.
func (d *domainClient) SetScriptExecutionDisabled(ctx context.Context, args *SetScriptExecutionDisabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setScriptExecutionDisabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setScriptExecutionDisabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetScriptExecutionDisabled", Err: err}
	}
	return
}

// SetTouchEmulationEnabled invokes the Emulation method. Enables touch on
// platforms which do not support them.
func (d *domainClient) SetTouchEmulationEnabled(ctx context.Context, args *SetTouchEmulationEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setTouchEmulationEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setTouchEmulationEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetTouchEmulationEnabled", Err: err}
	}
	return
}

// SetVirtualTimePolicy invokes the Emulation method. Turns on virtual time
// for all frames (replacing real-time with a synthetic time source) and sets
// the current virtual time policy. Note this supersedes any previous time
// budget.
func (d *domainClient) SetVirtualTimePolicy(ctx context.Context, args *SetVirtualTimePolicyArgs) (reply *SetVirtualTimePolicyReply, err error) {
	reply = new(SetVirtualTimePolicyReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setVirtualTimePolicy", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setVirtualTimePolicy", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetVirtualTimePolicy", Err: err}
	}
	return
}

// SetLocaleOverride invokes the Emulation method. Overrides default host
// system locale with the specified one.
func (d *domainClient) SetLocaleOverride(ctx context.Context, args *SetLocaleOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setLocaleOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setLocaleOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetLocaleOverride", Err: err}
	}
	return
}

// SetTimezoneOverride invokes the Emulation method. Overrides default host
// system timezone with the specified one.
func (d *domainClient) SetTimezoneOverride(ctx context.Context, args *SetTimezoneOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setTimezoneOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setTimezoneOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetTimezoneOverride", Err: err}
	}
	return
}

// SetVisibleSize invokes the Emulation method. Resizes the frame/viewport of
// the page. Note that this does not affect the frame's container (e.g. browser
// window). Can be used to produce screenshots of the specified size. Not
// supported on Android.
func (d *domainClient) SetVisibleSize(ctx context.Context, args *SetVisibleSizeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setVisibleSize", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setVisibleSize", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetVisibleSize", Err: err}
	}
	return
}

// SetDisabledImageTypes invokes the Emulation method.
func (d *domainClient) SetDisabledImageTypes(ctx context.Context, args *SetDisabledImageTypesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setDisabledImageTypes", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setDisabledImageTypes", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetDisabledImageTypes", Err: err}
	}
	return
}

// SetHardwareConcurrencyOverride invokes the Emulation method.
func (d *domainClient) SetHardwareConcurrencyOverride(ctx context.Context, args *SetHardwareConcurrencyOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setHardwareConcurrencyOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setHardwareConcurrencyOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetHardwareConcurrencyOverride", Err: err}
	}
	return
}

// SetUserAgentOverride invokes the Emulation method. Allows overriding user
// agent with the given string. `userAgentMetadata` must be set for Client Hint
// headers to be sent.
func (d *domainClient) SetUserAgentOverride(ctx context.Context, args *SetUserAgentOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setUserAgentOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setUserAgentOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetUserAgentOverride", Err: err}
	}
	return
}

// SetAutomationOverride invokes the Emulation method. Allows overriding the
// automation flag.
func (d *domainClient) SetAutomationOverride(ctx context.Context, args *SetAutomationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Emulation.setAutomationOverride", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Emulation.setAutomationOverride", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Emulation", Op: "SetAutomationOverride", Err: err}
	}
	return
}

func (d *domainClient) VirtualTimeBudgetExpired(ctx context.Context) (VirtualTimeBudgetExpiredClient, error) {
	s, err := rpcc.NewStream(ctx, "Emulation.virtualTimeBudgetExpired", d.conn)
	if err != nil {
		return nil, err
	}
	return &virtualTimeBudgetExpiredClient{Stream: s}, nil
}

type virtualTimeBudgetExpiredClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *virtualTimeBudgetExpiredClient) GetStream() rpcc.Stream { return c.Stream }

func (c *virtualTimeBudgetExpiredClient) Recv() (*VirtualTimeBudgetExpiredReply, error) {
	event := new(VirtualTimeBudgetExpiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Emulation", Op: "VirtualTimeBudgetExpired Recv", Err: err}
	}
	return event, nil
}
