// Code generated by cdpgen. DO NOT EDIT.

// Package page implements the Page domain. Actions and events related to the
// inspected page belong to the page domain.
package page

import (
	"context"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/rpcc"
)

// domainClient is a client for the Page domain. Actions and events related to
// the inspected page belong to the page domain.
type domainClient struct{ conn *rpcc.Conn }

// NewClient returns a client for the Page domain with the connection set to conn.
func NewClient(conn *rpcc.Conn) *domainClient {
	return &domainClient{conn: conn}
}

// AddScriptToEvaluateOnLoad invokes the Page method. Deprecated, please use
// addScriptToEvaluateOnNewDocument instead.
func (d *domainClient) AddScriptToEvaluateOnLoad(ctx context.Context, args *AddScriptToEvaluateOnLoadArgs) (reply *AddScriptToEvaluateOnLoadReply, err error) {
	reply = new(AddScriptToEvaluateOnLoadReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.addScriptToEvaluateOnLoad", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.addScriptToEvaluateOnLoad", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "AddScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// AddScriptToEvaluateOnNewDocument invokes the Page method. Evaluates given
// script in every frame upon creation (before loading frame's scripts).
func (d *domainClient) AddScriptToEvaluateOnNewDocument(ctx context.Context, args *AddScriptToEvaluateOnNewDocumentArgs) (reply *AddScriptToEvaluateOnNewDocumentReply, err error) {
	reply = new(AddScriptToEvaluateOnNewDocumentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.addScriptToEvaluateOnNewDocument", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.addScriptToEvaluateOnNewDocument", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "AddScriptToEvaluateOnNewDocument", Err: err}
	}
	return
}

// BringToFront invokes the Page method. Brings page to front (activates tab).
func (d *domainClient) BringToFront(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.bringToFront", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "BringToFront", Err: err}
	}
	return
}

// CaptureScreenshot invokes the Page method. Capture page screenshot.
func (d *domainClient) CaptureScreenshot(ctx context.Context, args *CaptureScreenshotArgs) (reply *CaptureScreenshotReply, err error) {
	reply = new(CaptureScreenshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.captureScreenshot", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.captureScreenshot", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "CaptureScreenshot", Err: err}
	}
	return
}

// CaptureSnapshot invokes the Page method. Returns a snapshot of the page as
// a string. For MHTML format, the serialization includes iframes, shadow DOM,
// external resources, and element-inline styles.
func (d *domainClient) CaptureSnapshot(ctx context.Context, args *CaptureSnapshotArgs) (reply *CaptureSnapshotReply, err error) {
	reply = new(CaptureSnapshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.captureSnapshot", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.captureSnapshot", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "CaptureSnapshot", Err: err}
	}
	return
}

// CreateIsolatedWorld invokes the Page method. Creates an isolated world for
// the given frame.
func (d *domainClient) CreateIsolatedWorld(ctx context.Context, args *CreateIsolatedWorldArgs) (reply *CreateIsolatedWorldReply, err error) {
	reply = new(CreateIsolatedWorldReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.createIsolatedWorld", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.createIsolatedWorld", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "CreateIsolatedWorld", Err: err}
	}
	return
}

// Disable invokes the Page method. Disables page domain notifications.
func (d *domainClient) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.disable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Disable", Err: err}
	}
	return
}

// Enable invokes the Page method. Enables page domain notifications.
func (d *domainClient) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.enable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Enable", Err: err}
	}
	return
}

// GetAppManifest invokes the Page method. Gets the processed manifest for
// this current document. This API always waits for the manifest to be loaded.
// If manifestId is provided, and it does not match the manifest of the current
// document, this API errors out. If there is not a loaded page, this API
// errors out immediately.
func (d *domainClient) GetAppManifest(ctx context.Context, args *GetAppManifestArgs) (reply *GetAppManifestReply, err error) {
	reply = new(GetAppManifestReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.getAppManifest", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.getAppManifest", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetAppManifest", Err: err}
	}
	return
}

// GetInstallabilityErrors invokes the Page method.
func (d *domainClient) GetInstallabilityErrors(ctx context.Context) (reply *GetInstallabilityErrorsReply, err error) {
	reply = new(GetInstallabilityErrorsReply)
	err = rpcc.Invoke(ctx, "Page.getInstallabilityErrors", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetInstallabilityErrors", Err: err}
	}
	return
}

// GetManifestIcons invokes the Page method. Deprecated because it's not
// guaranteed that the returned icon is in fact the one used for PWA
// installation.
func (d *domainClient) GetManifestIcons(ctx context.Context) (reply *GetManifestIconsReply, err error) {
	reply = new(GetManifestIconsReply)
	err = rpcc.Invoke(ctx, "Page.getManifestIcons", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetManifestIcons", Err: err}
	}
	return
}

// GetAppID invokes the Page method. Returns the unique (PWA) app id. Only
// returns values if the feature flag 'WebAppEnableManifestId' is enabled
func (d *domainClient) GetAppID(ctx context.Context) (reply *GetAppIDReply, err error) {
	reply = new(GetAppIDReply)
	err = rpcc.Invoke(ctx, "Page.getAppId", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetAppID", Err: err}
	}
	return
}

// GetAdScriptID invokes the Page method.
func (d *domainClient) GetAdScriptID(ctx context.Context, args *GetAdScriptIDArgs) (reply *GetAdScriptIDReply, err error) {
	reply = new(GetAdScriptIDReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.getAdScriptId", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.getAdScriptId", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetAdScriptID", Err: err}
	}
	return
}

// GetFrameTree invokes the Page method. Returns present frame tree structure.
func (d *domainClient) GetFrameTree(ctx context.Context) (reply *GetFrameTreeReply, err error) {
	reply = new(GetFrameTreeReply)
	err = rpcc.Invoke(ctx, "Page.getFrameTree", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetFrameTree", Err: err}
	}
	return
}

// GetLayoutMetrics invokes the Page method. Returns metrics relating to the
// layouting of the page, such as viewport bounds/scale.
func (d *domainClient) GetLayoutMetrics(ctx context.Context) (reply *GetLayoutMetricsReply, err error) {
	reply = new(GetLayoutMetricsReply)
	err = rpcc.Invoke(ctx, "Page.getLayoutMetrics", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetLayoutMetrics", Err: err}
	}
	return
}

// GetNavigationHistory invokes the Page method. Returns navigation history
// for the current page.
func (d *domainClient) GetNavigationHistory(ctx context.Context) (reply *GetNavigationHistoryReply, err error) {
	reply = new(GetNavigationHistoryReply)
	err = rpcc.Invoke(ctx, "Page.getNavigationHistory", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetNavigationHistory", Err: err}
	}
	return
}

// ResetNavigationHistory invokes the Page method. Resets navigation history
// for the current page.
func (d *domainClient) ResetNavigationHistory(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.resetNavigationHistory", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "ResetNavigationHistory", Err: err}
	}
	return
}

// GetResourceContent invokes the Page method. Returns content of the given
// resource.
func (d *domainClient) GetResourceContent(ctx context.Context, args *GetResourceContentArgs) (reply *GetResourceContentReply, err error) {
	reply = new(GetResourceContentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.getResourceContent", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.getResourceContent", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetResourceContent", Err: err}
	}
	return
}

// GetResourceTree invokes the Page method. Returns present frame / resource
// tree structure.
func (d *domainClient) GetResourceTree(ctx context.Context) (reply *GetResourceTreeReply, err error) {
	reply = new(GetResourceTreeReply)
	err = rpcc.Invoke(ctx, "Page.getResourceTree", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetResourceTree", Err: err}
	}
	return
}

// HandleJavaScriptDialog invokes the Page method. Accepts or dismisses a
// JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
func (d *domainClient) HandleJavaScriptDialog(ctx context.Context, args *HandleJavaScriptDialogArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.handleJavaScriptDialog", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.handleJavaScriptDialog", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "HandleJavaScriptDialog", Err: err}
	}
	return
}

// Navigate invokes the Page method. Navigates current page to the given URL.
func (d *domainClient) Navigate(ctx context.Context, args *NavigateArgs) (reply *NavigateReply, err error) {
	reply = new(NavigateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.navigate", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.navigate", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Navigate", Err: err}
	}
	return
}

// NavigateToHistoryEntry invokes the Page method. Navigates current page to
// the given history entry.
func (d *domainClient) NavigateToHistoryEntry(ctx context.Context, args *NavigateToHistoryEntryArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.navigateToHistoryEntry", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.navigateToHistoryEntry", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "NavigateToHistoryEntry", Err: err}
	}
	return
}

// PrintToPDF invokes the Page method. Print page as PDF.
func (d *domainClient) PrintToPDF(ctx context.Context, args *PrintToPDFArgs) (reply *PrintToPDFReply, err error) {
	reply = new(PrintToPDFReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.printToPDF", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.printToPDF", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "PrintToPDF", Err: err}
	}
	return
}

// Reload invokes the Page method. Reloads given page optionally ignoring the
// cache.
func (d *domainClient) Reload(ctx context.Context, args *ReloadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.reload", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.reload", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Reload", Err: err}
	}
	return
}

// RemoveScriptToEvaluateOnLoad invokes the Page method. Deprecated, please
// use removeScriptToEvaluateOnNewDocument instead.
func (d *domainClient) RemoveScriptToEvaluateOnLoad(ctx context.Context, args *RemoveScriptToEvaluateOnLoadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.removeScriptToEvaluateOnLoad", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.removeScriptToEvaluateOnLoad", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "RemoveScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// RemoveScriptToEvaluateOnNewDocument invokes the Page method. Removes given
// script from the list.
func (d *domainClient) RemoveScriptToEvaluateOnNewDocument(ctx context.Context, args *RemoveScriptToEvaluateOnNewDocumentArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.removeScriptToEvaluateOnNewDocument", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.removeScriptToEvaluateOnNewDocument", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "RemoveScriptToEvaluateOnNewDocument", Err: err}
	}
	return
}

// ScreencastFrameAck invokes the Page method. Acknowledges that a screencast
// frame has been received by the frontend.
func (d *domainClient) ScreencastFrameAck(ctx context.Context, args *ScreencastFrameAckArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.screencastFrameAck", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.screencastFrameAck", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "ScreencastFrameAck", Err: err}
	}
	return
}

// SearchInResource invokes the Page method. Searches for given string in
// resource content.
func (d *domainClient) SearchInResource(ctx context.Context, args *SearchInResourceArgs) (reply *SearchInResourceReply, err error) {
	reply = new(SearchInResourceReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.searchInResource", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.searchInResource", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SearchInResource", Err: err}
	}
	return
}

// SetAdBlockingEnabled invokes the Page method. Enable Chrome's experimental
// ad filter on all sites.
func (d *domainClient) SetAdBlockingEnabled(ctx context.Context, args *SetAdBlockingEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setAdBlockingEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setAdBlockingEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetAdBlockingEnabled", Err: err}
	}
	return
}

// SetBypassCSP invokes the Page method. Enable page Content Security Policy
// by-passing.
func (d *domainClient) SetBypassCSP(ctx context.Context, args *SetBypassCSPArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setBypassCSP", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setBypassCSP", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetBypassCSP", Err: err}
	}
	return
}

// GetPermissionsPolicyState invokes the Page method. Get Permissions Policy
// state on given frame.
func (d *domainClient) GetPermissionsPolicyState(ctx context.Context, args *GetPermissionsPolicyStateArgs) (reply *GetPermissionsPolicyStateReply, err error) {
	reply = new(GetPermissionsPolicyStateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.getPermissionsPolicyState", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.getPermissionsPolicyState", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetPermissionsPolicyState", Err: err}
	}
	return
}

// GetOriginTrials invokes the Page method. Get Origin Trials on given frame.
func (d *domainClient) GetOriginTrials(ctx context.Context, args *GetOriginTrialsArgs) (reply *GetOriginTrialsReply, err error) {
	reply = new(GetOriginTrialsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.getOriginTrials", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.getOriginTrials", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GetOriginTrials", Err: err}
	}
	return
}

// SetFontFamilies invokes the Page method. Set generic font families.
func (d *domainClient) SetFontFamilies(ctx context.Context, args *SetFontFamiliesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setFontFamilies", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setFontFamilies", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetFontFamilies", Err: err}
	}
	return
}

// SetFontSizes invokes the Page method. Set default font sizes.
func (d *domainClient) SetFontSizes(ctx context.Context, args *SetFontSizesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setFontSizes", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setFontSizes", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetFontSizes", Err: err}
	}
	return
}

// SetDocumentContent invokes the Page method. Sets given markup as the
// document's HTML.
func (d *domainClient) SetDocumentContent(ctx context.Context, args *SetDocumentContentArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setDocumentContent", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setDocumentContent", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetDocumentContent", Err: err}
	}
	return
}

// SetDownloadBehavior invokes the Page method. Set the behavior when
// downloading a file.
func (d *domainClient) SetDownloadBehavior(ctx context.Context, args *SetDownloadBehaviorArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setDownloadBehavior", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setDownloadBehavior", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetDownloadBehavior", Err: err}
	}
	return
}

// SetLifecycleEventsEnabled invokes the Page method. Controls whether page
// will emit lifecycle events.
func (d *domainClient) SetLifecycleEventsEnabled(ctx context.Context, args *SetLifecycleEventsEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setLifecycleEventsEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setLifecycleEventsEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetLifecycleEventsEnabled", Err: err}
	}
	return
}

// StartScreencast invokes the Page method. Starts sending each frame using
// the `screencastFrame` event.
func (d *domainClient) StartScreencast(ctx context.Context, args *StartScreencastArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.startScreencast", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.startScreencast", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "StartScreencast", Err: err}
	}
	return
}

// StopLoading invokes the Page method. Force the page stop all navigations
// and pending resource fetches.
func (d *domainClient) StopLoading(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.stopLoading", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "StopLoading", Err: err}
	}
	return
}

// Crash invokes the Page method. Crashes renderer on the IO thread, generates
// minidumps.
func (d *domainClient) Crash(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.crash", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Crash", Err: err}
	}
	return
}

// Close invokes the Page method. Tries to close page, running its
// beforeunload hooks, if any.
func (d *domainClient) Close(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.close", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "Close", Err: err}
	}
	return
}

// SetWebLifecycleState invokes the Page method. Tries to update the web
// lifecycle state of the page. It will transition the page to the given state
// according to: https://github.com/WICG/web-lifecycle/
func (d *domainClient) SetWebLifecycleState(ctx context.Context, args *SetWebLifecycleStateArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setWebLifecycleState", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setWebLifecycleState", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetWebLifecycleState", Err: err}
	}
	return
}

// StopScreencast invokes the Page method. Stops sending each frame in the
// `screencastFrame`.
func (d *domainClient) StopScreencast(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.stopScreencast", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "StopScreencast", Err: err}
	}
	return
}

// ProduceCompilationCache invokes the Page method. Requests backend to
// produce compilation cache for the specified scripts. `scripts` are appended
// to the list of scripts for which the cache would be produced. The list may
// be reset during page navigation. When script with a matching URL is
// encountered, the cache is optionally produced upon backend discretion, based
// on internal heuristics. See also: `Page.compilationCacheProduced`.
func (d *domainClient) ProduceCompilationCache(ctx context.Context, args *ProduceCompilationCacheArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.produceCompilationCache", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.produceCompilationCache", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "ProduceCompilationCache", Err: err}
	}
	return
}

// AddCompilationCache invokes the Page method. Seeds compilation cache for
// given url. Compilation cache does not survive cross-process navigation.
func (d *domainClient) AddCompilationCache(ctx context.Context, args *AddCompilationCacheArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.addCompilationCache", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.addCompilationCache", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "AddCompilationCache", Err: err}
	}
	return
}

// ClearCompilationCache invokes the Page method. Clears seeded compilation
// cache.
func (d *domainClient) ClearCompilationCache(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.clearCompilationCache", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "ClearCompilationCache", Err: err}
	}
	return
}

// SetSPCTransactionMode invokes the Page method. Sets the Secure Payment
// Confirmation transaction mode.
// https://w3c.github.io/secure-payment-confirmation/#sctn-automation-set-spc-transaction-mode
func (d *domainClient) SetSPCTransactionMode(ctx context.Context, args *SetSPCTransactionModeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setSPCTransactionMode", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setSPCTransactionMode", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetSPCTransactionMode", Err: err}
	}
	return
}

// SetRPHRegistrationMode invokes the Page method. Extensions for Custom
// Handlers API:
// https://html.spec.whatwg.org/multipage/system-state.html#rph-automation
func (d *domainClient) SetRPHRegistrationMode(ctx context.Context, args *SetRPHRegistrationModeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setRPHRegistrationMode", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setRPHRegistrationMode", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetRPHRegistrationMode", Err: err}
	}
	return
}

// GenerateTestReport invokes the Page method. Generates a report for testing.
func (d *domainClient) GenerateTestReport(ctx context.Context, args *GenerateTestReportArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.generateTestReport", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.generateTestReport", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "GenerateTestReport", Err: err}
	}
	return
}

// WaitForDebugger invokes the Page method. Pauses page execution. Can be
// resumed using generic Runtime.runIfWaitingForDebugger.
func (d *domainClient) WaitForDebugger(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Page.waitForDebugger", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "WaitForDebugger", Err: err}
	}
	return
}

// SetInterceptFileChooserDialog invokes the Page method. Intercept file
// chooser requests and transfer control to protocol clients. When file chooser
// interception is enabled, native file chooser dialog is not shown. Instead, a
// protocol event `Page.fileChooserOpened` is emitted.
func (d *domainClient) SetInterceptFileChooserDialog(ctx context.Context, args *SetInterceptFileChooserDialogArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setInterceptFileChooserDialog", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setInterceptFileChooserDialog", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetInterceptFileChooserDialog", Err: err}
	}
	return
}

// SetPrerenderingAllowed invokes the Page method. Enable/disable prerendering
// manually.
//
// This command is a short-term solution for https://crbug.com/1440085. See
// https://docs.google.com/document/d/12HVmFxYj5Jc-eJr5OmWsa2bqTJsbgGLKI6ZIyx0_wpA
// for more details.
//
// TODO(https://crbug.com/1440085): Remove this once Puppeteer supports tab
// targets.
func (d *domainClient) SetPrerenderingAllowed(ctx context.Context, args *SetPrerenderingAllowedArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Page.setPrerenderingAllowed", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Page.setPrerenderingAllowed", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Page", Op: "SetPrerenderingAllowed", Err: err}
	}
	return
}

func (d *domainClient) DOMContentEventFired(ctx context.Context) (DOMContentEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.domContentEventFired", d.conn)
	if err != nil {
		return nil, err
	}
	return &dOMContentEventFiredClient{Stream: s}, nil
}

type dOMContentEventFiredClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *dOMContentEventFiredClient) GetStream() rpcc.Stream { return c.Stream }

func (c *dOMContentEventFiredClient) Recv() (*DOMContentEventFiredReply, error) {
	event := new(DOMContentEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "DOMContentEventFired Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FileChooserOpened(ctx context.Context) (FileChooserOpenedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.fileChooserOpened", d.conn)
	if err != nil {
		return nil, err
	}
	return &fileChooserOpenedClient{Stream: s}, nil
}

type fileChooserOpenedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *fileChooserOpenedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *fileChooserOpenedClient) Recv() (*FileChooserOpenedReply, error) {
	event := new(FileChooserOpenedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FileChooserOpened Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameAttached(ctx context.Context) (FrameAttachedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameAttached", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameAttachedClient{Stream: s}, nil
}

type frameAttachedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameAttachedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameAttachedClient) Recv() (*FrameAttachedReply, error) {
	event := new(FrameAttachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameAttached Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameClearedScheduledNavigation(ctx context.Context) (FrameClearedScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameClearedScheduledNavigation", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameClearedScheduledNavigationClient{Stream: s}, nil
}

type frameClearedScheduledNavigationClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameClearedScheduledNavigationClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameClearedScheduledNavigationClient) Recv() (*FrameClearedScheduledNavigationReply, error) {
	event := new(FrameClearedScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameClearedScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameDetached(ctx context.Context) (FrameDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameDetached", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameDetachedClient{Stream: s}, nil
}

type frameDetachedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameDetachedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameDetachedClient) Recv() (*FrameDetachedReply, error) {
	event := new(FrameDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameDetached Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameSubtreeWillBeDetached(ctx context.Context) (FrameSubtreeWillBeDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameSubtreeWillBeDetached", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameSubtreeWillBeDetachedClient{Stream: s}, nil
}

type frameSubtreeWillBeDetachedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameSubtreeWillBeDetachedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameSubtreeWillBeDetachedClient) Recv() (*FrameSubtreeWillBeDetachedReply, error) {
	event := new(FrameSubtreeWillBeDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameSubtreeWillBeDetached Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameNavigated(ctx context.Context) (FrameNavigatedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameNavigated", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameNavigatedClient{Stream: s}, nil
}

type frameNavigatedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameNavigatedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameNavigatedClient) Recv() (*FrameNavigatedReply, error) {
	event := new(FrameNavigatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameNavigated Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) DocumentOpened(ctx context.Context) (DocumentOpenedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.documentOpened", d.conn)
	if err != nil {
		return nil, err
	}
	return &documentOpenedClient{Stream: s}, nil
}

type documentOpenedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *documentOpenedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *documentOpenedClient) Recv() (*DocumentOpenedReply, error) {
	event := new(DocumentOpenedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "DocumentOpened Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameResized(ctx context.Context) (FrameResizedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameResized", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameResizedClient{Stream: s}, nil
}

type frameResizedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameResizedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameResizedClient) Recv() (*FrameResizedReply, error) {
	event := new(FrameResizedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameResized Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameRequestedNavigation(ctx context.Context) (FrameRequestedNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameRequestedNavigation", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameRequestedNavigationClient{Stream: s}, nil
}

type frameRequestedNavigationClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameRequestedNavigationClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameRequestedNavigationClient) Recv() (*FrameRequestedNavigationReply, error) {
	event := new(FrameRequestedNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameRequestedNavigation Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameScheduledNavigation(ctx context.Context) (FrameScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameScheduledNavigation", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameScheduledNavigationClient{Stream: s}, nil
}

type frameScheduledNavigationClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameScheduledNavigationClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameScheduledNavigationClient) Recv() (*FrameScheduledNavigationReply, error) {
	event := new(FrameScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameStartedLoading(ctx context.Context) (FrameStartedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameStartedLoading", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameStartedLoadingClient{Stream: s}, nil
}

type frameStartedLoadingClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameStartedLoadingClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameStartedLoadingClient) Recv() (*FrameStartedLoadingReply, error) {
	event := new(FrameStartedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameStartedLoading Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) FrameStoppedLoading(ctx context.Context) (FrameStoppedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.frameStoppedLoading", d.conn)
	if err != nil {
		return nil, err
	}
	return &frameStoppedLoadingClient{Stream: s}, nil
}

type frameStoppedLoadingClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *frameStoppedLoadingClient) GetStream() rpcc.Stream { return c.Stream }

func (c *frameStoppedLoadingClient) Recv() (*FrameStoppedLoadingReply, error) {
	event := new(FrameStoppedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "FrameStoppedLoading Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) DownloadWillBegin(ctx context.Context) (DownloadWillBeginClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.downloadWillBegin", d.conn)
	if err != nil {
		return nil, err
	}
	return &downloadWillBeginClient{Stream: s}, nil
}

type downloadWillBeginClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *downloadWillBeginClient) GetStream() rpcc.Stream { return c.Stream }

func (c *downloadWillBeginClient) Recv() (*DownloadWillBeginReply, error) {
	event := new(DownloadWillBeginReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "DownloadWillBegin Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) DownloadProgress(ctx context.Context) (DownloadProgressClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.downloadProgress", d.conn)
	if err != nil {
		return nil, err
	}
	return &downloadProgressClient{Stream: s}, nil
}

type downloadProgressClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *downloadProgressClient) GetStream() rpcc.Stream { return c.Stream }

func (c *downloadProgressClient) Recv() (*DownloadProgressReply, error) {
	event := new(DownloadProgressReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "DownloadProgress Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) InterstitialHidden(ctx context.Context) (InterstitialHiddenClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.interstitialHidden", d.conn)
	if err != nil {
		return nil, err
	}
	return &interstitialHiddenClient{Stream: s}, nil
}

type interstitialHiddenClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *interstitialHiddenClient) GetStream() rpcc.Stream { return c.Stream }

func (c *interstitialHiddenClient) Recv() (*InterstitialHiddenReply, error) {
	event := new(InterstitialHiddenReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "InterstitialHidden Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) InterstitialShown(ctx context.Context) (InterstitialShownClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.interstitialShown", d.conn)
	if err != nil {
		return nil, err
	}
	return &interstitialShownClient{Stream: s}, nil
}

type interstitialShownClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *interstitialShownClient) GetStream() rpcc.Stream { return c.Stream }

func (c *interstitialShownClient) Recv() (*InterstitialShownReply, error) {
	event := new(InterstitialShownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "InterstitialShown Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) JavascriptDialogClosed(ctx context.Context) (JavascriptDialogClosedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.javascriptDialogClosed", d.conn)
	if err != nil {
		return nil, err
	}
	return &javascriptDialogClosedClient{Stream: s}, nil
}

type javascriptDialogClosedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *javascriptDialogClosedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *javascriptDialogClosedClient) Recv() (*JavascriptDialogClosedReply, error) {
	event := new(JavascriptDialogClosedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "JavascriptDialogClosed Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) JavascriptDialogOpening(ctx context.Context) (JavascriptDialogOpeningClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.javascriptDialogOpening", d.conn)
	if err != nil {
		return nil, err
	}
	return &javascriptDialogOpeningClient{Stream: s}, nil
}

type javascriptDialogOpeningClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *javascriptDialogOpeningClient) GetStream() rpcc.Stream { return c.Stream }

func (c *javascriptDialogOpeningClient) Recv() (*JavascriptDialogOpeningReply, error) {
	event := new(JavascriptDialogOpeningReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "JavascriptDialogOpening Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) LifecycleEvent(ctx context.Context) (LifecycleEventClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.lifecycleEvent", d.conn)
	if err != nil {
		return nil, err
	}
	return &lifecycleEventClient{Stream: s}, nil
}

type lifecycleEventClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *lifecycleEventClient) GetStream() rpcc.Stream { return c.Stream }

func (c *lifecycleEventClient) Recv() (*LifecycleEventReply, error) {
	event := new(LifecycleEventReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "LifecycleEvent Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) BackForwardCacheNotUsed(ctx context.Context) (BackForwardCacheNotUsedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.backForwardCacheNotUsed", d.conn)
	if err != nil {
		return nil, err
	}
	return &backForwardCacheNotUsedClient{Stream: s}, nil
}

type backForwardCacheNotUsedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *backForwardCacheNotUsedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *backForwardCacheNotUsedClient) Recv() (*BackForwardCacheNotUsedReply, error) {
	event := new(BackForwardCacheNotUsedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "BackForwardCacheNotUsed Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) LoadEventFired(ctx context.Context) (LoadEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.loadEventFired", d.conn)
	if err != nil {
		return nil, err
	}
	return &loadEventFiredClient{Stream: s}, nil
}

type loadEventFiredClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *loadEventFiredClient) GetStream() rpcc.Stream { return c.Stream }

func (c *loadEventFiredClient) Recv() (*LoadEventFiredReply, error) {
	event := new(LoadEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "LoadEventFired Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) NavigatedWithinDocument(ctx context.Context) (NavigatedWithinDocumentClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.navigatedWithinDocument", d.conn)
	if err != nil {
		return nil, err
	}
	return &navigatedWithinDocumentClient{Stream: s}, nil
}

type navigatedWithinDocumentClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *navigatedWithinDocumentClient) GetStream() rpcc.Stream { return c.Stream }

func (c *navigatedWithinDocumentClient) Recv() (*NavigatedWithinDocumentReply, error) {
	event := new(NavigatedWithinDocumentReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "NavigatedWithinDocument Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ScreencastFrame(ctx context.Context) (ScreencastFrameClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.screencastFrame", d.conn)
	if err != nil {
		return nil, err
	}
	return &screencastFrameClient{Stream: s}, nil
}

type screencastFrameClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *screencastFrameClient) GetStream() rpcc.Stream { return c.Stream }

func (c *screencastFrameClient) Recv() (*ScreencastFrameReply, error) {
	event := new(ScreencastFrameReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "ScreencastFrame Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ScreencastVisibilityChanged(ctx context.Context) (ScreencastVisibilityChangedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.screencastVisibilityChanged", d.conn)
	if err != nil {
		return nil, err
	}
	return &screencastVisibilityChangedClient{Stream: s}, nil
}

type screencastVisibilityChangedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *screencastVisibilityChangedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *screencastVisibilityChangedClient) Recv() (*ScreencastVisibilityChangedReply, error) {
	event := new(ScreencastVisibilityChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "ScreencastVisibilityChanged Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) WindowOpen(ctx context.Context) (WindowOpenClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.windowOpen", d.conn)
	if err != nil {
		return nil, err
	}
	return &windowOpenClient{Stream: s}, nil
}

type windowOpenClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *windowOpenClient) GetStream() rpcc.Stream { return c.Stream }

func (c *windowOpenClient) Recv() (*WindowOpenReply, error) {
	event := new(WindowOpenReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "WindowOpen Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) CompilationCacheProduced(ctx context.Context) (CompilationCacheProducedClient, error) {
	s, err := rpcc.NewStream(ctx, "Page.compilationCacheProduced", d.conn)
	if err != nil {
		return nil, err
	}
	return &compilationCacheProducedClient{Stream: s}, nil
}

type compilationCacheProducedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *compilationCacheProducedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *compilationCacheProducedClient) Recv() (*CompilationCacheProducedReply, error) {
	event := new(CompilationCacheProducedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Page", Op: "CompilationCacheProduced Recv", Err: err}
	}
	return event, nil
}
