// Code generated by cdpgen. DO NOT EDIT.

package fetch

import (
	"github.com/mafredri/cdp/protocol/io"
	"github.com/mafredri/cdp/protocol/network"
)

// EnableArgs represents the arguments for Enable in the Fetch domain.
type EnableArgs struct {
	Patterns           []RequestPattern `json:"patterns,omitempty"`           // If specified, only requests matching any of these patterns will produce fetchRequested event and will be paused until clients response. If not set, all requests will be affected.
	HandleAuthRequests *bool            `json:"handleAuthRequests,omitempty"` // If true, authRequired events will be issued and requests will be paused expecting a call to continueWithAuth.
}

// NewEnableArgs initializes EnableArgs with the required arguments.
func NewEnableArgs() *EnableArgs {
	args := new(EnableArgs)

	return args
}

// SetPatterns sets the Patterns optional argument. If specified, only
// requests matching any of these patterns will produce fetchRequested
// event and will be paused until clients response. If not set, all
// requests will be affected.
func (a *EnableArgs) SetPatterns(patterns []RequestPattern) *EnableArgs {
	a.Patterns = patterns
	return a
}

// SetHandleAuthRequests sets the HandleAuthRequests optional argument.
// If true, authRequired events will be issued and requests will be
// paused expecting a call to continueWithAuth.
func (a *EnableArgs) SetHandleAuthRequests(handleAuthRequests bool) *EnableArgs {
	a.HandleAuthRequests = &handleAuthRequests
	return a
}

// FailRequestArgs represents the arguments for FailRequest in the Fetch domain.
type FailRequestArgs struct {
	RequestID   RequestID           `json:"requestId"`   // An id the client received in requestPaused event.
	ErrorReason network.ErrorReason `json:"errorReason"` // Causes the request to fail with the given reason.
}

// NewFailRequestArgs initializes FailRequestArgs with the required arguments.
func NewFailRequestArgs(requestID RequestID, errorReason network.ErrorReason) *FailRequestArgs {
	args := new(FailRequestArgs)
	args.RequestID = requestID
	args.ErrorReason = errorReason
	return args
}

// FulfillRequestArgs represents the arguments for FulfillRequest in the Fetch domain.
type FulfillRequestArgs struct {
	RequestID             RequestID     `json:"requestId"`                       // An id the client received in requestPaused event.
	ResponseCode          int           `json:"responseCode"`                    // An HTTP response code.
	ResponseHeaders       []HeaderEntry `json:"responseHeaders,omitempty"`       // Response headers.
	BinaryResponseHeaders []byte        `json:"binaryResponseHeaders,omitempty"` // Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
	Body                  []byte        `json:"body,omitempty"`                  // A response body. If absent, original response body will be used if the request is intercepted at the response stage and empty body will be used if the request is intercepted at the request stage. (Encoded as a base64 string when passed over JSON)
	ResponsePhrase        *string       `json:"responsePhrase,omitempty"`        // A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
}

// NewFulfillRequestArgs initializes FulfillRequestArgs with the required arguments.
func NewFulfillRequestArgs(requestID RequestID, responseCode int) *FulfillRequestArgs {
	args := new(FulfillRequestArgs)
	args.RequestID = requestID
	args.ResponseCode = responseCode
	return args
}

// SetResponseHeaders sets the ResponseHeaders optional argument.
// Response headers.
func (a *FulfillRequestArgs) SetResponseHeaders(responseHeaders []HeaderEntry) *FulfillRequestArgs {
	a.ResponseHeaders = responseHeaders
	return a
}

// SetBinaryResponseHeaders sets the BinaryResponseHeaders optional argument.
// Alternative way of specifying response headers as a \0-separated
// series of name: value pairs. Prefer the above method unless you need
// to represent some non-UTF8 values that can't be transmitted over the
// protocol as text. (Encoded as a base64 string when passed over JSON)
func (a *FulfillRequestArgs) SetBinaryResponseHeaders(binaryResponseHeaders []byte) *FulfillRequestArgs {
	a.BinaryResponseHeaders = binaryResponseHeaders
	return a
}

// SetBody sets the Body optional argument. A response body. If
// absent, original response body will be used if the request is
// intercepted at the response stage and empty body will be used if the
// request is intercepted at the request stage. (Encoded as a base64
// string when passed over JSON)
func (a *FulfillRequestArgs) SetBody(body []byte) *FulfillRequestArgs {
	a.Body = body
	return a
}

// SetResponsePhrase sets the ResponsePhrase optional argument. A
// textual representation of responseCode. If absent, a standard phrase
// matching responseCode is used.
func (a *FulfillRequestArgs) SetResponsePhrase(responsePhrase string) *FulfillRequestArgs {
	a.ResponsePhrase = &responsePhrase
	return a
}

// ContinueRequestArgs represents the arguments for ContinueRequest in the Fetch domain.
type ContinueRequestArgs struct {
	RequestID RequestID     `json:"requestId"`          // An id the client received in requestPaused event.
	URL       *string       `json:"url,omitempty"`      // If set, the request url will be modified in a way that's not observable by page.
	Method    *string       `json:"method,omitempty"`   // If set, the request method is overridden.
	PostData  []byte        `json:"postData,omitempty"` // If set, overrides the post data in the request. (Encoded as a base64 string when passed over JSON)
	Headers   []HeaderEntry `json:"headers,omitempty"`  // If set, overrides the request headers. Note that the overrides do not extend to subsequent redirect hops, if a redirect happens. Another override may be applied to a different request produced by a redirect.
	// InterceptResponse If set, overrides response interception behavior
	// for this request.
	//
	// Note: This property is experimental.
	InterceptResponse *bool `json:"interceptResponse,omitempty"`
}

// NewContinueRequestArgs initializes ContinueRequestArgs with the required arguments.
func NewContinueRequestArgs(requestID RequestID) *ContinueRequestArgs {
	args := new(ContinueRequestArgs)
	args.RequestID = requestID
	return args
}

// SetURL sets the URL optional argument. If set, the request url will
// be modified in a way that's not observable by page.
func (a *ContinueRequestArgs) SetURL(url string) *ContinueRequestArgs {
	a.URL = &url
	return a
}

// SetMethod sets the Method optional argument. If set, the request
// method is overridden.
func (a *ContinueRequestArgs) SetMethod(method string) *ContinueRequestArgs {
	a.Method = &method
	return a
}

// SetPostData sets the PostData optional argument. If set, overrides
// the post data in the request. (Encoded as a base64 string when
// passed over JSON)
func (a *ContinueRequestArgs) SetPostData(postData []byte) *ContinueRequestArgs {
	a.PostData = postData
	return a
}

// SetHeaders sets the Headers optional argument. If set, overrides
// the request headers. Note that the overrides do not extend to
// subsequent redirect hops, if a redirect happens. Another override
// may be applied to a different request produced by a redirect.
func (a *ContinueRequestArgs) SetHeaders(headers []HeaderEntry) *ContinueRequestArgs {
	a.Headers = headers
	return a
}

// SetInterceptResponse sets the InterceptResponse optional argument.
// If set, overrides response interception behavior for this request.
//
// Note: This property is experimental.
func (a *ContinueRequestArgs) SetInterceptResponse(interceptResponse bool) *ContinueRequestArgs {
	a.InterceptResponse = &interceptResponse
	return a
}

// ContinueWithAuthArgs represents the arguments for ContinueWithAuth in the Fetch domain.
type ContinueWithAuthArgs struct {
	RequestID             RequestID             `json:"requestId"`             // An id the client received in authRequired event.
	AuthChallengeResponse AuthChallengeResponse `json:"authChallengeResponse"` // Response to with an authChallenge.
}

// NewContinueWithAuthArgs initializes ContinueWithAuthArgs with the required arguments.
func NewContinueWithAuthArgs(requestID RequestID, authChallengeResponse AuthChallengeResponse) *ContinueWithAuthArgs {
	args := new(ContinueWithAuthArgs)
	args.RequestID = requestID
	args.AuthChallengeResponse = authChallengeResponse
	return args
}

// ContinueResponseArgs represents the arguments for ContinueResponse in the Fetch domain.
type ContinueResponseArgs struct {
	RequestID             RequestID     `json:"requestId"`                       // An id the client received in requestPaused event.
	ResponseCode          *int          `json:"responseCode,omitempty"`          // An HTTP response code. If absent, original response code will be used.
	ResponsePhrase        *string       `json:"responsePhrase,omitempty"`        // A textual representation of responseCode. If absent, a standard phrase matching responseCode is used.
	ResponseHeaders       []HeaderEntry `json:"responseHeaders,omitempty"`       // Response headers. If absent, original response headers will be used.
	BinaryResponseHeaders []byte        `json:"binaryResponseHeaders,omitempty"` // Alternative way of specifying response headers as a \0-separated series of name: value pairs. Prefer the above method unless you need to represent some non-UTF8 values that can't be transmitted over the protocol as text. (Encoded as a base64 string when passed over JSON)
}

// NewContinueResponseArgs initializes ContinueResponseArgs with the required arguments.
func NewContinueResponseArgs(requestID RequestID) *ContinueResponseArgs {
	args := new(ContinueResponseArgs)
	args.RequestID = requestID
	return args
}

// SetResponseCode sets the ResponseCode optional argument. An HTTP
// response code. If absent, original response code will be used.
func (a *ContinueResponseArgs) SetResponseCode(responseCode int) *ContinueResponseArgs {
	a.ResponseCode = &responseCode
	return a
}

// SetResponsePhrase sets the ResponsePhrase optional argument. A
// textual representation of responseCode. If absent, a standard phrase
// matching responseCode is used.
func (a *ContinueResponseArgs) SetResponsePhrase(responsePhrase string) *ContinueResponseArgs {
	a.ResponsePhrase = &responsePhrase
	return a
}

// SetResponseHeaders sets the ResponseHeaders optional argument.
// Response headers. If absent, original response headers will be used.
func (a *ContinueResponseArgs) SetResponseHeaders(responseHeaders []HeaderEntry) *ContinueResponseArgs {
	a.ResponseHeaders = responseHeaders
	return a
}

// SetBinaryResponseHeaders sets the BinaryResponseHeaders optional argument.
// Alternative way of specifying response headers as a \0-separated
// series of name: value pairs. Prefer the above method unless you need
// to represent some non-UTF8 values that can't be transmitted over the
// protocol as text. (Encoded as a base64 string when passed over JSON)
func (a *ContinueResponseArgs) SetBinaryResponseHeaders(binaryResponseHeaders []byte) *ContinueResponseArgs {
	a.BinaryResponseHeaders = binaryResponseHeaders
	return a
}

// GetResponseBodyArgs represents the arguments for GetResponseBody in the Fetch domain.
type GetResponseBodyArgs struct {
	RequestID RequestID `json:"requestId"` // Identifier for the intercepted request to get body for.
}

// NewGetResponseBodyArgs initializes GetResponseBodyArgs with the required arguments.
func NewGetResponseBodyArgs(requestID RequestID) *GetResponseBodyArgs {
	args := new(GetResponseBodyArgs)
	args.RequestID = requestID
	return args
}

// GetResponseBodyReply represents the return values for GetResponseBody in the Fetch domain.
type GetResponseBodyReply struct {
	Body          string `json:"body"`          // Response body.
	Base64Encoded bool   `json:"base64Encoded"` // True, if content was sent as base64.
}

// TakeResponseBodyAsStreamArgs represents the arguments for TakeResponseBodyAsStream in the Fetch domain.
type TakeResponseBodyAsStreamArgs struct {
	RequestID RequestID `json:"requestId"` // No description.
}

// NewTakeResponseBodyAsStreamArgs initializes TakeResponseBodyAsStreamArgs with the required arguments.
func NewTakeResponseBodyAsStreamArgs(requestID RequestID) *TakeResponseBodyAsStreamArgs {
	args := new(TakeResponseBodyAsStreamArgs)
	args.RequestID = requestID
	return args
}

// TakeResponseBodyAsStreamReply represents the return values for TakeResponseBodyAsStream in the Fetch domain.
type TakeResponseBodyAsStreamReply struct {
	Stream io.StreamHandle `json:"stream"` // No description.
}
