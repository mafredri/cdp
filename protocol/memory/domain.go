// Code generated by cdpgen. DO NOT EDIT.

// Package memory implements the Memory domain.
package memory

import (
	"context"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/rpcc"
)

// domainClient is a client for the Memory domain.
type domainClient struct{ conn *rpcc.Conn }

// NewClient returns a client for the Memory domain with the connection set to conn.
func NewClient(conn *rpcc.Conn) *domainClient {
	return &domainClient{conn: conn}
}

// GetDOMCounters invokes the Memory method. Retruns current DOM object
// counters.
func (d *domainClient) GetDOMCounters(ctx context.Context) (reply *GetDOMCountersReply, err error) {
	reply = new(GetDOMCountersReply)
	err = rpcc.Invoke(ctx, "Memory.getDOMCounters", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "GetDOMCounters", Err: err}
	}
	return
}

// GetDOMCountersForLeakDetection invokes the Memory method. Retruns DOM
// object counters after preparing renderer for leak detection.
func (d *domainClient) GetDOMCountersForLeakDetection(ctx context.Context) (reply *GetDOMCountersForLeakDetectionReply, err error) {
	reply = new(GetDOMCountersForLeakDetectionReply)
	err = rpcc.Invoke(ctx, "Memory.getDOMCountersForLeakDetection", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "GetDOMCountersForLeakDetection", Err: err}
	}
	return
}

// PrepareForLeakDetection invokes the Memory method. Prepares for leak
// detection by terminating workers, stopping spellcheckers, dropping
// non-essential internal caches, running garbage collections, etc.
func (d *domainClient) PrepareForLeakDetection(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Memory.prepareForLeakDetection", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "PrepareForLeakDetection", Err: err}
	}
	return
}

// ForciblyPurgeJavaScriptMemory invokes the Memory method. Simulate
// OomIntervention by purging V8 memory.
func (d *domainClient) ForciblyPurgeJavaScriptMemory(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Memory.forciblyPurgeJavaScriptMemory", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "ForciblyPurgeJavaScriptMemory", Err: err}
	}
	return
}

// SetPressureNotificationsSuppressed invokes the Memory method.
// Enable/disable suppressing memory pressure notifications in all processes.
func (d *domainClient) SetPressureNotificationsSuppressed(ctx context.Context, args *SetPressureNotificationsSuppressedArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Memory.setPressureNotificationsSuppressed", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Memory.setPressureNotificationsSuppressed", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "SetPressureNotificationsSuppressed", Err: err}
	}
	return
}

// SimulatePressureNotification invokes the Memory method. Simulate a memory
// pressure notification in all processes.
func (d *domainClient) SimulatePressureNotification(ctx context.Context, args *SimulatePressureNotificationArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Memory.simulatePressureNotification", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Memory.simulatePressureNotification", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "SimulatePressureNotification", Err: err}
	}
	return
}

// StartSampling invokes the Memory method. Start collecting native memory
// profile.
func (d *domainClient) StartSampling(ctx context.Context, args *StartSamplingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Memory.startSampling", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Memory.startSampling", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "StartSampling", Err: err}
	}
	return
}

// StopSampling invokes the Memory method. Stop collecting native memory
// profile.
func (d *domainClient) StopSampling(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Memory.stopSampling", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "StopSampling", Err: err}
	}
	return
}

// GetAllTimeSamplingProfile invokes the Memory method. Retrieve native memory
// allocations profile collected since renderer process startup.
func (d *domainClient) GetAllTimeSamplingProfile(ctx context.Context) (reply *GetAllTimeSamplingProfileReply, err error) {
	reply = new(GetAllTimeSamplingProfileReply)
	err = rpcc.Invoke(ctx, "Memory.getAllTimeSamplingProfile", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "GetAllTimeSamplingProfile", Err: err}
	}
	return
}

// GetBrowserSamplingProfile invokes the Memory method. Retrieve native memory
// allocations profile collected since browser process startup.
func (d *domainClient) GetBrowserSamplingProfile(ctx context.Context) (reply *GetBrowserSamplingProfileReply, err error) {
	reply = new(GetBrowserSamplingProfileReply)
	err = rpcc.Invoke(ctx, "Memory.getBrowserSamplingProfile", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "GetBrowserSamplingProfile", Err: err}
	}
	return
}

// GetSamplingProfile invokes the Memory method. Retrieve native memory
// allocations profile collected since last `startSampling` call.
func (d *domainClient) GetSamplingProfile(ctx context.Context) (reply *GetSamplingProfileReply, err error) {
	reply = new(GetSamplingProfileReply)
	err = rpcc.Invoke(ctx, "Memory.getSamplingProfile", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Memory", Op: "GetSamplingProfile", Err: err}
	}
	return
}
