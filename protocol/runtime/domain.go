// Code generated by cdpgen. DO NOT EDIT.

// Package runtime implements the Runtime domain. Runtime domain exposes
// JavaScript runtime by means of remote evaluation and mirror objects.
// Evaluation results are returned as mirror object that expose object type,
// string representation and unique identifier that can be used for further
// object reference. Original objects are maintained in memory unless they are
// either explicitly released or are released along with the other objects in
// their object group.
package runtime

import (
	"context"

	"github.com/mafredri/cdp/protocol/internal"
	"github.com/mafredri/cdp/rpcc"
)

// domainClient is a client for the Runtime domain. Runtime domain exposes
// JavaScript runtime by means of remote evaluation and mirror objects.
// Evaluation results are returned as mirror object that expose object type,
// string representation and unique identifier that can be used for further
// object reference. Original objects are maintained in memory unless they are
// either explicitly released or are released along with the other objects in
// their object group.
type domainClient struct{ conn *rpcc.Conn }

// NewClient returns a client for the Runtime domain with the connection set to conn.
func NewClient(conn *rpcc.Conn) *domainClient {
	return &domainClient{conn: conn}
}

// AwaitPromise invokes the Runtime method. Add handler to promise with given
// promise object id.
func (d *domainClient) AwaitPromise(ctx context.Context, args *AwaitPromiseArgs) (reply *AwaitPromiseReply, err error) {
	reply = new(AwaitPromiseReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.awaitPromise", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.awaitPromise", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "AwaitPromise", Err: err}
	}
	return
}

// CallFunctionOn invokes the Runtime method. Calls function with given
// declaration on the given object. Object group of the result is inherited
// from the target object.
func (d *domainClient) CallFunctionOn(ctx context.Context, args *CallFunctionOnArgs) (reply *CallFunctionOnReply, err error) {
	reply = new(CallFunctionOnReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.callFunctionOn", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.callFunctionOn", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "CallFunctionOn", Err: err}
	}
	return
}

// CompileScript invokes the Runtime method. Compiles expression.
func (d *domainClient) CompileScript(ctx context.Context, args *CompileScriptArgs) (reply *CompileScriptReply, err error) {
	reply = new(CompileScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.compileScript", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.compileScript", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "CompileScript", Err: err}
	}
	return
}

// Disable invokes the Runtime method. Disables reporting of execution
// contexts creation.
func (d *domainClient) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.disable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Disable", Err: err}
	}
	return
}

// DiscardConsoleEntries invokes the Runtime method. Discards collected
// exceptions and console API calls.
func (d *domainClient) DiscardConsoleEntries(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.discardConsoleEntries", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "DiscardConsoleEntries", Err: err}
	}
	return
}

// Enable invokes the Runtime method. Enables reporting of execution contexts
// creation by means of `executionContextCreated` event. When the reporting
// gets enabled the event will be sent immediately for each existing execution
// context.
func (d *domainClient) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.enable", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Enable", Err: err}
	}
	return
}

// Evaluate invokes the Runtime method. Evaluates expression on global object.
func (d *domainClient) Evaluate(ctx context.Context, args *EvaluateArgs) (reply *EvaluateReply, err error) {
	reply = new(EvaluateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.evaluate", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.evaluate", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "Evaluate", Err: err}
	}
	return
}

// GetIsolateID invokes the Runtime method. Returns the isolate id.
func (d *domainClient) GetIsolateID(ctx context.Context) (reply *GetIsolateIDReply, err error) {
	reply = new(GetIsolateIDReply)
	err = rpcc.Invoke(ctx, "Runtime.getIsolateId", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GetIsolateID", Err: err}
	}
	return
}

// GetHeapUsage invokes the Runtime method. Returns the JavaScript heap usage.
// It is the total usage of the corresponding isolate not scoped to a
// particular Runtime.
func (d *domainClient) GetHeapUsage(ctx context.Context) (reply *GetHeapUsageReply, err error) {
	reply = new(GetHeapUsageReply)
	err = rpcc.Invoke(ctx, "Runtime.getHeapUsage", nil, reply, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GetHeapUsage", Err: err}
	}
	return
}

// GetProperties invokes the Runtime method. Returns properties of a given
// object. Object group of the result is inherited from the target object.
func (d *domainClient) GetProperties(ctx context.Context, args *GetPropertiesArgs) (reply *GetPropertiesReply, err error) {
	reply = new(GetPropertiesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.getProperties", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.getProperties", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GetProperties", Err: err}
	}
	return
}

// GlobalLexicalScopeNames invokes the Runtime method. Returns all let, const
// and class variables from global scope.
func (d *domainClient) GlobalLexicalScopeNames(ctx context.Context, args *GlobalLexicalScopeNamesArgs) (reply *GlobalLexicalScopeNamesReply, err error) {
	reply = new(GlobalLexicalScopeNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.globalLexicalScopeNames", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.globalLexicalScopeNames", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GlobalLexicalScopeNames", Err: err}
	}
	return
}

// QueryObjects invokes the Runtime method.
func (d *domainClient) QueryObjects(ctx context.Context, args *QueryObjectsArgs) (reply *QueryObjectsReply, err error) {
	reply = new(QueryObjectsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.queryObjects", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.queryObjects", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "QueryObjects", Err: err}
	}
	return
}

// ReleaseObject invokes the Runtime method. Releases remote object with given
// id.
func (d *domainClient) ReleaseObject(ctx context.Context, args *ReleaseObjectArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.releaseObject", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.releaseObject", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "ReleaseObject", Err: err}
	}
	return
}

// ReleaseObjectGroup invokes the Runtime method. Releases all remote objects
// that belong to a given group.
func (d *domainClient) ReleaseObjectGroup(ctx context.Context, args *ReleaseObjectGroupArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.releaseObjectGroup", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.releaseObjectGroup", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "ReleaseObjectGroup", Err: err}
	}
	return
}

// RunIfWaitingForDebugger invokes the Runtime method. Tells inspected
// instance to run if it was waiting for debugger to attach.
func (d *domainClient) RunIfWaitingForDebugger(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.runIfWaitingForDebugger", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "RunIfWaitingForDebugger", Err: err}
	}
	return
}

// RunScript invokes the Runtime method. Runs script with given id in a given
// context.
func (d *domainClient) RunScript(ctx context.Context, args *RunScriptArgs) (reply *RunScriptReply, err error) {
	reply = new(RunScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.runScript", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.runScript", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "RunScript", Err: err}
	}
	return
}

// SetCustomObjectFormatterEnabled invokes the Runtime method.
func (d *domainClient) SetCustomObjectFormatterEnabled(ctx context.Context, args *SetCustomObjectFormatterEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.setCustomObjectFormatterEnabled", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.setCustomObjectFormatterEnabled", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "SetCustomObjectFormatterEnabled", Err: err}
	}
	return
}

// SetMaxCallStackSizeToCapture invokes the Runtime method.
func (d *domainClient) SetMaxCallStackSizeToCapture(ctx context.Context, args *SetMaxCallStackSizeToCaptureArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.setMaxCallStackSizeToCapture", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.setMaxCallStackSizeToCapture", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "SetMaxCallStackSizeToCapture", Err: err}
	}
	return
}

// TerminateExecution invokes the Runtime method. Terminate current or next
// JavaScript execution. Will cancel the termination when the outer-most script
// execution ends.
func (d *domainClient) TerminateExecution(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, "Runtime.terminateExecution", nil, nil, d.conn)
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "TerminateExecution", Err: err}
	}
	return
}

// AddBinding invokes the Runtime method. If executionContextId is empty, adds
// binding with the given name on the global objects of all inspected contexts,
// including those created later, bindings survive reloads. Binding function
// takes exactly one argument, this argument should be string, in case of any
// other input, function throws an exception. Each binding function call
// produces Runtime.bindingCalled notification.
func (d *domainClient) AddBinding(ctx context.Context, args *AddBindingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.addBinding", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.addBinding", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "AddBinding", Err: err}
	}
	return
}

// RemoveBinding invokes the Runtime method. This method does not remove
// binding function from global object but unsubscribes current runtime agent
// from Runtime.bindingCalled notifications.
func (d *domainClient) RemoveBinding(ctx context.Context, args *RemoveBindingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.removeBinding", args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.removeBinding", nil, nil, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "RemoveBinding", Err: err}
	}
	return
}

// GetExceptionDetails invokes the Runtime method. This method tries to lookup
// and populate exception details for a JavaScript Error object. Note that the
// stackTrace portion of the resulting exceptionDetails will only be populated
// if the Runtime domain was enabled at the time when the Error was thrown.
func (d *domainClient) GetExceptionDetails(ctx context.Context, args *GetExceptionDetailsArgs) (reply *GetExceptionDetailsReply, err error) {
	reply = new(GetExceptionDetailsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, "Runtime.getExceptionDetails", args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, "Runtime.getExceptionDetails", nil, reply, d.conn)
	}
	if err != nil {
		err = &internal.OpError{Domain: "Runtime", Op: "GetExceptionDetails", Err: err}
	}
	return
}

func (d *domainClient) BindingCalled(ctx context.Context) (BindingCalledClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.bindingCalled", d.conn)
	if err != nil {
		return nil, err
	}
	return &bindingCalledClient{Stream: s}, nil
}

type bindingCalledClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *bindingCalledClient) GetStream() rpcc.Stream { return c.Stream }

func (c *bindingCalledClient) Recv() (*BindingCalledReply, error) {
	event := new(BindingCalledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "BindingCalled Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ConsoleAPICalled(ctx context.Context) (ConsoleAPICalledClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.consoleAPICalled", d.conn)
	if err != nil {
		return nil, err
	}
	return &consoleAPICalledClient{Stream: s}, nil
}

type consoleAPICalledClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *consoleAPICalledClient) GetStream() rpcc.Stream { return c.Stream }

func (c *consoleAPICalledClient) Recv() (*ConsoleAPICalledReply, error) {
	event := new(ConsoleAPICalledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ConsoleAPICalled Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExceptionRevoked(ctx context.Context) (ExceptionRevokedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.exceptionRevoked", d.conn)
	if err != nil {
		return nil, err
	}
	return &exceptionRevokedClient{Stream: s}, nil
}

type exceptionRevokedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *exceptionRevokedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *exceptionRevokedClient) Recv() (*ExceptionRevokedReply, error) {
	event := new(ExceptionRevokedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExceptionRevoked Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExceptionThrown(ctx context.Context) (ExceptionThrownClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.exceptionThrown", d.conn)
	if err != nil {
		return nil, err
	}
	return &exceptionThrownClient{Stream: s}, nil
}

type exceptionThrownClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *exceptionThrownClient) GetStream() rpcc.Stream { return c.Stream }

func (c *exceptionThrownClient) Recv() (*ExceptionThrownReply, error) {
	event := new(ExceptionThrownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExceptionThrown Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExecutionContextCreated(ctx context.Context) (ExecutionContextCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextCreated", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextCreatedClient{Stream: s}, nil
}

type executionContextCreatedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextCreatedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextCreatedClient) Recv() (*ExecutionContextCreatedReply, error) {
	event := new(ExecutionContextCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextCreated Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExecutionContextDestroyed(ctx context.Context) (ExecutionContextDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextDestroyed", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextDestroyedClient{Stream: s}, nil
}

type executionContextDestroyedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextDestroyedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextDestroyedClient) Recv() (*ExecutionContextDestroyedReply, error) {
	event := new(ExecutionContextDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextDestroyed Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) ExecutionContextsCleared(ctx context.Context) (ExecutionContextsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.executionContextsCleared", d.conn)
	if err != nil {
		return nil, err
	}
	return &executionContextsClearedClient{Stream: s}, nil
}

type executionContextsClearedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *executionContextsClearedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *executionContextsClearedClient) Recv() (*ExecutionContextsClearedReply, error) {
	event := new(ExecutionContextsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "ExecutionContextsCleared Recv", Err: err}
	}
	return event, nil
}

func (d *domainClient) InspectRequested(ctx context.Context) (InspectRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, "Runtime.inspectRequested", d.conn)
	if err != nil {
		return nil, err
	}
	return &inspectRequestedClient{Stream: s}, nil
}

type inspectRequestedClient struct{ rpcc.Stream }

// GetStream returns the original Stream for use with cdp.Sync.
func (c *inspectRequestedClient) GetStream() rpcc.Stream { return c.Stream }

func (c *inspectRequestedClient) Recv() (*InspectRequestedReply, error) {
	event := new(InspectRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &internal.OpError{Domain: "Runtime", Op: "InspectRequested Recv", Err: err}
	}
	return event, nil
}
