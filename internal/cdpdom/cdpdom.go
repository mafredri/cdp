// Code generated by cdpgen; DO NOT EDIT!

package cdpdom

import (
	"context"

	"github.com/mafredri/cdp/cdpcmd"
	"github.com/mafredri/cdp/cdpevent"
	"github.com/mafredri/cdp/rpcc"
)

// The Accessibility domain.
type Accessibility struct{ conn *rpcc.Conn }

// NewAccessibility returns the domain with the connection set to conn.
func NewAccessibility(conn *rpcc.Conn) *Accessibility {
	return &Accessibility{conn: conn}
}

// GetPartialAXTree invokes the Accessibility method. Fetches the accessibility node and partial accessibility tree for this DOM node, if it exists.
func (d *Accessibility) GetPartialAXTree(ctx context.Context, args *cdpcmd.AccessibilityGetPartialAXTreeArgs) (reply *cdpcmd.AccessibilityGetPartialAXTreeReply, err error) {
	reply = new(cdpcmd.AccessibilityGetPartialAXTreeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AccessibilityGetPartialAXTree.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AccessibilityGetPartialAXTree.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Accessibility", Op: "GetPartialAXTree", Err: err}
	}
	return
}

// The Animation domain.
type Animation struct{ conn *rpcc.Conn }

// NewAnimation returns the domain with the connection set to conn.
func NewAnimation(conn *rpcc.Conn) *Animation {
	return &Animation{conn: conn}
}

// Enable invokes the Animation method. Enables animation domain notifications.
func (d *Animation) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.AnimationEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Animation", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Animation method. Disables animation domain notifications.
func (d *Animation) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.AnimationDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Animation", Op: "Disable", Err: err}
	}
	return
}

// GetPlaybackRate invokes the Animation method. Gets the playback rate of the document timeline.
func (d *Animation) GetPlaybackRate(ctx context.Context) (reply *cdpcmd.AnimationGetPlaybackRateReply, err error) {
	reply = new(cdpcmd.AnimationGetPlaybackRateReply)
	err = rpcc.Invoke(ctx, cdpcmd.AnimationGetPlaybackRate.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Animation", Op: "GetPlaybackRate", Err: err}
	}
	return
}

// SetPlaybackRate invokes the Animation method. Sets the playback rate of the document timeline.
func (d *Animation) SetPlaybackRate(ctx context.Context, args *cdpcmd.AnimationSetPlaybackRateArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPlaybackRate.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPlaybackRate.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "SetPlaybackRate", Err: err}
	}
	return
}

// GetCurrentTime invokes the Animation method. Returns the current time of the an animation.
func (d *Animation) GetCurrentTime(ctx context.Context, args *cdpcmd.AnimationGetCurrentTimeArgs) (reply *cdpcmd.AnimationGetCurrentTimeReply, err error) {
	reply = new(cdpcmd.AnimationGetCurrentTimeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationGetCurrentTime.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationGetCurrentTime.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "GetCurrentTime", Err: err}
	}
	return
}

// SetPaused invokes the Animation method. Sets the paused state of a set of animations.
func (d *Animation) SetPaused(ctx context.Context, args *cdpcmd.AnimationSetPausedArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPaused.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetPaused.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "SetPaused", Err: err}
	}
	return
}

// SetTiming invokes the Animation method. Sets the timing of an animation node.
func (d *Animation) SetTiming(ctx context.Context, args *cdpcmd.AnimationSetTimingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetTiming.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSetTiming.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "SetTiming", Err: err}
	}
	return
}

// SeekAnimations invokes the Animation method. Seek a set of animations to a particular time within each animation.
func (d *Animation) SeekAnimations(ctx context.Context, args *cdpcmd.AnimationSeekAnimationsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSeekAnimations.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationSeekAnimations.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "SeekAnimations", Err: err}
	}
	return
}

// ReleaseAnimations invokes the Animation method. Releases a set of animations to no longer be manipulated.
func (d *Animation) ReleaseAnimations(ctx context.Context, args *cdpcmd.AnimationReleaseAnimationsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationReleaseAnimations.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationReleaseAnimations.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "ReleaseAnimations", Err: err}
	}
	return
}

// ResolveAnimation invokes the Animation method. Gets the remote object of the Animation.
func (d *Animation) ResolveAnimation(ctx context.Context, args *cdpcmd.AnimationResolveAnimationArgs) (reply *cdpcmd.AnimationResolveAnimationReply, err error) {
	reply = new(cdpcmd.AnimationResolveAnimationReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationResolveAnimation.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.AnimationResolveAnimation.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Animation", Op: "ResolveAnimation", Err: err}
	}
	return
}

// AnimationCreated creates the event client. Event for each animation that has been created.
func (d *Animation) AnimationCreated(ctx context.Context) (cdpevent.AnimationCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &AnimationCreatedClient{Stream: s}, nil
}

// AnimationCreatedClient implements cdpevent.AnimationCreatedClient.
type AnimationCreatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *AnimationCreatedClient) Recv() (*cdpevent.AnimationCreatedReply, error) {
	event := new(cdpevent.AnimationCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Animation", Op: "AnimationCreated Recv", Err: err}
	}
	return event, nil
}

// AnimationStarted creates the event client. Event for animation that has been started.
func (d *Animation) AnimationStarted(ctx context.Context) (cdpevent.AnimationStartedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationStarted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &AnimationStartedClient{Stream: s}, nil
}

// AnimationStartedClient implements cdpevent.AnimationStartedClient.
type AnimationStartedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *AnimationStartedClient) Recv() (*cdpevent.AnimationStartedReply, error) {
	event := new(cdpevent.AnimationStartedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Animation", Op: "AnimationStarted Recv", Err: err}
	}
	return event, nil
}

// AnimationCanceled creates the event client. Event for when an animation has been canceled.
func (d *Animation) AnimationCanceled(ctx context.Context) (cdpevent.AnimationCanceledClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.AnimationCanceled.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &AnimationCanceledClient{Stream: s}, nil
}

// AnimationCanceledClient implements cdpevent.AnimationCanceledClient.
type AnimationCanceledClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *AnimationCanceledClient) Recv() (*cdpevent.AnimationCanceledReply, error) {
	event := new(cdpevent.AnimationCanceledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Animation", Op: "AnimationCanceled Recv", Err: err}
	}
	return event, nil
}

// The ApplicationCache domain.
type ApplicationCache struct{ conn *rpcc.Conn }

// NewApplicationCache returns the domain with the connection set to conn.
func NewApplicationCache(conn *rpcc.Conn) *ApplicationCache {
	return &ApplicationCache{conn: conn}
}

// GetFramesWithManifests invokes the ApplicationCache method. Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache.
func (d *ApplicationCache) GetFramesWithManifests(ctx context.Context) (reply *cdpcmd.ApplicationCacheGetFramesWithManifestsReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetFramesWithManifestsReply)
	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetFramesWithManifests.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "ApplicationCache", Op: "GetFramesWithManifests", Err: err}
	}
	return
}

// Enable invokes the ApplicationCache method. Enables application cache domain notifications.
func (d *ApplicationCache) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "ApplicationCache", Op: "Enable", Err: err}
	}
	return
}

// GetManifestForFrame invokes the ApplicationCache method. Returns manifest URL for document in the given frame.
func (d *ApplicationCache) GetManifestForFrame(ctx context.Context, args *cdpcmd.ApplicationCacheGetManifestForFrameArgs) (reply *cdpcmd.ApplicationCacheGetManifestForFrameReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetManifestForFrameReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetManifestForFrame.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetManifestForFrame.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ApplicationCache", Op: "GetManifestForFrame", Err: err}
	}
	return
}

// GetApplicationCacheForFrame invokes the ApplicationCache method. Returns relevant application cache data for the document in given frame.
func (d *ApplicationCache) GetApplicationCacheForFrame(ctx context.Context, args *cdpcmd.ApplicationCacheGetApplicationCacheForFrameArgs) (reply *cdpcmd.ApplicationCacheGetApplicationCacheForFrameReply, err error) {
	reply = new(cdpcmd.ApplicationCacheGetApplicationCacheForFrameReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetApplicationCacheForFrame.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ApplicationCacheGetApplicationCacheForFrame.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ApplicationCache", Op: "GetApplicationCacheForFrame", Err: err}
	}
	return
}

// ApplicationCacheStatusUpdated creates the event client.
func (d *ApplicationCache) ApplicationCacheStatusUpdated(ctx context.Context) (cdpevent.ApplicationCacheStatusUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ApplicationCacheStatusUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ApplicationCacheStatusUpdatedClient{Stream: s}, nil
}

// ApplicationCacheStatusUpdatedClient implements cdpevent.ApplicationCacheStatusUpdatedClient.
type ApplicationCacheStatusUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ApplicationCacheStatusUpdatedClient) Recv() (*cdpevent.ApplicationCacheStatusUpdatedReply, error) {
	event := new(cdpevent.ApplicationCacheStatusUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "ApplicationCache", Op: "ApplicationCacheStatusUpdated Recv", Err: err}
	}
	return event, nil
}

// NetworkStateUpdated creates the event client.
func (d *ApplicationCache) NetworkStateUpdated(ctx context.Context) (cdpevent.ApplicationCacheNetworkStateUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ApplicationCacheNetworkStateUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ApplicationCacheNetworkStateUpdatedClient{Stream: s}, nil
}

// ApplicationCacheNetworkStateUpdatedClient implements cdpevent.ApplicationCacheNetworkStateUpdatedClient.
type ApplicationCacheNetworkStateUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ApplicationCacheNetworkStateUpdatedClient) Recv() (*cdpevent.ApplicationCacheNetworkStateUpdatedReply, error) {
	event := new(cdpevent.ApplicationCacheNetworkStateUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "ApplicationCache", Op: "NetworkStateUpdated Recv", Err: err}
	}
	return event, nil
}

// The Browser domain. The Browser domain defines methods and events for browser managing.
type Browser struct{ conn *rpcc.Conn }

// NewBrowser returns the domain with the connection set to conn.
func NewBrowser(conn *rpcc.Conn) *Browser {
	return &Browser{conn: conn}
}

// GetWindowForTarget invokes the Browser method. Get the browser window that contains the devtools target.
func (d *Browser) GetWindowForTarget(ctx context.Context, args *cdpcmd.BrowserGetWindowForTargetArgs) (reply *cdpcmd.BrowserGetWindowForTargetReply, err error) {
	reply = new(cdpcmd.BrowserGetWindowForTargetReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserGetWindowForTarget.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserGetWindowForTarget.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Browser", Op: "GetWindowForTarget", Err: err}
	}
	return
}

// SetWindowBounds invokes the Browser method. Set position and/or size of the browser window.
func (d *Browser) SetWindowBounds(ctx context.Context, args *cdpcmd.BrowserSetWindowBoundsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserSetWindowBounds.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserSetWindowBounds.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Browser", Op: "SetWindowBounds", Err: err}
	}
	return
}

// GetWindowBounds invokes the Browser method. Get position and size of the browser window.
func (d *Browser) GetWindowBounds(ctx context.Context, args *cdpcmd.BrowserGetWindowBoundsArgs) (reply *cdpcmd.BrowserGetWindowBoundsReply, err error) {
	reply = new(cdpcmd.BrowserGetWindowBoundsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserGetWindowBounds.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.BrowserGetWindowBounds.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Browser", Op: "GetWindowBounds", Err: err}
	}
	return
}

// The CSS domain. This domain exposes CSS read/write operations. All CSS objects (stylesheets, rules, and styles) have an associated id used in subsequent operations on the related object. Each object type has a specific id structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the get*ForNode() calls (which accept a DOM node id). A client can also discover all the existing stylesheets with the getAllStyleSheets() method (or keeping track of the styleSheetAdded/styleSheetRemoved events) and subsequently load the required stylesheet contents using the getStyleSheet[Text]() methods.
type CSS struct{ conn *rpcc.Conn }

// NewCSS returns the domain with the connection set to conn.
func NewCSS(conn *rpcc.Conn) *CSS {
	return &CSS{conn: conn}
}

// Enable invokes the CSS method. Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received.
func (d *CSS) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.CSSEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the CSS method. Disables the CSS agent for the given page.
func (d *CSS) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.CSSDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "Disable", Err: err}
	}
	return
}

// GetMatchedStylesForNode invokes the CSS method. Returns requested styles for a DOM node identified by nodeId.
func (d *CSS) GetMatchedStylesForNode(ctx context.Context, args *cdpcmd.CSSGetMatchedStylesForNodeArgs) (reply *cdpcmd.CSSGetMatchedStylesForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetMatchedStylesForNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetMatchedStylesForNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetMatchedStylesForNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetMatchedStylesForNode", Err: err}
	}
	return
}

// GetInlineStylesForNode invokes the CSS method. Returns the styles defined inline (explicitly in the "style" attribute and implicitly, using DOM attributes) for a DOM node identified by nodeId.
func (d *CSS) GetInlineStylesForNode(ctx context.Context, args *cdpcmd.CSSGetInlineStylesForNodeArgs) (reply *cdpcmd.CSSGetInlineStylesForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetInlineStylesForNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetInlineStylesForNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetInlineStylesForNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetInlineStylesForNode", Err: err}
	}
	return
}

// GetComputedStyleForNode invokes the CSS method. Returns the computed style for a DOM node identified by nodeId.
func (d *CSS) GetComputedStyleForNode(ctx context.Context, args *cdpcmd.CSSGetComputedStyleForNodeArgs) (reply *cdpcmd.CSSGetComputedStyleForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetComputedStyleForNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetComputedStyleForNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetComputedStyleForNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetComputedStyleForNode", Err: err}
	}
	return
}

// GetPlatformFontsForNode invokes the CSS method. Requests information about platform fonts which we used to render child TextNodes in the given node.
func (d *CSS) GetPlatformFontsForNode(ctx context.Context, args *cdpcmd.CSSGetPlatformFontsForNodeArgs) (reply *cdpcmd.CSSGetPlatformFontsForNodeReply, err error) {
	reply = new(cdpcmd.CSSGetPlatformFontsForNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetPlatformFontsForNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetPlatformFontsForNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetPlatformFontsForNode", Err: err}
	}
	return
}

// GetStyleSheetText invokes the CSS method. Returns the current textual content and the URL for a stylesheet.
func (d *CSS) GetStyleSheetText(ctx context.Context, args *cdpcmd.CSSGetStyleSheetTextArgs) (reply *cdpcmd.CSSGetStyleSheetTextReply, err error) {
	reply = new(cdpcmd.CSSGetStyleSheetTextReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetStyleSheetText.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetStyleSheetText.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetStyleSheetText", Err: err}
	}
	return
}

// CollectClassNames invokes the CSS method. Returns all class names from specified stylesheet.
func (d *CSS) CollectClassNames(ctx context.Context, args *cdpcmd.CSSCollectClassNamesArgs) (reply *cdpcmd.CSSCollectClassNamesReply, err error) {
	reply = new(cdpcmd.CSSCollectClassNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSCollectClassNames.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSCollectClassNames.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "CollectClassNames", Err: err}
	}
	return
}

// SetStyleSheetText invokes the CSS method. Sets the new stylesheet text.
func (d *CSS) SetStyleSheetText(ctx context.Context, args *cdpcmd.CSSSetStyleSheetTextArgs) (reply *cdpcmd.CSSSetStyleSheetTextReply, err error) {
	reply = new(cdpcmd.CSSSetStyleSheetTextReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleSheetText.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleSheetText.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetStyleSheetText", Err: err}
	}
	return
}

// SetRuleSelector invokes the CSS method. Modifies the rule selector.
func (d *CSS) SetRuleSelector(ctx context.Context, args *cdpcmd.CSSSetRuleSelectorArgs) (reply *cdpcmd.CSSSetRuleSelectorReply, err error) {
	reply = new(cdpcmd.CSSSetRuleSelectorReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetRuleSelector.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetRuleSelector.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetRuleSelector", Err: err}
	}
	return
}

// SetKeyframeKey invokes the CSS method. Modifies the keyframe rule key text.
func (d *CSS) SetKeyframeKey(ctx context.Context, args *cdpcmd.CSSSetKeyframeKeyArgs) (reply *cdpcmd.CSSSetKeyframeKeyReply, err error) {
	reply = new(cdpcmd.CSSSetKeyframeKeyReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetKeyframeKey.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetKeyframeKey.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetKeyframeKey", Err: err}
	}
	return
}

// SetStyleTexts invokes the CSS method. Applies specified style edits one after another in the given order.
func (d *CSS) SetStyleTexts(ctx context.Context, args *cdpcmd.CSSSetStyleTextsArgs) (reply *cdpcmd.CSSSetStyleTextsReply, err error) {
	reply = new(cdpcmd.CSSSetStyleTextsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleTexts.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetStyleTexts.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetStyleTexts", Err: err}
	}
	return
}

// SetMediaText invokes the CSS method. Modifies the rule selector.
func (d *CSS) SetMediaText(ctx context.Context, args *cdpcmd.CSSSetMediaTextArgs) (reply *cdpcmd.CSSSetMediaTextReply, err error) {
	reply = new(cdpcmd.CSSSetMediaTextReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetMediaText.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetMediaText.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetMediaText", Err: err}
	}
	return
}

// CreateStyleSheet invokes the CSS method. Creates a new special "via-inspector" stylesheet in the frame with given frameId.
func (d *CSS) CreateStyleSheet(ctx context.Context, args *cdpcmd.CSSCreateStyleSheetArgs) (reply *cdpcmd.CSSCreateStyleSheetReply, err error) {
	reply = new(cdpcmd.CSSCreateStyleSheetReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSCreateStyleSheet.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSCreateStyleSheet.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "CreateStyleSheet", Err: err}
	}
	return
}

// AddRule invokes the CSS method. Inserts a new rule with the given ruleText in a stylesheet with given styleSheetId, at the position specified by location.
func (d *CSS) AddRule(ctx context.Context, args *cdpcmd.CSSAddRuleArgs) (reply *cdpcmd.CSSAddRuleReply, err error) {
	reply = new(cdpcmd.CSSAddRuleReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSAddRule.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSAddRule.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "AddRule", Err: err}
	}
	return
}

// ForcePseudoState invokes the CSS method. Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser.
func (d *CSS) ForcePseudoState(ctx context.Context, args *cdpcmd.CSSForcePseudoStateArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSForcePseudoState.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSForcePseudoState.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "ForcePseudoState", Err: err}
	}
	return
}

// GetMediaQueries invokes the CSS method. Returns all media queries parsed by the rendering engine.
func (d *CSS) GetMediaQueries(ctx context.Context) (reply *cdpcmd.CSSGetMediaQueriesReply, err error) {
	reply = new(cdpcmd.CSSGetMediaQueriesReply)
	err = rpcc.Invoke(ctx, cdpcmd.CSSGetMediaQueries.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetMediaQueries", Err: err}
	}
	return
}

// SetEffectivePropertyValueForNode invokes the CSS method. Find a rule with the given active property for the given node and set the new value for this property
func (d *CSS) SetEffectivePropertyValueForNode(ctx context.Context, args *cdpcmd.CSSSetEffectivePropertyValueForNodeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetEffectivePropertyValueForNode.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSSetEffectivePropertyValueForNode.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "SetEffectivePropertyValueForNode", Err: err}
	}
	return
}

// GetBackgroundColors invokes the CSS method.
func (d *CSS) GetBackgroundColors(ctx context.Context, args *cdpcmd.CSSGetBackgroundColorsArgs) (reply *cdpcmd.CSSGetBackgroundColorsReply, err error) {
	reply = new(cdpcmd.CSSGetBackgroundColorsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetBackgroundColors.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetBackgroundColors.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetBackgroundColors", Err: err}
	}
	return
}

// GetLayoutTreeAndStyles invokes the CSS method. For the main document and any content documents, return the LayoutTreeNodes and a whitelisted subset of the computed style. It only returns pushed nodes, on way to pull all nodes is to call DOM.getDocument with a depth of -1.
func (d *CSS) GetLayoutTreeAndStyles(ctx context.Context, args *cdpcmd.CSSGetLayoutTreeAndStylesArgs) (reply *cdpcmd.CSSGetLayoutTreeAndStylesReply, err error) {
	reply = new(cdpcmd.CSSGetLayoutTreeAndStylesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetLayoutTreeAndStyles.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CSSGetLayoutTreeAndStyles.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CSS", Op: "GetLayoutTreeAndStyles", Err: err}
	}
	return
}

// StartRuleUsageTracking invokes the CSS method. Enables the selector recording.
func (d *CSS) StartRuleUsageTracking(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.CSSStartRuleUsageTracking.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "StartRuleUsageTracking", Err: err}
	}
	return
}

// TakeCoverageDelta invokes the CSS method. Obtain list of rules that became used since last call to this method (or since start of coverage instrumentation)
func (d *CSS) TakeCoverageDelta(ctx context.Context) (reply *cdpcmd.CSSTakeCoverageDeltaReply, err error) {
	reply = new(cdpcmd.CSSTakeCoverageDeltaReply)
	err = rpcc.Invoke(ctx, cdpcmd.CSSTakeCoverageDelta.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "TakeCoverageDelta", Err: err}
	}
	return
}

// StopRuleUsageTracking invokes the CSS method. The list of rules with an indication of whether these were used
func (d *CSS) StopRuleUsageTracking(ctx context.Context) (reply *cdpcmd.CSSStopRuleUsageTrackingReply, err error) {
	reply = new(cdpcmd.CSSStopRuleUsageTrackingReply)
	err = rpcc.Invoke(ctx, cdpcmd.CSSStopRuleUsageTracking.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "CSS", Op: "StopRuleUsageTracking", Err: err}
	}
	return
}

// MediaQueryResultChanged creates the event client. Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features.
func (d *CSS) MediaQueryResultChanged(ctx context.Context) (cdpevent.CSSMediaQueryResultChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSMediaQueryResultChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &CSSMediaQueryResultChangedClient{Stream: s}, nil
}

// CSSMediaQueryResultChangedClient implements cdpevent.CSSMediaQueryResultChangedClient.
type CSSMediaQueryResultChangedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *CSSMediaQueryResultChangedClient) Recv() (*cdpevent.CSSMediaQueryResultChangedReply, error) {
	event := new(cdpevent.CSSMediaQueryResultChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "CSS", Op: "MediaQueryResultChanged Recv", Err: err}
	}
	return event, nil
}

// FontsUpdated creates the event client. Fires whenever a web font gets loaded.
func (d *CSS) FontsUpdated(ctx context.Context) (cdpevent.CSSFontsUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSFontsUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &CSSFontsUpdatedClient{Stream: s}, nil
}

// CSSFontsUpdatedClient implements cdpevent.CSSFontsUpdatedClient.
type CSSFontsUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *CSSFontsUpdatedClient) Recv() (*cdpevent.CSSFontsUpdatedReply, error) {
	event := new(cdpevent.CSSFontsUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "CSS", Op: "FontsUpdated Recv", Err: err}
	}
	return event, nil
}

// StyleSheetChanged creates the event client. Fired whenever a stylesheet is changed as a result of the client operation.
func (d *CSS) StyleSheetChanged(ctx context.Context) (cdpevent.CSSStyleSheetChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &CSSStyleSheetChangedClient{Stream: s}, nil
}

// CSSStyleSheetChangedClient implements cdpevent.CSSStyleSheetChangedClient.
type CSSStyleSheetChangedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *CSSStyleSheetChangedClient) Recv() (*cdpevent.CSSStyleSheetChangedReply, error) {
	event := new(cdpevent.CSSStyleSheetChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "CSS", Op: "StyleSheetChanged Recv", Err: err}
	}
	return event, nil
}

// StyleSheetAdded creates the event client. Fired whenever an active document stylesheet is added.
func (d *CSS) StyleSheetAdded(ctx context.Context) (cdpevent.CSSStyleSheetAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &CSSStyleSheetAddedClient{Stream: s}, nil
}

// CSSStyleSheetAddedClient implements cdpevent.CSSStyleSheetAddedClient.
type CSSStyleSheetAddedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *CSSStyleSheetAddedClient) Recv() (*cdpevent.CSSStyleSheetAddedReply, error) {
	event := new(cdpevent.CSSStyleSheetAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "CSS", Op: "StyleSheetAdded Recv", Err: err}
	}
	return event, nil
}

// StyleSheetRemoved creates the event client. Fired whenever an active document stylesheet is removed.
func (d *CSS) StyleSheetRemoved(ctx context.Context) (cdpevent.CSSStyleSheetRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.CSSStyleSheetRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &CSSStyleSheetRemovedClient{Stream: s}, nil
}

// CSSStyleSheetRemovedClient implements cdpevent.CSSStyleSheetRemovedClient.
type CSSStyleSheetRemovedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *CSSStyleSheetRemovedClient) Recv() (*cdpevent.CSSStyleSheetRemovedReply, error) {
	event := new(cdpevent.CSSStyleSheetRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "CSS", Op: "StyleSheetRemoved Recv", Err: err}
	}
	return event, nil
}

// The CacheStorage domain.
type CacheStorage struct{ conn *rpcc.Conn }

// NewCacheStorage returns the domain with the connection set to conn.
func NewCacheStorage(conn *rpcc.Conn) *CacheStorage {
	return &CacheStorage{conn: conn}
}

// RequestCacheNames invokes the CacheStorage method. Requests cache names.
func (d *CacheStorage) RequestCacheNames(ctx context.Context, args *cdpcmd.CacheStorageRequestCacheNamesArgs) (reply *cdpcmd.CacheStorageRequestCacheNamesReply, err error) {
	reply = new(cdpcmd.CacheStorageRequestCacheNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestCacheNames.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestCacheNames.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CacheStorage", Op: "RequestCacheNames", Err: err}
	}
	return
}

// RequestEntries invokes the CacheStorage method. Requests data from cache.
func (d *CacheStorage) RequestEntries(ctx context.Context, args *cdpcmd.CacheStorageRequestEntriesArgs) (reply *cdpcmd.CacheStorageRequestEntriesReply, err error) {
	reply = new(cdpcmd.CacheStorageRequestEntriesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestEntries.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageRequestEntries.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CacheStorage", Op: "RequestEntries", Err: err}
	}
	return
}

// DeleteCache invokes the CacheStorage method. Deletes a cache.
func (d *CacheStorage) DeleteCache(ctx context.Context, args *cdpcmd.CacheStorageDeleteCacheArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteCache.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteCache.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CacheStorage", Op: "DeleteCache", Err: err}
	}
	return
}

// DeleteEntry invokes the CacheStorage method. Deletes a cache entry.
func (d *CacheStorage) DeleteEntry(ctx context.Context, args *cdpcmd.CacheStorageDeleteEntryArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteEntry.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.CacheStorageDeleteEntry.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "CacheStorage", Op: "DeleteEntry", Err: err}
	}
	return
}

// The Console domain. This domain is deprecated - use Runtime or Log instead.
type Console struct{ conn *rpcc.Conn }

// NewConsole returns the domain with the connection set to conn.
func NewConsole(conn *rpcc.Conn) *Console {
	return &Console{conn: conn}
}

// Enable invokes the Console method. Enables console domain, sends the messages collected so far to the client by means of the messageAdded notification.
func (d *Console) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ConsoleEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Console", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Console method. Disables console domain, prevents further console messages from being reported to the client.
func (d *Console) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ConsoleDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Console", Op: "Disable", Err: err}
	}
	return
}

// ClearMessages invokes the Console method. Does nothing.
func (d *Console) ClearMessages(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ConsoleClearMessages.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Console", Op: "ClearMessages", Err: err}
	}
	return
}

// MessageAdded creates the event client. Issued when new console message is added.
func (d *Console) MessageAdded(ctx context.Context) (cdpevent.ConsoleMessageAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ConsoleMessageAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ConsoleMessageAddedClient{Stream: s}, nil
}

// ConsoleMessageAddedClient implements cdpevent.ConsoleMessageAddedClient.
type ConsoleMessageAddedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ConsoleMessageAddedClient) Recv() (*cdpevent.ConsoleMessageAddedReply, error) {
	event := new(cdpevent.ConsoleMessageAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Console", Op: "MessageAdded Recv", Err: err}
	}
	return event, nil
}

// The DOM domain. This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an id. This id can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client's responsibility to collect information about the nodes that were sent to the client.
//
// Note that iframe owner elements will return corresponding document elements as their child nodes.
type DOM struct{ conn *rpcc.Conn }

// NewDOM returns the domain with the connection set to conn.
func NewDOM(conn *rpcc.Conn) *DOM {
	return &DOM{conn: conn}
}

// Enable invokes the DOM method. Enables DOM agent for the given page.
func (d *DOM) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the DOM method. Disables DOM agent for the given page.
func (d *DOM) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "Disable", Err: err}
	}
	return
}

// GetDocument invokes the DOM method. Returns the root DOM node (and optionally the subtree) to the caller.
func (d *DOM) GetDocument(ctx context.Context, args *cdpcmd.DOMGetDocumentArgs) (reply *cdpcmd.DOMGetDocumentReply, err error) {
	reply = new(cdpcmd.DOMGetDocumentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetDocument.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetDocument.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetDocument", Err: err}
	}
	return
}

// GetFlattenedDocument invokes the DOM method. Returns the root DOM node (and optionally the subtree) to the caller.
func (d *DOM) GetFlattenedDocument(ctx context.Context, args *cdpcmd.DOMGetFlattenedDocumentArgs) (reply *cdpcmd.DOMGetFlattenedDocumentReply, err error) {
	reply = new(cdpcmd.DOMGetFlattenedDocumentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetFlattenedDocument.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetFlattenedDocument.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetFlattenedDocument", Err: err}
	}
	return
}

// CollectClassNamesFromSubtree invokes the DOM method. Collects class names for the node with given id and all of it's child nodes.
func (d *DOM) CollectClassNamesFromSubtree(ctx context.Context, args *cdpcmd.DOMCollectClassNamesFromSubtreeArgs) (reply *cdpcmd.DOMCollectClassNamesFromSubtreeReply, err error) {
	reply = new(cdpcmd.DOMCollectClassNamesFromSubtreeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMCollectClassNamesFromSubtree.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMCollectClassNamesFromSubtree.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "CollectClassNamesFromSubtree", Err: err}
	}
	return
}

// RequestChildNodes invokes the DOM method. Requests that children of the node with given id are returned to the caller in form of setChildNodes events where not only immediate children are retrieved, but all children down to the specified depth.
func (d *DOM) RequestChildNodes(ctx context.Context, args *cdpcmd.DOMRequestChildNodesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRequestChildNodes.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRequestChildNodes.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "RequestChildNodes", Err: err}
	}
	return
}

// QuerySelector invokes the DOM method. Executes querySelector on a given node.
func (d *DOM) QuerySelector(ctx context.Context, args *cdpcmd.DOMQuerySelectorArgs) (reply *cdpcmd.DOMQuerySelectorReply, err error) {
	reply = new(cdpcmd.DOMQuerySelectorReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelector.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelector.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "QuerySelector", Err: err}
	}
	return
}

// QuerySelectorAll invokes the DOM method. Executes querySelectorAll on a given node.
func (d *DOM) QuerySelectorAll(ctx context.Context, args *cdpcmd.DOMQuerySelectorAllArgs) (reply *cdpcmd.DOMQuerySelectorAllReply, err error) {
	reply = new(cdpcmd.DOMQuerySelectorAllReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelectorAll.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMQuerySelectorAll.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "QuerySelectorAll", Err: err}
	}
	return
}

// SetNodeName invokes the DOM method. Sets node name for a node with given id.
func (d *DOM) SetNodeName(ctx context.Context, args *cdpcmd.DOMSetNodeNameArgs) (reply *cdpcmd.DOMSetNodeNameReply, err error) {
	reply = new(cdpcmd.DOMSetNodeNameReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeName.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeName.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetNodeName", Err: err}
	}
	return
}

// SetNodeValue invokes the DOM method. Sets node value for a node with given id.
func (d *DOM) SetNodeValue(ctx context.Context, args *cdpcmd.DOMSetNodeValueArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeValue.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetNodeValue.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetNodeValue", Err: err}
	}
	return
}

// RemoveNode invokes the DOM method. Removes node with given id.
func (d *DOM) RemoveNode(ctx context.Context, args *cdpcmd.DOMRemoveNodeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveNode.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveNode.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "RemoveNode", Err: err}
	}
	return
}

// SetAttributeValue invokes the DOM method. Sets attribute for an element with given id.
func (d *DOM) SetAttributeValue(ctx context.Context, args *cdpcmd.DOMSetAttributeValueArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributeValue.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributeValue.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetAttributeValue", Err: err}
	}
	return
}

// SetAttributesAsText invokes the DOM method. Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs.
func (d *DOM) SetAttributesAsText(ctx context.Context, args *cdpcmd.DOMSetAttributesAsTextArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributesAsText.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetAttributesAsText.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetAttributesAsText", Err: err}
	}
	return
}

// RemoveAttribute invokes the DOM method. Removes attribute with given name from an element with given id.
func (d *DOM) RemoveAttribute(ctx context.Context, args *cdpcmd.DOMRemoveAttributeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveAttribute.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRemoveAttribute.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "RemoveAttribute", Err: err}
	}
	return
}

// GetOuterHTML invokes the DOM method. Returns node's HTML markup.
func (d *DOM) GetOuterHTML(ctx context.Context, args *cdpcmd.DOMGetOuterHTMLArgs) (reply *cdpcmd.DOMGetOuterHTMLReply, err error) {
	reply = new(cdpcmd.DOMGetOuterHTMLReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetOuterHTML.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetOuterHTML.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetOuterHTML", Err: err}
	}
	return
}

// SetOuterHTML invokes the DOM method. Sets node HTML markup, returns new node id.
func (d *DOM) SetOuterHTML(ctx context.Context, args *cdpcmd.DOMSetOuterHTMLArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetOuterHTML.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetOuterHTML.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetOuterHTML", Err: err}
	}
	return
}

// PerformSearch invokes the DOM method. Searches for a given string in the DOM tree. Use getSearchResults to access search results or cancelSearch to end this search session.
func (d *DOM) PerformSearch(ctx context.Context, args *cdpcmd.DOMPerformSearchArgs) (reply *cdpcmd.DOMPerformSearchReply, err error) {
	reply = new(cdpcmd.DOMPerformSearchReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPerformSearch.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPerformSearch.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "PerformSearch", Err: err}
	}
	return
}

// GetSearchResults invokes the DOM method. Returns search results from given fromIndex to given toIndex from the sarch with the given identifier.
func (d *DOM) GetSearchResults(ctx context.Context, args *cdpcmd.DOMGetSearchResultsArgs) (reply *cdpcmd.DOMGetSearchResultsReply, err error) {
	reply = new(cdpcmd.DOMGetSearchResultsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetSearchResults.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetSearchResults.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetSearchResults", Err: err}
	}
	return
}

// DiscardSearchResults invokes the DOM method. Discards search results from the session with the given id. getSearchResults should no longer be called for that search.
func (d *DOM) DiscardSearchResults(ctx context.Context, args *cdpcmd.DOMDiscardSearchResultsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDiscardSearchResults.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDiscardSearchResults.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "DiscardSearchResults", Err: err}
	}
	return
}

// RequestNode invokes the DOM method. Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of setChildNodes notifications.
func (d *DOM) RequestNode(ctx context.Context, args *cdpcmd.DOMRequestNodeArgs) (reply *cdpcmd.DOMRequestNodeReply, err error) {
	reply = new(cdpcmd.DOMRequestNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRequestNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMRequestNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "RequestNode", Err: err}
	}
	return
}

// HighlightRect invokes the DOM method. Highlights given rectangle.
func (d *DOM) HighlightRect(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightRect.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "HighlightRect", Err: err}
	}
	return
}

// HighlightNode invokes the DOM method. Highlights DOM node.
func (d *DOM) HighlightNode(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMHighlightNode.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "HighlightNode", Err: err}
	}
	return
}

// HideHighlight invokes the DOM method. Hides any highlight.
func (d *DOM) HideHighlight(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMHideHighlight.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "HideHighlight", Err: err}
	}
	return
}

// PushNodeByPathToFrontend invokes the DOM method. Requests that the node is sent to the caller given its path. // FIXME, use XPath
func (d *DOM) PushNodeByPathToFrontend(ctx context.Context, args *cdpcmd.DOMPushNodeByPathToFrontendArgs) (reply *cdpcmd.DOMPushNodeByPathToFrontendReply, err error) {
	reply = new(cdpcmd.DOMPushNodeByPathToFrontendReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodeByPathToFrontend.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodeByPathToFrontend.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "PushNodeByPathToFrontend", Err: err}
	}
	return
}

// PushNodesByBackendIdsToFrontend invokes the DOM method. Requests that a batch of nodes is sent to the caller given their backend node ids.
func (d *DOM) PushNodesByBackendIdsToFrontend(ctx context.Context, args *cdpcmd.DOMPushNodesByBackendIdsToFrontendArgs) (reply *cdpcmd.DOMPushNodesByBackendIdsToFrontendReply, err error) {
	reply = new(cdpcmd.DOMPushNodesByBackendIdsToFrontendReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodesByBackendIdsToFrontend.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMPushNodesByBackendIdsToFrontend.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "PushNodesByBackendIdsToFrontend", Err: err}
	}
	return
}

// SetInspectedNode invokes the DOM method. Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
func (d *DOM) SetInspectedNode(ctx context.Context, args *cdpcmd.DOMSetInspectedNodeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetInspectedNode.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetInspectedNode.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetInspectedNode", Err: err}
	}
	return
}

// ResolveNode invokes the DOM method. Resolves JavaScript node object for given node id.
func (d *DOM) ResolveNode(ctx context.Context, args *cdpcmd.DOMResolveNodeArgs) (reply *cdpcmd.DOMResolveNodeReply, err error) {
	reply = new(cdpcmd.DOMResolveNodeReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMResolveNode.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMResolveNode.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "ResolveNode", Err: err}
	}
	return
}

// GetAttributes invokes the DOM method. Returns attributes for the specified node.
func (d *DOM) GetAttributes(ctx context.Context, args *cdpcmd.DOMGetAttributesArgs) (reply *cdpcmd.DOMGetAttributesReply, err error) {
	reply = new(cdpcmd.DOMGetAttributesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetAttributes.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetAttributes.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetAttributes", Err: err}
	}
	return
}

// CopyTo invokes the DOM method. Creates a deep copy of the specified node and places it into the target container before the given anchor.
func (d *DOM) CopyTo(ctx context.Context, args *cdpcmd.DOMCopyToArgs) (reply *cdpcmd.DOMCopyToReply, err error) {
	reply = new(cdpcmd.DOMCopyToReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMCopyTo.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMCopyTo.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "CopyTo", Err: err}
	}
	return
}

// MoveTo invokes the DOM method. Moves node into the new container, places it before the given anchor.
func (d *DOM) MoveTo(ctx context.Context, args *cdpcmd.DOMMoveToArgs) (reply *cdpcmd.DOMMoveToReply, err error) {
	reply = new(cdpcmd.DOMMoveToReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMMoveTo.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMMoveTo.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "MoveTo", Err: err}
	}
	return
}

// Undo invokes the DOM method. Undoes the last performed action.
func (d *DOM) Undo(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMUndo.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "Undo", Err: err}
	}
	return
}

// Redo invokes the DOM method. Re-does the last undone action.
func (d *DOM) Redo(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMRedo.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "Redo", Err: err}
	}
	return
}

// MarkUndoableState invokes the DOM method. Marks last undoable state.
func (d *DOM) MarkUndoableState(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMMarkUndoableState.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOM", Op: "MarkUndoableState", Err: err}
	}
	return
}

// Focus invokes the DOM method. Focuses the given element.
func (d *DOM) Focus(ctx context.Context, args *cdpcmd.DOMFocusArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMFocus.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMFocus.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "Focus", Err: err}
	}
	return
}

// SetFileInputFiles invokes the DOM method. Sets files for the given file input element.
func (d *DOM) SetFileInputFiles(ctx context.Context, args *cdpcmd.DOMSetFileInputFilesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetFileInputFiles.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMSetFileInputFiles.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "SetFileInputFiles", Err: err}
	}
	return
}

// GetBoxModel invokes the DOM method. Returns boxes for the currently selected nodes.
func (d *DOM) GetBoxModel(ctx context.Context, args *cdpcmd.DOMGetBoxModelArgs) (reply *cdpcmd.DOMGetBoxModelReply, err error) {
	reply = new(cdpcmd.DOMGetBoxModelReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetBoxModel.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetBoxModel.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetBoxModel", Err: err}
	}
	return
}

// GetNodeForLocation invokes the DOM method. Returns node id at given location.
func (d *DOM) GetNodeForLocation(ctx context.Context, args *cdpcmd.DOMGetNodeForLocationArgs) (reply *cdpcmd.DOMGetNodeForLocationReply, err error) {
	reply = new(cdpcmd.DOMGetNodeForLocationReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetNodeForLocation.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetNodeForLocation.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetNodeForLocation", Err: err}
	}
	return
}

// GetRelayoutBoundary invokes the DOM method. Returns the id of the nearest ancestor that is a relayout boundary.
func (d *DOM) GetRelayoutBoundary(ctx context.Context, args *cdpcmd.DOMGetRelayoutBoundaryArgs) (reply *cdpcmd.DOMGetRelayoutBoundaryReply, err error) {
	reply = new(cdpcmd.DOMGetRelayoutBoundaryReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetRelayoutBoundary.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMGetRelayoutBoundary.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOM", Op: "GetRelayoutBoundary", Err: err}
	}
	return
}

// DocumentUpdated creates the event client. Fired when Document has been totally updated. Node ids are no longer valid.
func (d *DOM) DocumentUpdated(ctx context.Context) (cdpevent.DOMDocumentUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMDocumentUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMDocumentUpdatedClient{Stream: s}, nil
}

// DOMDocumentUpdatedClient implements cdpevent.DOMDocumentUpdatedClient.
type DOMDocumentUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMDocumentUpdatedClient) Recv() (*cdpevent.DOMDocumentUpdatedReply, error) {
	event := new(cdpevent.DOMDocumentUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "DocumentUpdated Recv", Err: err}
	}
	return event, nil
}

// SetChildNodes creates the event client. Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids.
func (d *DOM) SetChildNodes(ctx context.Context) (cdpevent.DOMSetChildNodesClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMSetChildNodes.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMSetChildNodesClient{Stream: s}, nil
}

// DOMSetChildNodesClient implements cdpevent.DOMSetChildNodesClient.
type DOMSetChildNodesClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMSetChildNodesClient) Recv() (*cdpevent.DOMSetChildNodesReply, error) {
	event := new(cdpevent.DOMSetChildNodesReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "SetChildNodes Recv", Err: err}
	}
	return event, nil
}

// AttributeModified creates the event client. Fired when Element's attribute is modified.
func (d *DOM) AttributeModified(ctx context.Context) (cdpevent.DOMAttributeModifiedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMAttributeModified.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMAttributeModifiedClient{Stream: s}, nil
}

// DOMAttributeModifiedClient implements cdpevent.DOMAttributeModifiedClient.
type DOMAttributeModifiedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMAttributeModifiedClient) Recv() (*cdpevent.DOMAttributeModifiedReply, error) {
	event := new(cdpevent.DOMAttributeModifiedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "AttributeModified Recv", Err: err}
	}
	return event, nil
}

// AttributeRemoved creates the event client. Fired when Element's attribute is removed.
func (d *DOM) AttributeRemoved(ctx context.Context) (cdpevent.DOMAttributeRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMAttributeRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMAttributeRemovedClient{Stream: s}, nil
}

// DOMAttributeRemovedClient implements cdpevent.DOMAttributeRemovedClient.
type DOMAttributeRemovedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMAttributeRemovedClient) Recv() (*cdpevent.DOMAttributeRemovedReply, error) {
	event := new(cdpevent.DOMAttributeRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "AttributeRemoved Recv", Err: err}
	}
	return event, nil
}

// InlineStyleInvalidated creates the event client. Fired when Element's inline style is modified via a CSS property modification.
func (d *DOM) InlineStyleInvalidated(ctx context.Context) (cdpevent.DOMInlineStyleInvalidatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMInlineStyleInvalidated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMInlineStyleInvalidatedClient{Stream: s}, nil
}

// DOMInlineStyleInvalidatedClient implements cdpevent.DOMInlineStyleInvalidatedClient.
type DOMInlineStyleInvalidatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMInlineStyleInvalidatedClient) Recv() (*cdpevent.DOMInlineStyleInvalidatedReply, error) {
	event := new(cdpevent.DOMInlineStyleInvalidatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "InlineStyleInvalidated Recv", Err: err}
	}
	return event, nil
}

// CharacterDataModified creates the event client. Mirrors DOMCharacterDataModified event.
func (d *DOM) CharacterDataModified(ctx context.Context) (cdpevent.DOMCharacterDataModifiedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMCharacterDataModified.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMCharacterDataModifiedClient{Stream: s}, nil
}

// DOMCharacterDataModifiedClient implements cdpevent.DOMCharacterDataModifiedClient.
type DOMCharacterDataModifiedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMCharacterDataModifiedClient) Recv() (*cdpevent.DOMCharacterDataModifiedReply, error) {
	event := new(cdpevent.DOMCharacterDataModifiedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "CharacterDataModified Recv", Err: err}
	}
	return event, nil
}

// ChildNodeCountUpdated creates the event client. Fired when Container's child node count has changed.
func (d *DOM) ChildNodeCountUpdated(ctx context.Context) (cdpevent.DOMChildNodeCountUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeCountUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMChildNodeCountUpdatedClient{Stream: s}, nil
}

// DOMChildNodeCountUpdatedClient implements cdpevent.DOMChildNodeCountUpdatedClient.
type DOMChildNodeCountUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMChildNodeCountUpdatedClient) Recv() (*cdpevent.DOMChildNodeCountUpdatedReply, error) {
	event := new(cdpevent.DOMChildNodeCountUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "ChildNodeCountUpdated Recv", Err: err}
	}
	return event, nil
}

// ChildNodeInserted creates the event client. Mirrors DOMNodeInserted event.
func (d *DOM) ChildNodeInserted(ctx context.Context) (cdpevent.DOMChildNodeInsertedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeInserted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMChildNodeInsertedClient{Stream: s}, nil
}

// DOMChildNodeInsertedClient implements cdpevent.DOMChildNodeInsertedClient.
type DOMChildNodeInsertedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMChildNodeInsertedClient) Recv() (*cdpevent.DOMChildNodeInsertedReply, error) {
	event := new(cdpevent.DOMChildNodeInsertedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "ChildNodeInserted Recv", Err: err}
	}
	return event, nil
}

// ChildNodeRemoved creates the event client. Mirrors DOMNodeRemoved event.
func (d *DOM) ChildNodeRemoved(ctx context.Context) (cdpevent.DOMChildNodeRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMChildNodeRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMChildNodeRemovedClient{Stream: s}, nil
}

// DOMChildNodeRemovedClient implements cdpevent.DOMChildNodeRemovedClient.
type DOMChildNodeRemovedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMChildNodeRemovedClient) Recv() (*cdpevent.DOMChildNodeRemovedReply, error) {
	event := new(cdpevent.DOMChildNodeRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "ChildNodeRemoved Recv", Err: err}
	}
	return event, nil
}

// ShadowRootPushed creates the event client. Called when shadow root is pushed into the element.
func (d *DOM) ShadowRootPushed(ctx context.Context) (cdpevent.DOMShadowRootPushedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMShadowRootPushed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMShadowRootPushedClient{Stream: s}, nil
}

// DOMShadowRootPushedClient implements cdpevent.DOMShadowRootPushedClient.
type DOMShadowRootPushedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMShadowRootPushedClient) Recv() (*cdpevent.DOMShadowRootPushedReply, error) {
	event := new(cdpevent.DOMShadowRootPushedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "ShadowRootPushed Recv", Err: err}
	}
	return event, nil
}

// ShadowRootPopped creates the event client. Called when shadow root is popped from the element.
func (d *DOM) ShadowRootPopped(ctx context.Context) (cdpevent.DOMShadowRootPoppedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMShadowRootPopped.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMShadowRootPoppedClient{Stream: s}, nil
}

// DOMShadowRootPoppedClient implements cdpevent.DOMShadowRootPoppedClient.
type DOMShadowRootPoppedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMShadowRootPoppedClient) Recv() (*cdpevent.DOMShadowRootPoppedReply, error) {
	event := new(cdpevent.DOMShadowRootPoppedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "ShadowRootPopped Recv", Err: err}
	}
	return event, nil
}

// PseudoElementAdded creates the event client. Called when a pseudo element is added to an element.
func (d *DOM) PseudoElementAdded(ctx context.Context) (cdpevent.DOMPseudoElementAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMPseudoElementAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMPseudoElementAddedClient{Stream: s}, nil
}

// DOMPseudoElementAddedClient implements cdpevent.DOMPseudoElementAddedClient.
type DOMPseudoElementAddedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMPseudoElementAddedClient) Recv() (*cdpevent.DOMPseudoElementAddedReply, error) {
	event := new(cdpevent.DOMPseudoElementAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "PseudoElementAdded Recv", Err: err}
	}
	return event, nil
}

// PseudoElementRemoved creates the event client. Called when a pseudo element is removed from an element.
func (d *DOM) PseudoElementRemoved(ctx context.Context) (cdpevent.DOMPseudoElementRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMPseudoElementRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMPseudoElementRemovedClient{Stream: s}, nil
}

// DOMPseudoElementRemovedClient implements cdpevent.DOMPseudoElementRemovedClient.
type DOMPseudoElementRemovedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMPseudoElementRemovedClient) Recv() (*cdpevent.DOMPseudoElementRemovedReply, error) {
	event := new(cdpevent.DOMPseudoElementRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "PseudoElementRemoved Recv", Err: err}
	}
	return event, nil
}

// DistributedNodesUpdated creates the event client. Called when distribution is changed.
func (d *DOM) DistributedNodesUpdated(ctx context.Context) (cdpevent.DOMDistributedNodesUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMDistributedNodesUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMDistributedNodesUpdatedClient{Stream: s}, nil
}

// DOMDistributedNodesUpdatedClient implements cdpevent.DOMDistributedNodesUpdatedClient.
type DOMDistributedNodesUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMDistributedNodesUpdatedClient) Recv() (*cdpevent.DOMDistributedNodesUpdatedReply, error) {
	event := new(cdpevent.DOMDistributedNodesUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOM", Op: "DistributedNodesUpdated Recv", Err: err}
	}
	return event, nil
}

// The DOMDebugger domain. DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.
type DOMDebugger struct{ conn *rpcc.Conn }

// NewDOMDebugger returns the domain with the connection set to conn.
func NewDOMDebugger(conn *rpcc.Conn) *DOMDebugger {
	return &DOMDebugger{conn: conn}
}

// SetDOMBreakpoint invokes the DOMDebugger method. Sets breakpoint on particular operation with DOM.
func (d *DOMDebugger) SetDOMBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetDOMBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetDOMBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetDOMBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "SetDOMBreakpoint", Err: err}
	}
	return
}

// RemoveDOMBreakpoint invokes the DOMDebugger method. Removes DOM breakpoint that was set using setDOMBreakpoint.
func (d *DOMDebugger) RemoveDOMBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveDOMBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveDOMBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveDOMBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "RemoveDOMBreakpoint", Err: err}
	}
	return
}

// SetEventListenerBreakpoint invokes the DOMDebugger method. Sets breakpoint on particular DOM event.
func (d *DOMDebugger) SetEventListenerBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetEventListenerBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetEventListenerBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetEventListenerBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "SetEventListenerBreakpoint", Err: err}
	}
	return
}

// RemoveEventListenerBreakpoint invokes the DOMDebugger method. Removes breakpoint on particular DOM event.
func (d *DOMDebugger) RemoveEventListenerBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveEventListenerBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveEventListenerBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveEventListenerBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "RemoveEventListenerBreakpoint", Err: err}
	}
	return
}

// SetInstrumentationBreakpoint invokes the DOMDebugger method. Sets breakpoint on particular native event.
func (d *DOMDebugger) SetInstrumentationBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetInstrumentationBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetInstrumentationBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetInstrumentationBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "SetInstrumentationBreakpoint", Err: err}
	}
	return
}

// RemoveInstrumentationBreakpoint invokes the DOMDebugger method. Removes breakpoint on particular native event.
func (d *DOMDebugger) RemoveInstrumentationBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveInstrumentationBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveInstrumentationBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveInstrumentationBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "RemoveInstrumentationBreakpoint", Err: err}
	}
	return
}

// SetXHRBreakpoint invokes the DOMDebugger method. Sets breakpoint on XMLHttpRequest.
func (d *DOMDebugger) SetXHRBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerSetXHRBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetXHRBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerSetXHRBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "SetXHRBreakpoint", Err: err}
	}
	return
}

// RemoveXHRBreakpoint invokes the DOMDebugger method. Removes breakpoint from XMLHttpRequest.
func (d *DOMDebugger) RemoveXHRBreakpoint(ctx context.Context, args *cdpcmd.DOMDebuggerRemoveXHRBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveXHRBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerRemoveXHRBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "RemoveXHRBreakpoint", Err: err}
	}
	return
}

// GetEventListeners invokes the DOMDebugger method. Returns event listeners of the given object.
func (d *DOMDebugger) GetEventListeners(ctx context.Context, args *cdpcmd.DOMDebuggerGetEventListenersArgs) (reply *cdpcmd.DOMDebuggerGetEventListenersReply, err error) {
	reply = new(cdpcmd.DOMDebuggerGetEventListenersReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerGetEventListeners.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMDebuggerGetEventListeners.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMDebugger", Op: "GetEventListeners", Err: err}
	}
	return
}

// The DOMStorage domain. Query and modify DOM storage.
type DOMStorage struct{ conn *rpcc.Conn }

// NewDOMStorage returns the domain with the connection set to conn.
func NewDOMStorage(conn *rpcc.Conn) *DOMStorage {
	return &DOMStorage{conn: conn}
}

// Enable invokes the DOMStorage method. Enables storage tracking, storage events will now be delivered to the client.
func (d *DOMStorage) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the DOMStorage method. Disables storage tracking, prevents storage events from being sent to the client.
func (d *DOMStorage) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DOMStorageDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "Disable", Err: err}
	}
	return
}

// Clear invokes the DOMStorage method.
func (d *DOMStorage) Clear(ctx context.Context, args *cdpcmd.DOMStorageClearArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageClear.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageClear.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "Clear", Err: err}
	}
	return
}

// GetDOMStorageItems invokes the DOMStorage method.
func (d *DOMStorage) GetDOMStorageItems(ctx context.Context, args *cdpcmd.DOMStorageGetDOMStorageItemsArgs) (reply *cdpcmd.DOMStorageGetDOMStorageItemsReply, err error) {
	reply = new(cdpcmd.DOMStorageGetDOMStorageItemsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageGetDOMStorageItems.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageGetDOMStorageItems.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "GetDOMStorageItems", Err: err}
	}
	return
}

// SetDOMStorageItem invokes the DOMStorage method.
func (d *DOMStorage) SetDOMStorageItem(ctx context.Context, args *cdpcmd.DOMStorageSetDOMStorageItemArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageSetDOMStorageItem.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageSetDOMStorageItem.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "SetDOMStorageItem", Err: err}
	}
	return
}

// RemoveDOMStorageItem invokes the DOMStorage method.
func (d *DOMStorage) RemoveDOMStorageItem(ctx context.Context, args *cdpcmd.DOMStorageRemoveDOMStorageItemArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageRemoveDOMStorageItem.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DOMStorageRemoveDOMStorageItem.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DOMStorage", Op: "RemoveDOMStorageItem", Err: err}
	}
	return
}

// DOMStorageItemsCleared creates the event client.
func (d *DOMStorage) DOMStorageItemsCleared(ctx context.Context) (cdpevent.DOMStorageItemsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemsCleared.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMStorageItemsClearedClient{Stream: s}, nil
}

// DOMStorageItemsClearedClient implements cdpevent.DOMStorageItemsClearedClient.
type DOMStorageItemsClearedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMStorageItemsClearedClient) Recv() (*cdpevent.DOMStorageItemsClearedReply, error) {
	event := new(cdpevent.DOMStorageItemsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOMStorage", Op: "DOMStorageItemsCleared Recv", Err: err}
	}
	return event, nil
}

// DOMStorageItemRemoved creates the event client.
func (d *DOMStorage) DOMStorageItemRemoved(ctx context.Context) (cdpevent.DOMStorageItemRemovedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemRemoved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMStorageItemRemovedClient{Stream: s}, nil
}

// DOMStorageItemRemovedClient implements cdpevent.DOMStorageItemRemovedClient.
type DOMStorageItemRemovedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMStorageItemRemovedClient) Recv() (*cdpevent.DOMStorageItemRemovedReply, error) {
	event := new(cdpevent.DOMStorageItemRemovedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOMStorage", Op: "DOMStorageItemRemoved Recv", Err: err}
	}
	return event, nil
}

// DOMStorageItemAdded creates the event client.
func (d *DOMStorage) DOMStorageItemAdded(ctx context.Context) (cdpevent.DOMStorageItemAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMStorageItemAddedClient{Stream: s}, nil
}

// DOMStorageItemAddedClient implements cdpevent.DOMStorageItemAddedClient.
type DOMStorageItemAddedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMStorageItemAddedClient) Recv() (*cdpevent.DOMStorageItemAddedReply, error) {
	event := new(cdpevent.DOMStorageItemAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOMStorage", Op: "DOMStorageItemAdded Recv", Err: err}
	}
	return event, nil
}

// DOMStorageItemUpdated creates the event client.
func (d *DOMStorage) DOMStorageItemUpdated(ctx context.Context) (cdpevent.DOMStorageItemUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DOMStorageItemUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DOMStorageItemUpdatedClient{Stream: s}, nil
}

// DOMStorageItemUpdatedClient implements cdpevent.DOMStorageItemUpdatedClient.
type DOMStorageItemUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DOMStorageItemUpdatedClient) Recv() (*cdpevent.DOMStorageItemUpdatedReply, error) {
	event := new(cdpevent.DOMStorageItemUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "DOMStorage", Op: "DOMStorageItemUpdated Recv", Err: err}
	}
	return event, nil
}

// The Database domain.
type Database struct{ conn *rpcc.Conn }

// NewDatabase returns the domain with the connection set to conn.
func NewDatabase(conn *rpcc.Conn) *Database {
	return &Database{conn: conn}
}

// Enable invokes the Database method. Enables database tracking, database events will now be delivered to the client.
func (d *Database) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DatabaseEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Database", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Database method. Disables database tracking, prevents database events from being sent to the client.
func (d *Database) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DatabaseDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Database", Op: "Disable", Err: err}
	}
	return
}

// GetDatabaseTableNames invokes the Database method.
func (d *Database) GetDatabaseTableNames(ctx context.Context, args *cdpcmd.DatabaseGetDatabaseTableNamesArgs) (reply *cdpcmd.DatabaseGetDatabaseTableNamesReply, err error) {
	reply = new(cdpcmd.DatabaseGetDatabaseTableNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DatabaseGetDatabaseTableNames.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DatabaseGetDatabaseTableNames.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Database", Op: "GetDatabaseTableNames", Err: err}
	}
	return
}

// ExecuteSQL invokes the Database method.
func (d *Database) ExecuteSQL(ctx context.Context, args *cdpcmd.DatabaseExecuteSQLArgs) (reply *cdpcmd.DatabaseExecuteSQLReply, err error) {
	reply = new(cdpcmd.DatabaseExecuteSQLReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DatabaseExecuteSQL.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DatabaseExecuteSQL.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Database", Op: "ExecuteSQL", Err: err}
	}
	return
}

// AddDatabase creates the event client.
func (d *Database) AddDatabase(ctx context.Context) (cdpevent.DatabaseAddDatabaseClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DatabaseAddDatabase.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DatabaseAddDatabaseClient{Stream: s}, nil
}

// DatabaseAddDatabaseClient implements cdpevent.DatabaseAddDatabaseClient.
type DatabaseAddDatabaseClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DatabaseAddDatabaseClient) Recv() (*cdpevent.DatabaseAddDatabaseReply, error) {
	event := new(cdpevent.DatabaseAddDatabaseReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Database", Op: "AddDatabase Recv", Err: err}
	}
	return event, nil
}

// The Debugger domain. Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.
type Debugger struct{ conn *rpcc.Conn }

// NewDebugger returns the domain with the connection set to conn.
func NewDebugger(conn *rpcc.Conn) *Debugger {
	return &Debugger{conn: conn}
}

// Enable invokes the Debugger method. Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
func (d *Debugger) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Debugger method. Disables debugger for given page.
func (d *Debugger) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "Disable", Err: err}
	}
	return
}

// SetBreakpointsActive invokes the Debugger method. Activates / deactivates all breakpoints on the page.
func (d *Debugger) SetBreakpointsActive(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointsActiveArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointsActive.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointsActive.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetBreakpointsActive", Err: err}
	}
	return
}

// SetSkipAllPauses invokes the Debugger method. Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
func (d *Debugger) SetSkipAllPauses(ctx context.Context, args *cdpcmd.DebuggerSetSkipAllPausesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetSkipAllPauses.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetSkipAllPauses.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetSkipAllPauses", Err: err}
	}
	return
}

// SetBreakpointByURL invokes the Debugger method. Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads.
func (d *Debugger) SetBreakpointByURL(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointByURLArgs) (reply *cdpcmd.DebuggerSetBreakpointByURLReply, err error) {
	reply = new(cdpcmd.DebuggerSetBreakpointByURLReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointByURL.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpointByURL.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetBreakpointByURL", Err: err}
	}
	return
}

// SetBreakpoint invokes the Debugger method. Sets JavaScript breakpoint at a given location.
func (d *Debugger) SetBreakpoint(ctx context.Context, args *cdpcmd.DebuggerSetBreakpointArgs) (reply *cdpcmd.DebuggerSetBreakpointReply, err error) {
	reply = new(cdpcmd.DebuggerSetBreakpointReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpoint.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBreakpoint.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetBreakpoint", Err: err}
	}
	return
}

// RemoveBreakpoint invokes the Debugger method. Removes JavaScript breakpoint.
func (d *Debugger) RemoveBreakpoint(ctx context.Context, args *cdpcmd.DebuggerRemoveBreakpointArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerRemoveBreakpoint.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerRemoveBreakpoint.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "RemoveBreakpoint", Err: err}
	}
	return
}

// GetPossibleBreakpoints invokes the Debugger method. Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
func (d *Debugger) GetPossibleBreakpoints(ctx context.Context, args *cdpcmd.DebuggerGetPossibleBreakpointsArgs) (reply *cdpcmd.DebuggerGetPossibleBreakpointsReply, err error) {
	reply = new(cdpcmd.DebuggerGetPossibleBreakpointsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetPossibleBreakpoints.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetPossibleBreakpoints.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "GetPossibleBreakpoints", Err: err}
	}
	return
}

// ContinueToLocation invokes the Debugger method. Continues execution until specific location is reached.
func (d *Debugger) ContinueToLocation(ctx context.Context, args *cdpcmd.DebuggerContinueToLocationArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerContinueToLocation.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerContinueToLocation.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "ContinueToLocation", Err: err}
	}
	return
}

// StepOver invokes the Debugger method. Steps over the statement.
func (d *Debugger) StepOver(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepOver.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "StepOver", Err: err}
	}
	return
}

// StepInto invokes the Debugger method. Steps into the function call.
func (d *Debugger) StepInto(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepInto.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "StepInto", Err: err}
	}
	return
}

// StepOut invokes the Debugger method. Steps out of the function call.
func (d *Debugger) StepOut(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerStepOut.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "StepOut", Err: err}
	}
	return
}

// Pause invokes the Debugger method. Stops on the next JavaScript statement.
func (d *Debugger) Pause(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerPause.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "Pause", Err: err}
	}
	return
}

// ScheduleStepIntoAsync invokes the Debugger method. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
func (d *Debugger) ScheduleStepIntoAsync(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerScheduleStepIntoAsync.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "ScheduleStepIntoAsync", Err: err}
	}
	return
}

// Resume invokes the Debugger method. Resumes JavaScript execution.
func (d *Debugger) Resume(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DebuggerResume.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "Resume", Err: err}
	}
	return
}

// SearchInContent invokes the Debugger method. Searches for given string in script content.
func (d *Debugger) SearchInContent(ctx context.Context, args *cdpcmd.DebuggerSearchInContentArgs) (reply *cdpcmd.DebuggerSearchInContentReply, err error) {
	reply = new(cdpcmd.DebuggerSearchInContentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSearchInContent.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSearchInContent.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SearchInContent", Err: err}
	}
	return
}

// SetScriptSource invokes the Debugger method. Edits JavaScript source live.
func (d *Debugger) SetScriptSource(ctx context.Context, args *cdpcmd.DebuggerSetScriptSourceArgs) (reply *cdpcmd.DebuggerSetScriptSourceReply, err error) {
	reply = new(cdpcmd.DebuggerSetScriptSourceReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetScriptSource.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetScriptSource.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetScriptSource", Err: err}
	}
	return
}

// RestartFrame invokes the Debugger method. Restarts particular call frame from the beginning.
func (d *Debugger) RestartFrame(ctx context.Context, args *cdpcmd.DebuggerRestartFrameArgs) (reply *cdpcmd.DebuggerRestartFrameReply, err error) {
	reply = new(cdpcmd.DebuggerRestartFrameReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerRestartFrame.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerRestartFrame.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "RestartFrame", Err: err}
	}
	return
}

// GetScriptSource invokes the Debugger method. Returns source for the script with given id.
func (d *Debugger) GetScriptSource(ctx context.Context, args *cdpcmd.DebuggerGetScriptSourceArgs) (reply *cdpcmd.DebuggerGetScriptSourceReply, err error) {
	reply = new(cdpcmd.DebuggerGetScriptSourceReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetScriptSource.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerGetScriptSource.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "GetScriptSource", Err: err}
	}
	return
}

// SetPauseOnExceptions invokes the Debugger method. Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is none.
func (d *Debugger) SetPauseOnExceptions(ctx context.Context, args *cdpcmd.DebuggerSetPauseOnExceptionsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetPauseOnExceptions.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetPauseOnExceptions.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetPauseOnExceptions", Err: err}
	}
	return
}

// EvaluateOnCallFrame invokes the Debugger method. Evaluates expression on a given call frame.
func (d *Debugger) EvaluateOnCallFrame(ctx context.Context, args *cdpcmd.DebuggerEvaluateOnCallFrameArgs) (reply *cdpcmd.DebuggerEvaluateOnCallFrameReply, err error) {
	reply = new(cdpcmd.DebuggerEvaluateOnCallFrameReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerEvaluateOnCallFrame.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerEvaluateOnCallFrame.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "EvaluateOnCallFrame", Err: err}
	}
	return
}

// SetVariableValue invokes the Debugger method. Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
func (d *Debugger) SetVariableValue(ctx context.Context, args *cdpcmd.DebuggerSetVariableValueArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetVariableValue.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetVariableValue.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetVariableValue", Err: err}
	}
	return
}

// SetAsyncCallStackDepth invokes the Debugger method. Enables or disables async call stacks tracking.
func (d *Debugger) SetAsyncCallStackDepth(ctx context.Context, args *cdpcmd.DebuggerSetAsyncCallStackDepthArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetAsyncCallStackDepth.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetAsyncCallStackDepth.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetAsyncCallStackDepth", Err: err}
	}
	return
}

// SetBlackboxPatterns invokes the Debugger method. Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
func (d *Debugger) SetBlackboxPatterns(ctx context.Context, args *cdpcmd.DebuggerSetBlackboxPatternsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxPatterns.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxPatterns.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetBlackboxPatterns", Err: err}
	}
	return
}

// SetBlackboxedRanges invokes the Debugger method. Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
func (d *Debugger) SetBlackboxedRanges(ctx context.Context, args *cdpcmd.DebuggerSetBlackboxedRangesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxedRanges.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DebuggerSetBlackboxedRanges.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Debugger", Op: "SetBlackboxedRanges", Err: err}
	}
	return
}

// ScriptParsed creates the event client. Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
func (d *Debugger) ScriptParsed(ctx context.Context) (cdpevent.DebuggerScriptParsedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerScriptParsed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DebuggerScriptParsedClient{Stream: s}, nil
}

// DebuggerScriptParsedClient implements cdpevent.DebuggerScriptParsedClient.
type DebuggerScriptParsedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DebuggerScriptParsedClient) Recv() (*cdpevent.DebuggerScriptParsedReply, error) {
	event := new(cdpevent.DebuggerScriptParsedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Debugger", Op: "ScriptParsed Recv", Err: err}
	}
	return event, nil
}

// ScriptFailedToParse creates the event client. Fired when virtual machine fails to parse the script.
func (d *Debugger) ScriptFailedToParse(ctx context.Context) (cdpevent.DebuggerScriptFailedToParseClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerScriptFailedToParse.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DebuggerScriptFailedToParseClient{Stream: s}, nil
}

// DebuggerScriptFailedToParseClient implements cdpevent.DebuggerScriptFailedToParseClient.
type DebuggerScriptFailedToParseClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DebuggerScriptFailedToParseClient) Recv() (*cdpevent.DebuggerScriptFailedToParseReply, error) {
	event := new(cdpevent.DebuggerScriptFailedToParseReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Debugger", Op: "ScriptFailedToParse Recv", Err: err}
	}
	return event, nil
}

// BreakpointResolved creates the event client. Fired when breakpoint is resolved to an actual script and location.
func (d *Debugger) BreakpointResolved(ctx context.Context) (cdpevent.DebuggerBreakpointResolvedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerBreakpointResolved.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DebuggerBreakpointResolvedClient{Stream: s}, nil
}

// DebuggerBreakpointResolvedClient implements cdpevent.DebuggerBreakpointResolvedClient.
type DebuggerBreakpointResolvedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DebuggerBreakpointResolvedClient) Recv() (*cdpevent.DebuggerBreakpointResolvedReply, error) {
	event := new(cdpevent.DebuggerBreakpointResolvedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Debugger", Op: "BreakpointResolved Recv", Err: err}
	}
	return event, nil
}

// Paused creates the event client. Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
func (d *Debugger) Paused(ctx context.Context) (cdpevent.DebuggerPausedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerPaused.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DebuggerPausedClient{Stream: s}, nil
}

// DebuggerPausedClient implements cdpevent.DebuggerPausedClient.
type DebuggerPausedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DebuggerPausedClient) Recv() (*cdpevent.DebuggerPausedReply, error) {
	event := new(cdpevent.DebuggerPausedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Debugger", Op: "Paused Recv", Err: err}
	}
	return event, nil
}

// Resumed creates the event client. Fired when the virtual machine resumed execution.
func (d *Debugger) Resumed(ctx context.Context) (cdpevent.DebuggerResumedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.DebuggerResumed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &DebuggerResumedClient{Stream: s}, nil
}

// DebuggerResumedClient implements cdpevent.DebuggerResumedClient.
type DebuggerResumedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *DebuggerResumedClient) Recv() (*cdpevent.DebuggerResumedReply, error) {
	event := new(cdpevent.DebuggerResumedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Debugger", Op: "Resumed Recv", Err: err}
	}
	return event, nil
}

// The DeviceOrientation domain.
type DeviceOrientation struct{ conn *rpcc.Conn }

// NewDeviceOrientation returns the domain with the connection set to conn.
func NewDeviceOrientation(conn *rpcc.Conn) *DeviceOrientation {
	return &DeviceOrientation{conn: conn}
}

// SetDeviceOrientationOverride invokes the DeviceOrientation method. Overrides the Device Orientation.
func (d *DeviceOrientation) SetDeviceOrientationOverride(ctx context.Context, args *cdpcmd.DeviceOrientationSetDeviceOrientationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.DeviceOrientationSetDeviceOrientationOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.DeviceOrientationSetDeviceOrientationOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "DeviceOrientation", Op: "SetDeviceOrientationOverride", Err: err}
	}
	return
}

// ClearDeviceOrientationOverride invokes the DeviceOrientation method. Clears the overridden Device Orientation.
func (d *DeviceOrientation) ClearDeviceOrientationOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.DeviceOrientationClearDeviceOrientationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "DeviceOrientation", Op: "ClearDeviceOrientationOverride", Err: err}
	}
	return
}

// The Emulation domain. This domain emulates different environments for the page.
type Emulation struct{ conn *rpcc.Conn }

// NewEmulation returns the domain with the connection set to conn.
func NewEmulation(conn *rpcc.Conn) *Emulation {
	return &Emulation{conn: conn}
}

// SetDeviceMetricsOverride invokes the Emulation method. Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
func (d *Emulation) SetDeviceMetricsOverride(ctx context.Context, args *cdpcmd.EmulationSetDeviceMetricsOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDeviceMetricsOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDeviceMetricsOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetDeviceMetricsOverride", Err: err}
	}
	return
}

// ClearDeviceMetricsOverride invokes the Emulation method. Clears the overridden device metrics.
func (d *Emulation) ClearDeviceMetricsOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.EmulationClearDeviceMetricsOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "ClearDeviceMetricsOverride", Err: err}
	}
	return
}

// ForceViewport invokes the Emulation method. Overrides the visible area of the page. The change is hidden from the page, i.e. the observable scroll position and page scale does not change. In effect, the command moves the specified area of the page into the top-left corner of the frame.
func (d *Emulation) ForceViewport(ctx context.Context, args *cdpcmd.EmulationForceViewportArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationForceViewport.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationForceViewport.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "ForceViewport", Err: err}
	}
	return
}

// ResetViewport invokes the Emulation method. Resets the visible area of the page to the original viewport, undoing any effects of the forceViewport command.
func (d *Emulation) ResetViewport(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.EmulationResetViewport.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "ResetViewport", Err: err}
	}
	return
}

// ResetPageScaleFactor invokes the Emulation method. Requests that page scale factor is reset to initial values.
func (d *Emulation) ResetPageScaleFactor(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.EmulationResetPageScaleFactor.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "ResetPageScaleFactor", Err: err}
	}
	return
}

// SetPageScaleFactor invokes the Emulation method. Sets a specified page scale factor.
func (d *Emulation) SetPageScaleFactor(ctx context.Context, args *cdpcmd.EmulationSetPageScaleFactorArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetPageScaleFactor.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetPageScaleFactor.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetPageScaleFactor", Err: err}
	}
	return
}

// SetVisibleSize invokes the Emulation method. Resizes the frame/viewport of the page. Note that this does not affect the frame's container (e.g. browser window). Can be used to produce screenshots of the specified size. Not supported on Android.
func (d *Emulation) SetVisibleSize(ctx context.Context, args *cdpcmd.EmulationSetVisibleSizeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVisibleSize.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVisibleSize.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetVisibleSize", Err: err}
	}
	return
}

// SetScriptExecutionDisabled invokes the Emulation method. Switches script execution in the page.
func (d *Emulation) SetScriptExecutionDisabled(ctx context.Context, args *cdpcmd.EmulationSetScriptExecutionDisabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetScriptExecutionDisabled.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetScriptExecutionDisabled.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetScriptExecutionDisabled", Err: err}
	}
	return
}

// SetGeolocationOverride invokes the Emulation method. Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.
func (d *Emulation) SetGeolocationOverride(ctx context.Context, args *cdpcmd.EmulationSetGeolocationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetGeolocationOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetGeolocationOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetGeolocationOverride", Err: err}
	}
	return
}

// ClearGeolocationOverride invokes the Emulation method. Clears the overridden Geolocation Position and Error.
func (d *Emulation) ClearGeolocationOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.EmulationClearGeolocationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "ClearGeolocationOverride", Err: err}
	}
	return
}

// SetTouchEmulationEnabled invokes the Emulation method. Toggles mouse event-based touch event emulation.
func (d *Emulation) SetTouchEmulationEnabled(ctx context.Context, args *cdpcmd.EmulationSetTouchEmulationEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetTouchEmulationEnabled.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetTouchEmulationEnabled.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetTouchEmulationEnabled", Err: err}
	}
	return
}

// SetEmulatedMedia invokes the Emulation method. Emulates the given media for CSS media queries.
func (d *Emulation) SetEmulatedMedia(ctx context.Context, args *cdpcmd.EmulationSetEmulatedMediaArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetEmulatedMedia.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetEmulatedMedia.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetEmulatedMedia", Err: err}
	}
	return
}

// SetCPUThrottlingRate invokes the Emulation method. Enables CPU throttling to emulate slow CPUs.
func (d *Emulation) SetCPUThrottlingRate(ctx context.Context, args *cdpcmd.EmulationSetCPUThrottlingRateArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetCPUThrottlingRate.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetCPUThrottlingRate.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetCPUThrottlingRate", Err: err}
	}
	return
}

// CanEmulate invokes the Emulation method. Tells whether emulation is supported.
func (d *Emulation) CanEmulate(ctx context.Context) (reply *cdpcmd.EmulationCanEmulateReply, err error) {
	reply = new(cdpcmd.EmulationCanEmulateReply)
	err = rpcc.Invoke(ctx, cdpcmd.EmulationCanEmulate.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "CanEmulate", Err: err}
	}
	return
}

// SetVirtualTimePolicy invokes the Emulation method. Turns on virtual time for all frames (replacing real-time with a synthetic time source) and sets the current virtual time policy.  Note this supersedes any previous time budget.
func (d *Emulation) SetVirtualTimePolicy(ctx context.Context, args *cdpcmd.EmulationSetVirtualTimePolicyArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVirtualTimePolicy.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetVirtualTimePolicy.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetVirtualTimePolicy", Err: err}
	}
	return
}

// SetDefaultBackgroundColorOverride invokes the Emulation method. Sets or clears an override of the default background color of the frame. This override is used if the content does not specify one.
func (d *Emulation) SetDefaultBackgroundColorOverride(ctx context.Context, args *cdpcmd.EmulationSetDefaultBackgroundColorOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDefaultBackgroundColorOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.EmulationSetDefaultBackgroundColorOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Emulation", Op: "SetDefaultBackgroundColorOverride", Err: err}
	}
	return
}

// VirtualTimeBudgetExpired creates the event client. Notification sent after the virual time budget for the current VirtualTimePolicy has run out.
func (d *Emulation) VirtualTimeBudgetExpired(ctx context.Context) (cdpevent.EmulationVirtualTimeBudgetExpiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.EmulationVirtualTimeBudgetExpired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &EmulationVirtualTimeBudgetExpiredClient{Stream: s}, nil
}

// EmulationVirtualTimeBudgetExpiredClient implements cdpevent.EmulationVirtualTimeBudgetExpiredClient.
type EmulationVirtualTimeBudgetExpiredClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *EmulationVirtualTimeBudgetExpiredClient) Recv() (*cdpevent.EmulationVirtualTimeBudgetExpiredReply, error) {
	event := new(cdpevent.EmulationVirtualTimeBudgetExpiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Emulation", Op: "VirtualTimeBudgetExpired Recv", Err: err}
	}
	return event, nil
}

// The HeapProfiler domain.
type HeapProfiler struct{ conn *rpcc.Conn }

// NewHeapProfiler returns the domain with the connection set to conn.
func NewHeapProfiler(conn *rpcc.Conn) *HeapProfiler {
	return &HeapProfiler{conn: conn}
}

// Enable invokes the HeapProfiler method.
func (d *HeapProfiler) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the HeapProfiler method.
func (d *HeapProfiler) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "Disable", Err: err}
	}
	return
}

// StartTrackingHeapObjects invokes the HeapProfiler method.
func (d *HeapProfiler) StartTrackingHeapObjects(ctx context.Context, args *cdpcmd.HeapProfilerStartTrackingHeapObjectsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartTrackingHeapObjects.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartTrackingHeapObjects.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "StartTrackingHeapObjects", Err: err}
	}
	return
}

// StopTrackingHeapObjects invokes the HeapProfiler method.
func (d *HeapProfiler) StopTrackingHeapObjects(ctx context.Context, args *cdpcmd.HeapProfilerStopTrackingHeapObjectsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStopTrackingHeapObjects.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStopTrackingHeapObjects.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "StopTrackingHeapObjects", Err: err}
	}
	return
}

// TakeHeapSnapshot invokes the HeapProfiler method.
func (d *HeapProfiler) TakeHeapSnapshot(ctx context.Context, args *cdpcmd.HeapProfilerTakeHeapSnapshotArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerTakeHeapSnapshot.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerTakeHeapSnapshot.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "TakeHeapSnapshot", Err: err}
	}
	return
}

// CollectGarbage invokes the HeapProfiler method.
func (d *HeapProfiler) CollectGarbage(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerCollectGarbage.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "CollectGarbage", Err: err}
	}
	return
}

// GetObjectByHeapObjectID invokes the HeapProfiler method.
func (d *HeapProfiler) GetObjectByHeapObjectID(ctx context.Context, args *cdpcmd.HeapProfilerGetObjectByHeapObjectIDArgs) (reply *cdpcmd.HeapProfilerGetObjectByHeapObjectIDReply, err error) {
	reply = new(cdpcmd.HeapProfilerGetObjectByHeapObjectIDReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetObjectByHeapObjectID.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetObjectByHeapObjectID.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "GetObjectByHeapObjectID", Err: err}
	}
	return
}

// AddInspectedHeapObject invokes the HeapProfiler method. Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
func (d *HeapProfiler) AddInspectedHeapObject(ctx context.Context, args *cdpcmd.HeapProfilerAddInspectedHeapObjectArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerAddInspectedHeapObject.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerAddInspectedHeapObject.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "AddInspectedHeapObject", Err: err}
	}
	return
}

// GetHeapObjectID invokes the HeapProfiler method.
func (d *HeapProfiler) GetHeapObjectID(ctx context.Context, args *cdpcmd.HeapProfilerGetHeapObjectIDArgs) (reply *cdpcmd.HeapProfilerGetHeapObjectIDReply, err error) {
	reply = new(cdpcmd.HeapProfilerGetHeapObjectIDReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetHeapObjectID.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerGetHeapObjectID.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "GetHeapObjectID", Err: err}
	}
	return
}

// StartSampling invokes the HeapProfiler method.
func (d *HeapProfiler) StartSampling(ctx context.Context, args *cdpcmd.HeapProfilerStartSamplingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartSampling.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStartSampling.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "StartSampling", Err: err}
	}
	return
}

// StopSampling invokes the HeapProfiler method.
func (d *HeapProfiler) StopSampling(ctx context.Context) (reply *cdpcmd.HeapProfilerStopSamplingReply, err error) {
	reply = new(cdpcmd.HeapProfilerStopSamplingReply)
	err = rpcc.Invoke(ctx, cdpcmd.HeapProfilerStopSampling.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "HeapProfiler", Op: "StopSampling", Err: err}
	}
	return
}

// AddHeapSnapshotChunk creates the event client.
func (d *HeapProfiler) AddHeapSnapshotChunk(ctx context.Context) (cdpevent.HeapProfilerAddHeapSnapshotChunkClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerAddHeapSnapshotChunk.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &HeapProfilerAddHeapSnapshotChunkClient{Stream: s}, nil
}

// HeapProfilerAddHeapSnapshotChunkClient implements cdpevent.HeapProfilerAddHeapSnapshotChunkClient.
type HeapProfilerAddHeapSnapshotChunkClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *HeapProfilerAddHeapSnapshotChunkClient) Recv() (*cdpevent.HeapProfilerAddHeapSnapshotChunkReply, error) {
	event := new(cdpevent.HeapProfilerAddHeapSnapshotChunkReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "HeapProfiler", Op: "AddHeapSnapshotChunk Recv", Err: err}
	}
	return event, nil
}

// ResetProfiles creates the event client.
func (d *HeapProfiler) ResetProfiles(ctx context.Context) (cdpevent.HeapProfilerResetProfilesClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerResetProfiles.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &HeapProfilerResetProfilesClient{Stream: s}, nil
}

// HeapProfilerResetProfilesClient implements cdpevent.HeapProfilerResetProfilesClient.
type HeapProfilerResetProfilesClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *HeapProfilerResetProfilesClient) Recv() (*cdpevent.HeapProfilerResetProfilesReply, error) {
	event := new(cdpevent.HeapProfilerResetProfilesReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "HeapProfiler", Op: "ResetProfiles Recv", Err: err}
	}
	return event, nil
}

// ReportHeapSnapshotProgress creates the event client.
func (d *HeapProfiler) ReportHeapSnapshotProgress(ctx context.Context) (cdpevent.HeapProfilerReportHeapSnapshotProgressClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerReportHeapSnapshotProgress.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &HeapProfilerReportHeapSnapshotProgressClient{Stream: s}, nil
}

// HeapProfilerReportHeapSnapshotProgressClient implements cdpevent.HeapProfilerReportHeapSnapshotProgressClient.
type HeapProfilerReportHeapSnapshotProgressClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *HeapProfilerReportHeapSnapshotProgressClient) Recv() (*cdpevent.HeapProfilerReportHeapSnapshotProgressReply, error) {
	event := new(cdpevent.HeapProfilerReportHeapSnapshotProgressReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "HeapProfiler", Op: "ReportHeapSnapshotProgress Recv", Err: err}
	}
	return event, nil
}

// LastSeenObjectID creates the event client. If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
func (d *HeapProfiler) LastSeenObjectID(ctx context.Context) (cdpevent.HeapProfilerLastSeenObjectIDClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerLastSeenObjectID.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &HeapProfilerLastSeenObjectIDClient{Stream: s}, nil
}

// HeapProfilerLastSeenObjectIDClient implements cdpevent.HeapProfilerLastSeenObjectIDClient.
type HeapProfilerLastSeenObjectIDClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *HeapProfilerLastSeenObjectIDClient) Recv() (*cdpevent.HeapProfilerLastSeenObjectIDReply, error) {
	event := new(cdpevent.HeapProfilerLastSeenObjectIDReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "HeapProfiler", Op: "LastSeenObjectID Recv", Err: err}
	}
	return event, nil
}

// HeapStatsUpdate creates the event client. If heap objects tracking has been started then backend may send update for one or more fragments
func (d *HeapProfiler) HeapStatsUpdate(ctx context.Context) (cdpevent.HeapProfilerHeapStatsUpdateClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.HeapProfilerHeapStatsUpdate.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &HeapProfilerHeapStatsUpdateClient{Stream: s}, nil
}

// HeapProfilerHeapStatsUpdateClient implements cdpevent.HeapProfilerHeapStatsUpdateClient.
type HeapProfilerHeapStatsUpdateClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *HeapProfilerHeapStatsUpdateClient) Recv() (*cdpevent.HeapProfilerHeapStatsUpdateReply, error) {
	event := new(cdpevent.HeapProfilerHeapStatsUpdateReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "HeapProfiler", Op: "HeapStatsUpdate Recv", Err: err}
	}
	return event, nil
}

// The IO domain. Input/Output operations for streams produced by DevTools.
type IO struct{ conn *rpcc.Conn }

// NewIO returns the domain with the connection set to conn.
func NewIO(conn *rpcc.Conn) *IO {
	return &IO{conn: conn}
}

// Read invokes the IO method. Read a chunk of the stream
func (d *IO) Read(ctx context.Context, args *cdpcmd.IOReadArgs) (reply *cdpcmd.IOReadReply, err error) {
	reply = new(cdpcmd.IOReadReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IORead.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IORead.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IO", Op: "Read", Err: err}
	}
	return
}

// Close invokes the IO method. Close the stream, discard any temporary backing storage.
func (d *IO) Close(ctx context.Context, args *cdpcmd.IOCloseArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IOClose.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IOClose.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IO", Op: "Close", Err: err}
	}
	return
}

// The IndexedDB domain.
type IndexedDB struct{ conn *rpcc.Conn }

// NewIndexedDB returns the domain with the connection set to conn.
func NewIndexedDB(conn *rpcc.Conn) *IndexedDB {
	return &IndexedDB{conn: conn}
}

// Enable invokes the IndexedDB method. Enables events from backend.
func (d *IndexedDB) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the IndexedDB method. Disables events from backend.
func (d *IndexedDB) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.IndexedDBDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "Disable", Err: err}
	}
	return
}

// RequestDatabaseNames invokes the IndexedDB method. Requests database names for given security origin.
func (d *IndexedDB) RequestDatabaseNames(ctx context.Context, args *cdpcmd.IndexedDBRequestDatabaseNamesArgs) (reply *cdpcmd.IndexedDBRequestDatabaseNamesReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDatabaseNamesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabaseNames.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabaseNames.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "RequestDatabaseNames", Err: err}
	}
	return
}

// RequestDatabase invokes the IndexedDB method. Requests database with given name in given frame.
func (d *IndexedDB) RequestDatabase(ctx context.Context, args *cdpcmd.IndexedDBRequestDatabaseArgs) (reply *cdpcmd.IndexedDBRequestDatabaseReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDatabaseReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabase.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestDatabase.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "RequestDatabase", Err: err}
	}
	return
}

// RequestData invokes the IndexedDB method. Requests data from object store or index.
func (d *IndexedDB) RequestData(ctx context.Context, args *cdpcmd.IndexedDBRequestDataArgs) (reply *cdpcmd.IndexedDBRequestDataReply, err error) {
	reply = new(cdpcmd.IndexedDBRequestDataReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestData.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBRequestData.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "RequestData", Err: err}
	}
	return
}

// ClearObjectStore invokes the IndexedDB method. Clears all entries from an object store.
func (d *IndexedDB) ClearObjectStore(ctx context.Context, args *cdpcmd.IndexedDBClearObjectStoreArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBClearObjectStore.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBClearObjectStore.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "ClearObjectStore", Err: err}
	}
	return
}

// DeleteDatabase invokes the IndexedDB method. Deletes a database.
func (d *IndexedDB) DeleteDatabase(ctx context.Context, args *cdpcmd.IndexedDBDeleteDatabaseArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBDeleteDatabase.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.IndexedDBDeleteDatabase.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "IndexedDB", Op: "DeleteDatabase", Err: err}
	}
	return
}

// The Input domain.
type Input struct{ conn *rpcc.Conn }

// NewInput returns the domain with the connection set to conn.
func NewInput(conn *rpcc.Conn) *Input {
	return &Input{conn: conn}
}

// SetIgnoreInputEvents invokes the Input method. Ignores input events (useful while auditing page).
func (d *Input) SetIgnoreInputEvents(ctx context.Context, args *cdpcmd.InputSetIgnoreInputEventsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputSetIgnoreInputEvents.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputSetIgnoreInputEvents.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "SetIgnoreInputEvents", Err: err}
	}
	return
}

// DispatchKeyEvent invokes the Input method. Dispatches a key event to the page.
func (d *Input) DispatchKeyEvent(ctx context.Context, args *cdpcmd.InputDispatchKeyEventArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchKeyEvent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchKeyEvent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "DispatchKeyEvent", Err: err}
	}
	return
}

// DispatchMouseEvent invokes the Input method. Dispatches a mouse event to the page.
func (d *Input) DispatchMouseEvent(ctx context.Context, args *cdpcmd.InputDispatchMouseEventArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchMouseEvent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchMouseEvent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "DispatchMouseEvent", Err: err}
	}
	return
}

// DispatchTouchEvent invokes the Input method. Dispatches a touch event to the page.
func (d *Input) DispatchTouchEvent(ctx context.Context, args *cdpcmd.InputDispatchTouchEventArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchTouchEvent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputDispatchTouchEvent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "DispatchTouchEvent", Err: err}
	}
	return
}

// EmulateTouchFromMouseEvent invokes the Input method. Emulates touch event from the mouse event parameters.
func (d *Input) EmulateTouchFromMouseEvent(ctx context.Context, args *cdpcmd.InputEmulateTouchFromMouseEventArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputEmulateTouchFromMouseEvent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputEmulateTouchFromMouseEvent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "EmulateTouchFromMouseEvent", Err: err}
	}
	return
}

// SynthesizePinchGesture invokes the Input method. Synthesizes a pinch gesture over a time period by issuing appropriate touch events.
func (d *Input) SynthesizePinchGesture(ctx context.Context, args *cdpcmd.InputSynthesizePinchGestureArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizePinchGesture.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizePinchGesture.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "SynthesizePinchGesture", Err: err}
	}
	return
}

// SynthesizeScrollGesture invokes the Input method. Synthesizes a scroll gesture over a time period by issuing appropriate touch events.
func (d *Input) SynthesizeScrollGesture(ctx context.Context, args *cdpcmd.InputSynthesizeScrollGestureArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeScrollGesture.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeScrollGesture.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "SynthesizeScrollGesture", Err: err}
	}
	return
}

// SynthesizeTapGesture invokes the Input method. Synthesizes a tap gesture over a time period by issuing appropriate touch events.
func (d *Input) SynthesizeTapGesture(ctx context.Context, args *cdpcmd.InputSynthesizeTapGestureArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeTapGesture.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.InputSynthesizeTapGesture.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Input", Op: "SynthesizeTapGesture", Err: err}
	}
	return
}

// The Inspector domain.
type Inspector struct{ conn *rpcc.Conn }

// NewInspector returns the domain with the connection set to conn.
func NewInspector(conn *rpcc.Conn) *Inspector {
	return &Inspector{conn: conn}
}

// Enable invokes the Inspector method. Enables inspector domain notifications.
func (d *Inspector) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.InspectorEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Inspector", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Inspector method. Disables inspector domain notifications.
func (d *Inspector) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.InspectorDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Inspector", Op: "Disable", Err: err}
	}
	return
}

// Detached creates the event client. Fired when remote debugging connection is about to be terminated. Contains detach reason.
func (d *Inspector) Detached(ctx context.Context) (cdpevent.InspectorDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.InspectorDetached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &InspectorDetachedClient{Stream: s}, nil
}

// InspectorDetachedClient implements cdpevent.InspectorDetachedClient.
type InspectorDetachedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *InspectorDetachedClient) Recv() (*cdpevent.InspectorDetachedReply, error) {
	event := new(cdpevent.InspectorDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Inspector", Op: "Detached Recv", Err: err}
	}
	return event, nil
}

// TargetCrashed creates the event client. Fired when debugging target has crashed
func (d *Inspector) TargetCrashed(ctx context.Context) (cdpevent.InspectorTargetCrashedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.InspectorTargetCrashed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &InspectorTargetCrashedClient{Stream: s}, nil
}

// InspectorTargetCrashedClient implements cdpevent.InspectorTargetCrashedClient.
type InspectorTargetCrashedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *InspectorTargetCrashedClient) Recv() (*cdpevent.InspectorTargetCrashedReply, error) {
	event := new(cdpevent.InspectorTargetCrashedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Inspector", Op: "TargetCrashed Recv", Err: err}
	}
	return event, nil
}

// The LayerTree domain.
type LayerTree struct{ conn *rpcc.Conn }

// NewLayerTree returns the domain with the connection set to conn.
func NewLayerTree(conn *rpcc.Conn) *LayerTree {
	return &LayerTree{conn: conn}
}

// Enable invokes the LayerTree method. Enables compositing tree inspection.
func (d *LayerTree) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the LayerTree method. Disables compositing tree inspection.
func (d *LayerTree) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LayerTreeDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "Disable", Err: err}
	}
	return
}

// CompositingReasons invokes the LayerTree method. Provides the reasons why the given layer was composited.
func (d *LayerTree) CompositingReasons(ctx context.Context, args *cdpcmd.LayerTreeCompositingReasonsArgs) (reply *cdpcmd.LayerTreeCompositingReasonsReply, err error) {
	reply = new(cdpcmd.LayerTreeCompositingReasonsReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeCompositingReasons.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeCompositingReasons.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "CompositingReasons", Err: err}
	}
	return
}

// MakeSnapshot invokes the LayerTree method. Returns the layer snapshot identifier.
func (d *LayerTree) MakeSnapshot(ctx context.Context, args *cdpcmd.LayerTreeMakeSnapshotArgs) (reply *cdpcmd.LayerTreeMakeSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeMakeSnapshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeMakeSnapshot.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeMakeSnapshot.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "MakeSnapshot", Err: err}
	}
	return
}

// LoadSnapshot invokes the LayerTree method. Returns the snapshot identifier.
func (d *LayerTree) LoadSnapshot(ctx context.Context, args *cdpcmd.LayerTreeLoadSnapshotArgs) (reply *cdpcmd.LayerTreeLoadSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeLoadSnapshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeLoadSnapshot.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeLoadSnapshot.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "LoadSnapshot", Err: err}
	}
	return
}

// ReleaseSnapshot invokes the LayerTree method. Releases layer snapshot captured by the back-end.
func (d *LayerTree) ReleaseSnapshot(ctx context.Context, args *cdpcmd.LayerTreeReleaseSnapshotArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReleaseSnapshot.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReleaseSnapshot.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "ReleaseSnapshot", Err: err}
	}
	return
}

// ProfileSnapshot invokes the LayerTree method.
func (d *LayerTree) ProfileSnapshot(ctx context.Context, args *cdpcmd.LayerTreeProfileSnapshotArgs) (reply *cdpcmd.LayerTreeProfileSnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeProfileSnapshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeProfileSnapshot.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeProfileSnapshot.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "ProfileSnapshot", Err: err}
	}
	return
}

// ReplaySnapshot invokes the LayerTree method. Replays the layer snapshot and returns the resulting bitmap.
func (d *LayerTree) ReplaySnapshot(ctx context.Context, args *cdpcmd.LayerTreeReplaySnapshotArgs) (reply *cdpcmd.LayerTreeReplaySnapshotReply, err error) {
	reply = new(cdpcmd.LayerTreeReplaySnapshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReplaySnapshot.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeReplaySnapshot.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "ReplaySnapshot", Err: err}
	}
	return
}

// SnapshotCommandLog invokes the LayerTree method. Replays the layer snapshot and returns canvas log.
func (d *LayerTree) SnapshotCommandLog(ctx context.Context, args *cdpcmd.LayerTreeSnapshotCommandLogArgs) (reply *cdpcmd.LayerTreeSnapshotCommandLogReply, err error) {
	reply = new(cdpcmd.LayerTreeSnapshotCommandLogReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeSnapshotCommandLog.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LayerTreeSnapshotCommandLog.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "LayerTree", Op: "SnapshotCommandLog", Err: err}
	}
	return
}

// LayerTreeDidChange creates the event client.
func (d *LayerTree) LayerTreeDidChange(ctx context.Context) (cdpevent.LayerTreeDidChangeClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LayerTreeDidChange.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &LayerTreeDidChangeClient{Stream: s}, nil
}

// LayerTreeDidChangeClient implements cdpevent.LayerTreeDidChangeClient.
type LayerTreeDidChangeClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *LayerTreeDidChangeClient) Recv() (*cdpevent.LayerTreeDidChangeReply, error) {
	event := new(cdpevent.LayerTreeDidChangeReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "LayerTree", Op: "LayerTreeDidChange Recv", Err: err}
	}
	return event, nil
}

// LayerPainted creates the event client.
func (d *LayerTree) LayerPainted(ctx context.Context) (cdpevent.LayerTreeLayerPaintedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LayerTreeLayerPainted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &LayerTreeLayerPaintedClient{Stream: s}, nil
}

// LayerTreeLayerPaintedClient implements cdpevent.LayerTreeLayerPaintedClient.
type LayerTreeLayerPaintedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *LayerTreeLayerPaintedClient) Recv() (*cdpevent.LayerTreeLayerPaintedReply, error) {
	event := new(cdpevent.LayerTreeLayerPaintedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "LayerTree", Op: "LayerPainted Recv", Err: err}
	}
	return event, nil
}

// The Log domain. Provides access to log entries.
type Log struct{ conn *rpcc.Conn }

// NewLog returns the domain with the connection set to conn.
func NewLog(conn *rpcc.Conn) *Log {
	return &Log{conn: conn}
}

// Enable invokes the Log method. Enables log domain, sends the entries collected so far to the client by means of the entryAdded notification.
func (d *Log) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LogEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Log", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Log method. Disables log domain, prevents further log entries from being reported to the client.
func (d *Log) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LogDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Log", Op: "Disable", Err: err}
	}
	return
}

// Clear invokes the Log method. Clears the log.
func (d *Log) Clear(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LogClear.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Log", Op: "Clear", Err: err}
	}
	return
}

// StartViolationsReport invokes the Log method. start violation reporting.
func (d *Log) StartViolationsReport(ctx context.Context, args *cdpcmd.LogStartViolationsReportArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.LogStartViolationsReport.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.LogStartViolationsReport.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Log", Op: "StartViolationsReport", Err: err}
	}
	return
}

// StopViolationsReport invokes the Log method. Stop violation reporting.
func (d *Log) StopViolationsReport(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.LogStopViolationsReport.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Log", Op: "StopViolationsReport", Err: err}
	}
	return
}

// EntryAdded creates the event client. Issued when new message was logged.
func (d *Log) EntryAdded(ctx context.Context) (cdpevent.LogEntryAddedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.LogEntryAdded.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &LogEntryAddedClient{Stream: s}, nil
}

// LogEntryAddedClient implements cdpevent.LogEntryAddedClient.
type LogEntryAddedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *LogEntryAddedClient) Recv() (*cdpevent.LogEntryAddedReply, error) {
	event := new(cdpevent.LogEntryAddedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Log", Op: "EntryAdded Recv", Err: err}
	}
	return event, nil
}

// The Memory domain.
type Memory struct{ conn *rpcc.Conn }

// NewMemory returns the domain with the connection set to conn.
func NewMemory(conn *rpcc.Conn) *Memory {
	return &Memory{conn: conn}
}

// GetDOMCounters invokes the Memory method.
func (d *Memory) GetDOMCounters(ctx context.Context) (reply *cdpcmd.MemoryGetDOMCountersReply, err error) {
	reply = new(cdpcmd.MemoryGetDOMCountersReply)
	err = rpcc.Invoke(ctx, cdpcmd.MemoryGetDOMCounters.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Memory", Op: "GetDOMCounters", Err: err}
	}
	return
}

// SetPressureNotificationsSuppressed invokes the Memory method. Enable/disable suppressing memory pressure notifications in all processes.
func (d *Memory) SetPressureNotificationsSuppressed(ctx context.Context, args *cdpcmd.MemorySetPressureNotificationsSuppressedArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.MemorySetPressureNotificationsSuppressed.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.MemorySetPressureNotificationsSuppressed.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Memory", Op: "SetPressureNotificationsSuppressed", Err: err}
	}
	return
}

// SimulatePressureNotification invokes the Memory method. Simulate a memory pressure notification in all processes.
func (d *Memory) SimulatePressureNotification(ctx context.Context, args *cdpcmd.MemorySimulatePressureNotificationArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.MemorySimulatePressureNotification.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.MemorySimulatePressureNotification.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Memory", Op: "SimulatePressureNotification", Err: err}
	}
	return
}

// The Network domain. Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.
type Network struct{ conn *rpcc.Conn }

// NewNetwork returns the domain with the connection set to conn.
func NewNetwork(conn *rpcc.Conn) *Network {
	return &Network{conn: conn}
}

// Enable invokes the Network method. Enables network tracking, network events will now be delivered to the client.
func (d *Network) Enable(ctx context.Context, args *cdpcmd.NetworkEnableArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkEnable.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkEnable.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Network method. Disables network tracking, prevents network events from being sent to the client.
func (d *Network) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.NetworkDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "Disable", Err: err}
	}
	return
}

// SetUserAgentOverride invokes the Network method. Allows overriding user agent with the given string.
func (d *Network) SetUserAgentOverride(ctx context.Context, args *cdpcmd.NetworkSetUserAgentOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetUserAgentOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetUserAgentOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetUserAgentOverride", Err: err}
	}
	return
}

// SetExtraHTTPHeaders invokes the Network method. Specifies whether to always send extra HTTP headers with the requests from this page.
func (d *Network) SetExtraHTTPHeaders(ctx context.Context, args *cdpcmd.NetworkSetExtraHTTPHeadersArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetExtraHTTPHeaders.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetExtraHTTPHeaders.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetExtraHTTPHeaders", Err: err}
	}
	return
}

// GetResponseBody invokes the Network method. Returns content served for the given request.
func (d *Network) GetResponseBody(ctx context.Context, args *cdpcmd.NetworkGetResponseBodyArgs) (reply *cdpcmd.NetworkGetResponseBodyReply, err error) {
	reply = new(cdpcmd.NetworkGetResponseBodyReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetResponseBody.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetResponseBody.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "GetResponseBody", Err: err}
	}
	return
}

// SetBlockedURLs invokes the Network method. Blocks URLs from loading.
func (d *Network) SetBlockedURLs(ctx context.Context, args *cdpcmd.NetworkSetBlockedURLsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBlockedURLs.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBlockedURLs.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetBlockedURLs", Err: err}
	}
	return
}

// ReplayXHR invokes the Network method. This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.
func (d *Network) ReplayXHR(ctx context.Context, args *cdpcmd.NetworkReplayXHRArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkReplayXHR.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkReplayXHR.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "ReplayXHR", Err: err}
	}
	return
}

// CanClearBrowserCache invokes the Network method. Tells whether clearing browser cache is supported.
func (d *Network) CanClearBrowserCache(ctx context.Context) (reply *cdpcmd.NetworkCanClearBrowserCacheReply, err error) {
	reply = new(cdpcmd.NetworkCanClearBrowserCacheReply)
	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanClearBrowserCache.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "CanClearBrowserCache", Err: err}
	}
	return
}

// ClearBrowserCache invokes the Network method. Clears browser cache.
func (d *Network) ClearBrowserCache(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.NetworkClearBrowserCache.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "ClearBrowserCache", Err: err}
	}
	return
}

// CanClearBrowserCookies invokes the Network method. Tells whether clearing browser cookies is supported.
func (d *Network) CanClearBrowserCookies(ctx context.Context) (reply *cdpcmd.NetworkCanClearBrowserCookiesReply, err error) {
	reply = new(cdpcmd.NetworkCanClearBrowserCookiesReply)
	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanClearBrowserCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "CanClearBrowserCookies", Err: err}
	}
	return
}

// ClearBrowserCookies invokes the Network method. Clears browser cookies.
func (d *Network) ClearBrowserCookies(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.NetworkClearBrowserCookies.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "ClearBrowserCookies", Err: err}
	}
	return
}

// GetCookies invokes the Network method. Returns all browser cookies for the current URL. Depending on the backend support, will return detailed cookie information in the cookies field.
func (d *Network) GetCookies(ctx context.Context, args *cdpcmd.NetworkGetCookiesArgs) (reply *cdpcmd.NetworkGetCookiesReply, err error) {
	reply = new(cdpcmd.NetworkGetCookiesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCookies.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCookies.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "GetCookies", Err: err}
	}
	return
}

// GetAllCookies invokes the Network method. Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the cookies field.
func (d *Network) GetAllCookies(ctx context.Context) (reply *cdpcmd.NetworkGetAllCookiesReply, err error) {
	reply = new(cdpcmd.NetworkGetAllCookiesReply)
	err = rpcc.Invoke(ctx, cdpcmd.NetworkGetAllCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "GetAllCookies", Err: err}
	}
	return
}

// DeleteCookie invokes the Network method. Deletes browser cookie with given name, domain and path.
func (d *Network) DeleteCookie(ctx context.Context, args *cdpcmd.NetworkDeleteCookieArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkDeleteCookie.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkDeleteCookie.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "DeleteCookie", Err: err}
	}
	return
}

// SetCookie invokes the Network method. Sets a cookie with the given cookie data; may overwrite equivalent cookies if they exist.
func (d *Network) SetCookie(ctx context.Context, args *cdpcmd.NetworkSetCookieArgs) (reply *cdpcmd.NetworkSetCookieReply, err error) {
	reply = new(cdpcmd.NetworkSetCookieReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCookie.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCookie.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetCookie", Err: err}
	}
	return
}

// CanEmulateNetworkConditions invokes the Network method. Tells whether emulation of network conditions is supported.
func (d *Network) CanEmulateNetworkConditions(ctx context.Context) (reply *cdpcmd.NetworkCanEmulateNetworkConditionsReply, err error) {
	reply = new(cdpcmd.NetworkCanEmulateNetworkConditionsReply)
	err = rpcc.Invoke(ctx, cdpcmd.NetworkCanEmulateNetworkConditions.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Network", Op: "CanEmulateNetworkConditions", Err: err}
	}
	return
}

// EmulateNetworkConditions invokes the Network method. Activates emulation of network conditions.
func (d *Network) EmulateNetworkConditions(ctx context.Context, args *cdpcmd.NetworkEmulateNetworkConditionsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkEmulateNetworkConditions.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkEmulateNetworkConditions.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "EmulateNetworkConditions", Err: err}
	}
	return
}

// SetCacheDisabled invokes the Network method. Toggles ignoring cache for each request. If true, cache will not be used.
func (d *Network) SetCacheDisabled(ctx context.Context, args *cdpcmd.NetworkSetCacheDisabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCacheDisabled.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetCacheDisabled.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetCacheDisabled", Err: err}
	}
	return
}

// SetBypassServiceWorker invokes the Network method. Toggles ignoring of service worker for each request.
func (d *Network) SetBypassServiceWorker(ctx context.Context, args *cdpcmd.NetworkSetBypassServiceWorkerArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBypassServiceWorker.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetBypassServiceWorker.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetBypassServiceWorker", Err: err}
	}
	return
}

// SetDataSizeLimitsForTest invokes the Network method. For testing.
func (d *Network) SetDataSizeLimitsForTest(ctx context.Context, args *cdpcmd.NetworkSetDataSizeLimitsForTestArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetDataSizeLimitsForTest.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkSetDataSizeLimitsForTest.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "SetDataSizeLimitsForTest", Err: err}
	}
	return
}

// GetCertificate invokes the Network method. Returns the DER-encoded certificate.
func (d *Network) GetCertificate(ctx context.Context, args *cdpcmd.NetworkGetCertificateArgs) (reply *cdpcmd.NetworkGetCertificateReply, err error) {
	reply = new(cdpcmd.NetworkGetCertificateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCertificate.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.NetworkGetCertificate.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Network", Op: "GetCertificate", Err: err}
	}
	return
}

// ResourceChangedPriority creates the event client. Fired when resource loading priority is changed
func (d *Network) ResourceChangedPriority(ctx context.Context) (cdpevent.NetworkResourceChangedPriorityClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkResourceChangedPriority.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkResourceChangedPriorityClient{Stream: s}, nil
}

// NetworkResourceChangedPriorityClient implements cdpevent.NetworkResourceChangedPriorityClient.
type NetworkResourceChangedPriorityClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkResourceChangedPriorityClient) Recv() (*cdpevent.NetworkResourceChangedPriorityReply, error) {
	event := new(cdpevent.NetworkResourceChangedPriorityReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "ResourceChangedPriority Recv", Err: err}
	}
	return event, nil
}

// RequestWillBeSent creates the event client. Fired when page is about to send HTTP request.
func (d *Network) RequestWillBeSent(ctx context.Context) (cdpevent.NetworkRequestWillBeSentClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkRequestWillBeSent.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkRequestWillBeSentClient{Stream: s}, nil
}

// NetworkRequestWillBeSentClient implements cdpevent.NetworkRequestWillBeSentClient.
type NetworkRequestWillBeSentClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkRequestWillBeSentClient) Recv() (*cdpevent.NetworkRequestWillBeSentReply, error) {
	event := new(cdpevent.NetworkRequestWillBeSentReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "RequestWillBeSent Recv", Err: err}
	}
	return event, nil
}

// RequestServedFromCache creates the event client. Fired if request ended up loading from cache.
func (d *Network) RequestServedFromCache(ctx context.Context) (cdpevent.NetworkRequestServedFromCacheClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkRequestServedFromCache.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkRequestServedFromCacheClient{Stream: s}, nil
}

// NetworkRequestServedFromCacheClient implements cdpevent.NetworkRequestServedFromCacheClient.
type NetworkRequestServedFromCacheClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkRequestServedFromCacheClient) Recv() (*cdpevent.NetworkRequestServedFromCacheReply, error) {
	event := new(cdpevent.NetworkRequestServedFromCacheReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "RequestServedFromCache Recv", Err: err}
	}
	return event, nil
}

// ResponseReceived creates the event client. Fired when HTTP response is available.
func (d *Network) ResponseReceived(ctx context.Context) (cdpevent.NetworkResponseReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkResponseReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkResponseReceivedClient{Stream: s}, nil
}

// NetworkResponseReceivedClient implements cdpevent.NetworkResponseReceivedClient.
type NetworkResponseReceivedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkResponseReceivedClient) Recv() (*cdpevent.NetworkResponseReceivedReply, error) {
	event := new(cdpevent.NetworkResponseReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "ResponseReceived Recv", Err: err}
	}
	return event, nil
}

// DataReceived creates the event client. Fired when data chunk was received over the network.
func (d *Network) DataReceived(ctx context.Context) (cdpevent.NetworkDataReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkDataReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkDataReceivedClient{Stream: s}, nil
}

// NetworkDataReceivedClient implements cdpevent.NetworkDataReceivedClient.
type NetworkDataReceivedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkDataReceivedClient) Recv() (*cdpevent.NetworkDataReceivedReply, error) {
	event := new(cdpevent.NetworkDataReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "DataReceived Recv", Err: err}
	}
	return event, nil
}

// LoadingFinished creates the event client. Fired when HTTP request has finished loading.
func (d *Network) LoadingFinished(ctx context.Context) (cdpevent.NetworkLoadingFinishedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkLoadingFinished.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkLoadingFinishedClient{Stream: s}, nil
}

// NetworkLoadingFinishedClient implements cdpevent.NetworkLoadingFinishedClient.
type NetworkLoadingFinishedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkLoadingFinishedClient) Recv() (*cdpevent.NetworkLoadingFinishedReply, error) {
	event := new(cdpevent.NetworkLoadingFinishedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "LoadingFinished Recv", Err: err}
	}
	return event, nil
}

// LoadingFailed creates the event client. Fired when HTTP request has failed to load.
func (d *Network) LoadingFailed(ctx context.Context) (cdpevent.NetworkLoadingFailedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkLoadingFailed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkLoadingFailedClient{Stream: s}, nil
}

// NetworkLoadingFailedClient implements cdpevent.NetworkLoadingFailedClient.
type NetworkLoadingFailedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkLoadingFailedClient) Recv() (*cdpevent.NetworkLoadingFailedReply, error) {
	event := new(cdpevent.NetworkLoadingFailedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "LoadingFailed Recv", Err: err}
	}
	return event, nil
}

// WebSocketWillSendHandshakeRequest creates the event client. Fired when WebSocket is about to initiate handshake.
func (d *Network) WebSocketWillSendHandshakeRequest(ctx context.Context) (cdpevent.NetworkWebSocketWillSendHandshakeRequestClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketWillSendHandshakeRequest.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketWillSendHandshakeRequestClient{Stream: s}, nil
}

// NetworkWebSocketWillSendHandshakeRequestClient implements cdpevent.NetworkWebSocketWillSendHandshakeRequestClient.
type NetworkWebSocketWillSendHandshakeRequestClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketWillSendHandshakeRequestClient) Recv() (*cdpevent.NetworkWebSocketWillSendHandshakeRequestReply, error) {
	event := new(cdpevent.NetworkWebSocketWillSendHandshakeRequestReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketWillSendHandshakeRequest Recv", Err: err}
	}
	return event, nil
}

// WebSocketHandshakeResponseReceived creates the event client. Fired when WebSocket handshake response becomes available.
func (d *Network) WebSocketHandshakeResponseReceived(ctx context.Context) (cdpevent.NetworkWebSocketHandshakeResponseReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketHandshakeResponseReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketHandshakeResponseReceivedClient{Stream: s}, nil
}

// NetworkWebSocketHandshakeResponseReceivedClient implements cdpevent.NetworkWebSocketHandshakeResponseReceivedClient.
type NetworkWebSocketHandshakeResponseReceivedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketHandshakeResponseReceivedClient) Recv() (*cdpevent.NetworkWebSocketHandshakeResponseReceivedReply, error) {
	event := new(cdpevent.NetworkWebSocketHandshakeResponseReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketHandshakeResponseReceived Recv", Err: err}
	}
	return event, nil
}

// WebSocketCreated creates the event client. Fired upon WebSocket creation.
func (d *Network) WebSocketCreated(ctx context.Context) (cdpevent.NetworkWebSocketCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketCreatedClient{Stream: s}, nil
}

// NetworkWebSocketCreatedClient implements cdpevent.NetworkWebSocketCreatedClient.
type NetworkWebSocketCreatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketCreatedClient) Recv() (*cdpevent.NetworkWebSocketCreatedReply, error) {
	event := new(cdpevent.NetworkWebSocketCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketCreated Recv", Err: err}
	}
	return event, nil
}

// WebSocketClosed creates the event client. Fired when WebSocket is closed.
func (d *Network) WebSocketClosed(ctx context.Context) (cdpevent.NetworkWebSocketClosedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketClosed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketClosedClient{Stream: s}, nil
}

// NetworkWebSocketClosedClient implements cdpevent.NetworkWebSocketClosedClient.
type NetworkWebSocketClosedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketClosedClient) Recv() (*cdpevent.NetworkWebSocketClosedReply, error) {
	event := new(cdpevent.NetworkWebSocketClosedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketClosed Recv", Err: err}
	}
	return event, nil
}

// WebSocketFrameReceived creates the event client. Fired when WebSocket frame is received.
func (d *Network) WebSocketFrameReceived(ctx context.Context) (cdpevent.NetworkWebSocketFrameReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketFrameReceivedClient{Stream: s}, nil
}

// NetworkWebSocketFrameReceivedClient implements cdpevent.NetworkWebSocketFrameReceivedClient.
type NetworkWebSocketFrameReceivedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketFrameReceivedClient) Recv() (*cdpevent.NetworkWebSocketFrameReceivedReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketFrameReceived Recv", Err: err}
	}
	return event, nil
}

// WebSocketFrameError creates the event client. Fired when WebSocket frame error occurs.
func (d *Network) WebSocketFrameError(ctx context.Context) (cdpevent.NetworkWebSocketFrameErrorClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameError.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketFrameErrorClient{Stream: s}, nil
}

// NetworkWebSocketFrameErrorClient implements cdpevent.NetworkWebSocketFrameErrorClient.
type NetworkWebSocketFrameErrorClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketFrameErrorClient) Recv() (*cdpevent.NetworkWebSocketFrameErrorReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameErrorReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketFrameError Recv", Err: err}
	}
	return event, nil
}

// WebSocketFrameSent creates the event client. Fired when WebSocket frame is sent.
func (d *Network) WebSocketFrameSent(ctx context.Context) (cdpevent.NetworkWebSocketFrameSentClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkWebSocketFrameSent.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkWebSocketFrameSentClient{Stream: s}, nil
}

// NetworkWebSocketFrameSentClient implements cdpevent.NetworkWebSocketFrameSentClient.
type NetworkWebSocketFrameSentClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkWebSocketFrameSentClient) Recv() (*cdpevent.NetworkWebSocketFrameSentReply, error) {
	event := new(cdpevent.NetworkWebSocketFrameSentReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "WebSocketFrameSent Recv", Err: err}
	}
	return event, nil
}

// EventSourceMessageReceived creates the event client. Fired when EventSource message is received.
func (d *Network) EventSourceMessageReceived(ctx context.Context) (cdpevent.NetworkEventSourceMessageReceivedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.NetworkEventSourceMessageReceived.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &NetworkEventSourceMessageReceivedClient{Stream: s}, nil
}

// NetworkEventSourceMessageReceivedClient implements cdpevent.NetworkEventSourceMessageReceivedClient.
type NetworkEventSourceMessageReceivedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *NetworkEventSourceMessageReceivedClient) Recv() (*cdpevent.NetworkEventSourceMessageReceivedReply, error) {
	event := new(cdpevent.NetworkEventSourceMessageReceivedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Network", Op: "EventSourceMessageReceived Recv", Err: err}
	}
	return event, nil
}

// The Overlay domain. This domain provides various functionality related to drawing atop the inspected page.
type Overlay struct{ conn *rpcc.Conn }

// NewOverlay returns the domain with the connection set to conn.
func NewOverlay(conn *rpcc.Conn) *Overlay {
	return &Overlay{conn: conn}
}

// Enable invokes the Overlay method. Enables domain notifications.
func (d *Overlay) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.OverlayEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Overlay method. Disables domain notifications.
func (d *Overlay) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.OverlayDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "Disable", Err: err}
	}
	return
}

// SetShowPaintRects invokes the Overlay method. Requests that backend shows paint rectangles
func (d *Overlay) SetShowPaintRects(ctx context.Context, args *cdpcmd.OverlaySetShowPaintRectsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowPaintRects.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowPaintRects.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetShowPaintRects", Err: err}
	}
	return
}

// SetShowDebugBorders invokes the Overlay method. Requests that backend shows debug borders on layers
func (d *Overlay) SetShowDebugBorders(ctx context.Context, args *cdpcmd.OverlaySetShowDebugBordersArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowDebugBorders.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowDebugBorders.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetShowDebugBorders", Err: err}
	}
	return
}

// SetShowFPSCounter invokes the Overlay method. Requests that backend shows the FPS counter
func (d *Overlay) SetShowFPSCounter(ctx context.Context, args *cdpcmd.OverlaySetShowFPSCounterArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowFPSCounter.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowFPSCounter.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetShowFPSCounter", Err: err}
	}
	return
}

// SetShowScrollBottleneckRects invokes the Overlay method. Requests that backend shows scroll bottleneck rects
func (d *Overlay) SetShowScrollBottleneckRects(ctx context.Context, args *cdpcmd.OverlaySetShowScrollBottleneckRectsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowScrollBottleneckRects.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowScrollBottleneckRects.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetShowScrollBottleneckRects", Err: err}
	}
	return
}

// SetShowViewportSizeOnResize invokes the Overlay method. Paints viewport size upon main frame resize.
func (d *Overlay) SetShowViewportSizeOnResize(ctx context.Context, args *cdpcmd.OverlaySetShowViewportSizeOnResizeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowViewportSizeOnResize.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetShowViewportSizeOnResize.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetShowViewportSizeOnResize", Err: err}
	}
	return
}

// SetPausedInDebuggerMessage invokes the Overlay method.
func (d *Overlay) SetPausedInDebuggerMessage(ctx context.Context, args *cdpcmd.OverlaySetPausedInDebuggerMessageArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetPausedInDebuggerMessage.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetPausedInDebuggerMessage.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetPausedInDebuggerMessage", Err: err}
	}
	return
}

// SetSuspended invokes the Overlay method.
func (d *Overlay) SetSuspended(ctx context.Context, args *cdpcmd.OverlaySetSuspendedArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetSuspended.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetSuspended.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetSuspended", Err: err}
	}
	return
}

// SetInspectMode invokes the Overlay method. Enters the 'inspect' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates 'inspectNodeRequested' event upon element selection.
func (d *Overlay) SetInspectMode(ctx context.Context, args *cdpcmd.OverlaySetInspectModeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetInspectMode.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlaySetInspectMode.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "SetInspectMode", Err: err}
	}
	return
}

// HighlightRect invokes the Overlay method. Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport.
func (d *Overlay) HighlightRect(ctx context.Context, args *cdpcmd.OverlayHighlightRectArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightRect.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightRect.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "HighlightRect", Err: err}
	}
	return
}

// HighlightQuad invokes the Overlay method. Highlights given quad. Coordinates are absolute with respect to the main frame viewport.
func (d *Overlay) HighlightQuad(ctx context.Context, args *cdpcmd.OverlayHighlightQuadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightQuad.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightQuad.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "HighlightQuad", Err: err}
	}
	return
}

// HighlightNode invokes the Overlay method. Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified.
func (d *Overlay) HighlightNode(ctx context.Context, args *cdpcmd.OverlayHighlightNodeArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightNode.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightNode.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "HighlightNode", Err: err}
	}
	return
}

// HighlightFrame invokes the Overlay method. Highlights owner element of the frame with given id.
func (d *Overlay) HighlightFrame(ctx context.Context, args *cdpcmd.OverlayHighlightFrameArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightFrame.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayHighlightFrame.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "HighlightFrame", Err: err}
	}
	return
}

// HideHighlight invokes the Overlay method. Hides any highlight.
func (d *Overlay) HideHighlight(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.OverlayHideHighlight.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "HideHighlight", Err: err}
	}
	return
}

// GetHighlightObjectForTest invokes the Overlay method. For testing.
func (d *Overlay) GetHighlightObjectForTest(ctx context.Context, args *cdpcmd.OverlayGetHighlightObjectForTestArgs) (reply *cdpcmd.OverlayGetHighlightObjectForTestReply, err error) {
	reply = new(cdpcmd.OverlayGetHighlightObjectForTestReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayGetHighlightObjectForTest.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.OverlayGetHighlightObjectForTest.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Overlay", Op: "GetHighlightObjectForTest", Err: err}
	}
	return
}

// NodeHighlightRequested creates the event client. Fired when the node should be highlighted. This happens after call to setInspectMode.
func (d *Overlay) NodeHighlightRequested(ctx context.Context) (cdpevent.OverlayNodeHighlightRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.OverlayNodeHighlightRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &OverlayNodeHighlightRequestedClient{Stream: s}, nil
}

// OverlayNodeHighlightRequestedClient implements cdpevent.OverlayNodeHighlightRequestedClient.
type OverlayNodeHighlightRequestedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *OverlayNodeHighlightRequestedClient) Recv() (*cdpevent.OverlayNodeHighlightRequestedReply, error) {
	event := new(cdpevent.OverlayNodeHighlightRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Overlay", Op: "NodeHighlightRequested Recv", Err: err}
	}
	return event, nil
}

// InspectNodeRequested creates the event client. Fired when the node should be inspected. This happens after call to setInspectMode or when user manually inspects an element.
func (d *Overlay) InspectNodeRequested(ctx context.Context) (cdpevent.OverlayInspectNodeRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.OverlayInspectNodeRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &OverlayInspectNodeRequestedClient{Stream: s}, nil
}

// OverlayInspectNodeRequestedClient implements cdpevent.OverlayInspectNodeRequestedClient.
type OverlayInspectNodeRequestedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *OverlayInspectNodeRequestedClient) Recv() (*cdpevent.OverlayInspectNodeRequestedReply, error) {
	event := new(cdpevent.OverlayInspectNodeRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Overlay", Op: "InspectNodeRequested Recv", Err: err}
	}
	return event, nil
}

// The Page domain. Actions and events related to the inspected page belong to the page domain.
type Page struct{ conn *rpcc.Conn }

// NewPage returns the domain with the connection set to conn.
func NewPage(conn *rpcc.Conn) *Page {
	return &Page{conn: conn}
}

// Enable invokes the Page method. Enables page domain notifications.
func (d *Page) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Page method. Disables page domain notifications.
func (d *Page) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "Disable", Err: err}
	}
	return
}

// AddScriptToEvaluateOnLoad invokes the Page method.
func (d *Page) AddScriptToEvaluateOnLoad(ctx context.Context, args *cdpcmd.PageAddScriptToEvaluateOnLoadArgs) (reply *cdpcmd.PageAddScriptToEvaluateOnLoadReply, err error) {
	reply = new(cdpcmd.PageAddScriptToEvaluateOnLoadReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageAddScriptToEvaluateOnLoad.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageAddScriptToEvaluateOnLoad.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "AddScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// RemoveScriptToEvaluateOnLoad invokes the Page method.
func (d *Page) RemoveScriptToEvaluateOnLoad(ctx context.Context, args *cdpcmd.PageRemoveScriptToEvaluateOnLoadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageRemoveScriptToEvaluateOnLoad.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageRemoveScriptToEvaluateOnLoad.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "RemoveScriptToEvaluateOnLoad", Err: err}
	}
	return
}

// SetAutoAttachToCreatedPages invokes the Page method. Controls whether browser will open a new inspector window for connected pages.
func (d *Page) SetAutoAttachToCreatedPages(ctx context.Context, args *cdpcmd.PageSetAutoAttachToCreatedPagesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetAutoAttachToCreatedPages.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetAutoAttachToCreatedPages.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetAutoAttachToCreatedPages", Err: err}
	}
	return
}

// Reload invokes the Page method. Reloads given page optionally ignoring the cache.
func (d *Page) Reload(ctx context.Context, args *cdpcmd.PageReloadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageReload.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageReload.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "Reload", Err: err}
	}
	return
}

// Navigate invokes the Page method. Navigates current page to the given URL.
func (d *Page) Navigate(ctx context.Context, args *cdpcmd.PageNavigateArgs) (reply *cdpcmd.PageNavigateReply, err error) {
	reply = new(cdpcmd.PageNavigateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageNavigate.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageNavigate.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "Navigate", Err: err}
	}
	return
}

// StopLoading invokes the Page method. Force the page stop all navigations and pending resource fetches.
func (d *Page) StopLoading(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageStopLoading.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "StopLoading", Err: err}
	}
	return
}

// GetNavigationHistory invokes the Page method. Returns navigation history for the current page.
func (d *Page) GetNavigationHistory(ctx context.Context) (reply *cdpcmd.PageGetNavigationHistoryReply, err error) {
	reply = new(cdpcmd.PageGetNavigationHistoryReply)
	err = rpcc.Invoke(ctx, cdpcmd.PageGetNavigationHistory.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetNavigationHistory", Err: err}
	}
	return
}

// NavigateToHistoryEntry invokes the Page method. Navigates current page to the given history entry.
func (d *Page) NavigateToHistoryEntry(ctx context.Context, args *cdpcmd.PageNavigateToHistoryEntryArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageNavigateToHistoryEntry.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageNavigateToHistoryEntry.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "NavigateToHistoryEntry", Err: err}
	}
	return
}

// GetCookies invokes the Page method. Returns all browser cookies. Depending on the backend support, will return detailed cookie information in the cookies field.
func (d *Page) GetCookies(ctx context.Context) (reply *cdpcmd.PageGetCookiesReply, err error) {
	reply = new(cdpcmd.PageGetCookiesReply)
	err = rpcc.Invoke(ctx, cdpcmd.PageGetCookies.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetCookies", Err: err}
	}
	return
}

// DeleteCookie invokes the Page method. Deletes browser cookie with given name, domain and path.
func (d *Page) DeleteCookie(ctx context.Context, args *cdpcmd.PageDeleteCookieArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageDeleteCookie.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageDeleteCookie.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "DeleteCookie", Err: err}
	}
	return
}

// GetResourceTree invokes the Page method. Returns present frame / resource tree structure.
func (d *Page) GetResourceTree(ctx context.Context) (reply *cdpcmd.PageGetResourceTreeReply, err error) {
	reply = new(cdpcmd.PageGetResourceTreeReply)
	err = rpcc.Invoke(ctx, cdpcmd.PageGetResourceTree.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetResourceTree", Err: err}
	}
	return
}

// GetResourceContent invokes the Page method. Returns content of the given resource.
func (d *Page) GetResourceContent(ctx context.Context, args *cdpcmd.PageGetResourceContentArgs) (reply *cdpcmd.PageGetResourceContentReply, err error) {
	reply = new(cdpcmd.PageGetResourceContentReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageGetResourceContent.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageGetResourceContent.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetResourceContent", Err: err}
	}
	return
}

// SearchInResource invokes the Page method. Searches for given string in resource content.
func (d *Page) SearchInResource(ctx context.Context, args *cdpcmd.PageSearchInResourceArgs) (reply *cdpcmd.PageSearchInResourceReply, err error) {
	reply = new(cdpcmd.PageSearchInResourceReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSearchInResource.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSearchInResource.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SearchInResource", Err: err}
	}
	return
}

// SetDocumentContent invokes the Page method. Sets given markup as the document's HTML.
func (d *Page) SetDocumentContent(ctx context.Context, args *cdpcmd.PageSetDocumentContentArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDocumentContent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDocumentContent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetDocumentContent", Err: err}
	}
	return
}

// SetDeviceMetricsOverride invokes the Page method. Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and "device-width"/"device-height"-related CSS media query results).
func (d *Page) SetDeviceMetricsOverride(ctx context.Context, args *cdpcmd.PageSetDeviceMetricsOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceMetricsOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceMetricsOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetDeviceMetricsOverride", Err: err}
	}
	return
}

// ClearDeviceMetricsOverride invokes the Page method. Clears the overridden device metrics.
func (d *Page) ClearDeviceMetricsOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageClearDeviceMetricsOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "ClearDeviceMetricsOverride", Err: err}
	}
	return
}

// SetGeolocationOverride invokes the Page method. Overrides the Geolocation Position or Error. Omitting any of the parameters emulates position unavailable.
func (d *Page) SetGeolocationOverride(ctx context.Context, args *cdpcmd.PageSetGeolocationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetGeolocationOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetGeolocationOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetGeolocationOverride", Err: err}
	}
	return
}

// ClearGeolocationOverride invokes the Page method. Clears the overridden Geolocation Position and Error.
func (d *Page) ClearGeolocationOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageClearGeolocationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "ClearGeolocationOverride", Err: err}
	}
	return
}

// SetDeviceOrientationOverride invokes the Page method. Overrides the Device Orientation.
func (d *Page) SetDeviceOrientationOverride(ctx context.Context, args *cdpcmd.PageSetDeviceOrientationOverrideArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceOrientationOverride.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetDeviceOrientationOverride.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetDeviceOrientationOverride", Err: err}
	}
	return
}

// ClearDeviceOrientationOverride invokes the Page method. Clears the overridden Device Orientation.
func (d *Page) ClearDeviceOrientationOverride(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageClearDeviceOrientationOverride.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "ClearDeviceOrientationOverride", Err: err}
	}
	return
}

// SetTouchEmulationEnabled invokes the Page method. Toggles mouse event-based touch event emulation.
func (d *Page) SetTouchEmulationEnabled(ctx context.Context, args *cdpcmd.PageSetTouchEmulationEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetTouchEmulationEnabled.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetTouchEmulationEnabled.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetTouchEmulationEnabled", Err: err}
	}
	return
}

// CaptureScreenshot invokes the Page method. Capture page screenshot.
func (d *Page) CaptureScreenshot(ctx context.Context, args *cdpcmd.PageCaptureScreenshotArgs) (reply *cdpcmd.PageCaptureScreenshotReply, err error) {
	reply = new(cdpcmd.PageCaptureScreenshotReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageCaptureScreenshot.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageCaptureScreenshot.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "CaptureScreenshot", Err: err}
	}
	return
}

// PrintToPDF invokes the Page method. Print page as PDF.
func (d *Page) PrintToPDF(ctx context.Context, args *cdpcmd.PagePrintToPDFArgs) (reply *cdpcmd.PagePrintToPDFReply, err error) {
	reply = new(cdpcmd.PagePrintToPDFReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PagePrintToPDF.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PagePrintToPDF.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "PrintToPDF", Err: err}
	}
	return
}

// StartScreencast invokes the Page method. Starts sending each frame using the screencastFrame event.
func (d *Page) StartScreencast(ctx context.Context, args *cdpcmd.PageStartScreencastArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageStartScreencast.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageStartScreencast.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "StartScreencast", Err: err}
	}
	return
}

// StopScreencast invokes the Page method. Stops sending each frame in the screencastFrame.
func (d *Page) StopScreencast(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageStopScreencast.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "StopScreencast", Err: err}
	}
	return
}

// ScreencastFrameAck invokes the Page method. Acknowledges that a screencast frame has been received by the frontend.
func (d *Page) ScreencastFrameAck(ctx context.Context, args *cdpcmd.PageScreencastFrameAckArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageScreencastFrameAck.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageScreencastFrameAck.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "ScreencastFrameAck", Err: err}
	}
	return
}

// HandleJavaScriptDialog invokes the Page method. Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).
func (d *Page) HandleJavaScriptDialog(ctx context.Context, args *cdpcmd.PageHandleJavaScriptDialogArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageHandleJavaScriptDialog.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageHandleJavaScriptDialog.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "HandleJavaScriptDialog", Err: err}
	}
	return
}

// GetAppManifest invokes the Page method.
func (d *Page) GetAppManifest(ctx context.Context) (reply *cdpcmd.PageGetAppManifestReply, err error) {
	reply = new(cdpcmd.PageGetAppManifestReply)
	err = rpcc.Invoke(ctx, cdpcmd.PageGetAppManifest.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetAppManifest", Err: err}
	}
	return
}

// RequestAppBanner invokes the Page method.
func (d *Page) RequestAppBanner(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.PageRequestAppBanner.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "RequestAppBanner", Err: err}
	}
	return
}

// SetControlNavigations invokes the Page method. Toggles navigation throttling which allows programatic control over navigation and redirect response.
func (d *Page) SetControlNavigations(ctx context.Context, args *cdpcmd.PageSetControlNavigationsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetControlNavigations.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageSetControlNavigations.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "SetControlNavigations", Err: err}
	}
	return
}

// ProcessNavigation invokes the Page method. Should be sent in response to a navigationRequested or a redirectRequested event, telling the browser how to handle the navigation.
func (d *Page) ProcessNavigation(ctx context.Context, args *cdpcmd.PageProcessNavigationArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageProcessNavigation.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageProcessNavigation.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "ProcessNavigation", Err: err}
	}
	return
}

// GetLayoutMetrics invokes the Page method. Returns metrics relating to the layouting of the page, such as viewport bounds/scale.
func (d *Page) GetLayoutMetrics(ctx context.Context) (reply *cdpcmd.PageGetLayoutMetricsReply, err error) {
	reply = new(cdpcmd.PageGetLayoutMetricsReply)
	err = rpcc.Invoke(ctx, cdpcmd.PageGetLayoutMetrics.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Page", Op: "GetLayoutMetrics", Err: err}
	}
	return
}

// CreateIsolatedWorld invokes the Page method. Creates an isolated world for the given frame.
func (d *Page) CreateIsolatedWorld(ctx context.Context, args *cdpcmd.PageCreateIsolatedWorldArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.PageCreateIsolatedWorld.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.PageCreateIsolatedWorld.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Page", Op: "CreateIsolatedWorld", Err: err}
	}
	return
}

// DOMContentEventFired creates the event client.
func (d *Page) DOMContentEventFired(ctx context.Context) (cdpevent.PageDOMContentEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageDOMContentEventFired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageDOMContentEventFiredClient{Stream: s}, nil
}

// PageDOMContentEventFiredClient implements cdpevent.PageDOMContentEventFiredClient.
type PageDOMContentEventFiredClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageDOMContentEventFiredClient) Recv() (*cdpevent.PageDOMContentEventFiredReply, error) {
	event := new(cdpevent.PageDOMContentEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "DOMContentEventFired Recv", Err: err}
	}
	return event, nil
}

// LoadEventFired creates the event client.
func (d *Page) LoadEventFired(ctx context.Context) (cdpevent.PageLoadEventFiredClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageLoadEventFired.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageLoadEventFiredClient{Stream: s}, nil
}

// PageLoadEventFiredClient implements cdpevent.PageLoadEventFiredClient.
type PageLoadEventFiredClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageLoadEventFiredClient) Recv() (*cdpevent.PageLoadEventFiredReply, error) {
	event := new(cdpevent.PageLoadEventFiredReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "LoadEventFired Recv", Err: err}
	}
	return event, nil
}

// FrameAttached creates the event client. Fired when frame has been attached to its parent.
func (d *Page) FrameAttached(ctx context.Context) (cdpevent.PageFrameAttachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameAttached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameAttachedClient{Stream: s}, nil
}

// PageFrameAttachedClient implements cdpevent.PageFrameAttachedClient.
type PageFrameAttachedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameAttachedClient) Recv() (*cdpevent.PageFrameAttachedReply, error) {
	event := new(cdpevent.PageFrameAttachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameAttached Recv", Err: err}
	}
	return event, nil
}

// FrameNavigated creates the event client. Fired once navigation of the frame has completed. Frame is now associated with the new loader.
func (d *Page) FrameNavigated(ctx context.Context) (cdpevent.PageFrameNavigatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameNavigated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameNavigatedClient{Stream: s}, nil
}

// PageFrameNavigatedClient implements cdpevent.PageFrameNavigatedClient.
type PageFrameNavigatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameNavigatedClient) Recv() (*cdpevent.PageFrameNavigatedReply, error) {
	event := new(cdpevent.PageFrameNavigatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameNavigated Recv", Err: err}
	}
	return event, nil
}

// FrameDetached creates the event client. Fired when frame has been detached from its parent.
func (d *Page) FrameDetached(ctx context.Context) (cdpevent.PageFrameDetachedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameDetached.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameDetachedClient{Stream: s}, nil
}

// PageFrameDetachedClient implements cdpevent.PageFrameDetachedClient.
type PageFrameDetachedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameDetachedClient) Recv() (*cdpevent.PageFrameDetachedReply, error) {
	event := new(cdpevent.PageFrameDetachedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameDetached Recv", Err: err}
	}
	return event, nil
}

// FrameStartedLoading creates the event client. Fired when frame has started loading.
func (d *Page) FrameStartedLoading(ctx context.Context) (cdpevent.PageFrameStartedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameStartedLoading.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameStartedLoadingClient{Stream: s}, nil
}

// PageFrameStartedLoadingClient implements cdpevent.PageFrameStartedLoadingClient.
type PageFrameStartedLoadingClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameStartedLoadingClient) Recv() (*cdpevent.PageFrameStartedLoadingReply, error) {
	event := new(cdpevent.PageFrameStartedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameStartedLoading Recv", Err: err}
	}
	return event, nil
}

// FrameStoppedLoading creates the event client. Fired when frame has stopped loading.
func (d *Page) FrameStoppedLoading(ctx context.Context) (cdpevent.PageFrameStoppedLoadingClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameStoppedLoading.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameStoppedLoadingClient{Stream: s}, nil
}

// PageFrameStoppedLoadingClient implements cdpevent.PageFrameStoppedLoadingClient.
type PageFrameStoppedLoadingClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameStoppedLoadingClient) Recv() (*cdpevent.PageFrameStoppedLoadingReply, error) {
	event := new(cdpevent.PageFrameStoppedLoadingReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameStoppedLoading Recv", Err: err}
	}
	return event, nil
}

// FrameScheduledNavigation creates the event client. Fired when frame schedules a potential navigation.
func (d *Page) FrameScheduledNavigation(ctx context.Context) (cdpevent.PageFrameScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameScheduledNavigation.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameScheduledNavigationClient{Stream: s}, nil
}

// PageFrameScheduledNavigationClient implements cdpevent.PageFrameScheduledNavigationClient.
type PageFrameScheduledNavigationClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameScheduledNavigationClient) Recv() (*cdpevent.PageFrameScheduledNavigationReply, error) {
	event := new(cdpevent.PageFrameScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

// FrameClearedScheduledNavigation creates the event client. Fired when frame no longer has a scheduled navigation.
func (d *Page) FrameClearedScheduledNavigation(ctx context.Context) (cdpevent.PageFrameClearedScheduledNavigationClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameClearedScheduledNavigation.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameClearedScheduledNavigationClient{Stream: s}, nil
}

// PageFrameClearedScheduledNavigationClient implements cdpevent.PageFrameClearedScheduledNavigationClient.
type PageFrameClearedScheduledNavigationClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameClearedScheduledNavigationClient) Recv() (*cdpevent.PageFrameClearedScheduledNavigationReply, error) {
	event := new(cdpevent.PageFrameClearedScheduledNavigationReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameClearedScheduledNavigation Recv", Err: err}
	}
	return event, nil
}

// FrameResized creates the event client.
func (d *Page) FrameResized(ctx context.Context) (cdpevent.PageFrameResizedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageFrameResized.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageFrameResizedClient{Stream: s}, nil
}

// PageFrameResizedClient implements cdpevent.PageFrameResizedClient.
type PageFrameResizedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageFrameResizedClient) Recv() (*cdpevent.PageFrameResizedReply, error) {
	event := new(cdpevent.PageFrameResizedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "FrameResized Recv", Err: err}
	}
	return event, nil
}

// JavascriptDialogOpening creates the event client. Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.
func (d *Page) JavascriptDialogOpening(ctx context.Context) (cdpevent.PageJavascriptDialogOpeningClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageJavascriptDialogOpening.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageJavascriptDialogOpeningClient{Stream: s}, nil
}

// PageJavascriptDialogOpeningClient implements cdpevent.PageJavascriptDialogOpeningClient.
type PageJavascriptDialogOpeningClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageJavascriptDialogOpeningClient) Recv() (*cdpevent.PageJavascriptDialogOpeningReply, error) {
	event := new(cdpevent.PageJavascriptDialogOpeningReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "JavascriptDialogOpening Recv", Err: err}
	}
	return event, nil
}

// JavascriptDialogClosed creates the event client. Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.
func (d *Page) JavascriptDialogClosed(ctx context.Context) (cdpevent.PageJavascriptDialogClosedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageJavascriptDialogClosed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageJavascriptDialogClosedClient{Stream: s}, nil
}

// PageJavascriptDialogClosedClient implements cdpevent.PageJavascriptDialogClosedClient.
type PageJavascriptDialogClosedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageJavascriptDialogClosedClient) Recv() (*cdpevent.PageJavascriptDialogClosedReply, error) {
	event := new(cdpevent.PageJavascriptDialogClosedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "JavascriptDialogClosed Recv", Err: err}
	}
	return event, nil
}

// ScreencastFrame creates the event client. Compressed image data requested by the startScreencast.
func (d *Page) ScreencastFrame(ctx context.Context) (cdpevent.PageScreencastFrameClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageScreencastFrame.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageScreencastFrameClient{Stream: s}, nil
}

// PageScreencastFrameClient implements cdpevent.PageScreencastFrameClient.
type PageScreencastFrameClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageScreencastFrameClient) Recv() (*cdpevent.PageScreencastFrameReply, error) {
	event := new(cdpevent.PageScreencastFrameReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "ScreencastFrame Recv", Err: err}
	}
	return event, nil
}

// ScreencastVisibilityChanged creates the event client. Fired when the page with currently enabled screencast was shown or hidden .
func (d *Page) ScreencastVisibilityChanged(ctx context.Context) (cdpevent.PageScreencastVisibilityChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageScreencastVisibilityChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageScreencastVisibilityChangedClient{Stream: s}, nil
}

// PageScreencastVisibilityChangedClient implements cdpevent.PageScreencastVisibilityChangedClient.
type PageScreencastVisibilityChangedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageScreencastVisibilityChangedClient) Recv() (*cdpevent.PageScreencastVisibilityChangedReply, error) {
	event := new(cdpevent.PageScreencastVisibilityChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "ScreencastVisibilityChanged Recv", Err: err}
	}
	return event, nil
}

// InterstitialShown creates the event client. Fired when interstitial page was shown
func (d *Page) InterstitialShown(ctx context.Context) (cdpevent.PageInterstitialShownClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageInterstitialShown.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageInterstitialShownClient{Stream: s}, nil
}

// PageInterstitialShownClient implements cdpevent.PageInterstitialShownClient.
type PageInterstitialShownClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageInterstitialShownClient) Recv() (*cdpevent.PageInterstitialShownReply, error) {
	event := new(cdpevent.PageInterstitialShownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "InterstitialShown Recv", Err: err}
	}
	return event, nil
}

// InterstitialHidden creates the event client. Fired when interstitial page was hidden
func (d *Page) InterstitialHidden(ctx context.Context) (cdpevent.PageInterstitialHiddenClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageInterstitialHidden.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageInterstitialHiddenClient{Stream: s}, nil
}

// PageInterstitialHiddenClient implements cdpevent.PageInterstitialHiddenClient.
type PageInterstitialHiddenClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageInterstitialHiddenClient) Recv() (*cdpevent.PageInterstitialHiddenReply, error) {
	event := new(cdpevent.PageInterstitialHiddenReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "InterstitialHidden Recv", Err: err}
	}
	return event, nil
}

// NavigationRequested creates the event client. Fired when a navigation is started if navigation throttles are enabled.  The navigation will be deferred until processNavigation is called.
func (d *Page) NavigationRequested(ctx context.Context) (cdpevent.PageNavigationRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.PageNavigationRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &PageNavigationRequestedClient{Stream: s}, nil
}

// PageNavigationRequestedClient implements cdpevent.PageNavigationRequestedClient.
type PageNavigationRequestedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *PageNavigationRequestedClient) Recv() (*cdpevent.PageNavigationRequestedReply, error) {
	event := new(cdpevent.PageNavigationRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Page", Op: "NavigationRequested Recv", Err: err}
	}
	return event, nil
}

// The Profiler domain.
type Profiler struct{ conn *rpcc.Conn }

// NewProfiler returns the domain with the connection set to conn.
func NewProfiler(conn *rpcc.Conn) *Profiler {
	return &Profiler{conn: conn}
}

// Enable invokes the Profiler method.
func (d *Profiler) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Profiler method.
func (d *Profiler) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "Disable", Err: err}
	}
	return
}

// SetSamplingInterval invokes the Profiler method. Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
func (d *Profiler) SetSamplingInterval(ctx context.Context, args *cdpcmd.ProfilerSetSamplingIntervalArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ProfilerSetSamplingInterval.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ProfilerSetSamplingInterval.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "SetSamplingInterval", Err: err}
	}
	return
}

// Start invokes the Profiler method.
func (d *Profiler) Start(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStart.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "Start", Err: err}
	}
	return
}

// Stop invokes the Profiler method.
func (d *Profiler) Stop(ctx context.Context) (reply *cdpcmd.ProfilerStopReply, err error) {
	reply = new(cdpcmd.ProfilerStopReply)
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStop.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "Stop", Err: err}
	}
	return
}

// StartPreciseCoverage invokes the Profiler method. Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
func (d *Profiler) StartPreciseCoverage(ctx context.Context, args *cdpcmd.ProfilerStartPreciseCoverageArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ProfilerStartPreciseCoverage.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ProfilerStartPreciseCoverage.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "StartPreciseCoverage", Err: err}
	}
	return
}

// StopPreciseCoverage invokes the Profiler method. Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
func (d *Profiler) StopPreciseCoverage(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerStopPreciseCoverage.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "StopPreciseCoverage", Err: err}
	}
	return
}

// TakePreciseCoverage invokes the Profiler method. Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
func (d *Profiler) TakePreciseCoverage(ctx context.Context) (reply *cdpcmd.ProfilerTakePreciseCoverageReply, err error) {
	reply = new(cdpcmd.ProfilerTakePreciseCoverageReply)
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerTakePreciseCoverage.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "TakePreciseCoverage", Err: err}
	}
	return
}

// GetBestEffortCoverage invokes the Profiler method. Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
func (d *Profiler) GetBestEffortCoverage(ctx context.Context) (reply *cdpcmd.ProfilerGetBestEffortCoverageReply, err error) {
	reply = new(cdpcmd.ProfilerGetBestEffortCoverageReply)
	err = rpcc.Invoke(ctx, cdpcmd.ProfilerGetBestEffortCoverage.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Profiler", Op: "GetBestEffortCoverage", Err: err}
	}
	return
}

// ConsoleProfileStarted creates the event client. Sent when new profile recording is started using console.profile() call.
func (d *Profiler) ConsoleProfileStarted(ctx context.Context) (cdpevent.ProfilerConsoleProfileStartedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ProfilerConsoleProfileStarted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ProfilerConsoleProfileStartedClient{Stream: s}, nil
}

// ProfilerConsoleProfileStartedClient implements cdpevent.ProfilerConsoleProfileStartedClient.
type ProfilerConsoleProfileStartedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ProfilerConsoleProfileStartedClient) Recv() (*cdpevent.ProfilerConsoleProfileStartedReply, error) {
	event := new(cdpevent.ProfilerConsoleProfileStartedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Profiler", Op: "ConsoleProfileStarted Recv", Err: err}
	}
	return event, nil
}

// ConsoleProfileFinished creates the event client.
func (d *Profiler) ConsoleProfileFinished(ctx context.Context) (cdpevent.ProfilerConsoleProfileFinishedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ProfilerConsoleProfileFinished.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ProfilerConsoleProfileFinishedClient{Stream: s}, nil
}

// ProfilerConsoleProfileFinishedClient implements cdpevent.ProfilerConsoleProfileFinishedClient.
type ProfilerConsoleProfileFinishedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ProfilerConsoleProfileFinishedClient) Recv() (*cdpevent.ProfilerConsoleProfileFinishedReply, error) {
	event := new(cdpevent.ProfilerConsoleProfileFinishedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Profiler", Op: "ConsoleProfileFinished Recv", Err: err}
	}
	return event, nil
}

// The Runtime domain. Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.
type Runtime struct{ conn *rpcc.Conn }

// NewRuntime returns the domain with the connection set to conn.
func NewRuntime(conn *rpcc.Conn) *Runtime {
	return &Runtime{conn: conn}
}

// Evaluate invokes the Runtime method. Evaluates expression on global object.
func (d *Runtime) Evaluate(ctx context.Context, args *cdpcmd.RuntimeEvaluateArgs) (reply *cdpcmd.RuntimeEvaluateReply, err error) {
	reply = new(cdpcmd.RuntimeEvaluateReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeEvaluate.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeEvaluate.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "Evaluate", Err: err}
	}
	return
}

// AwaitPromise invokes the Runtime method. Add handler to promise with given promise object id.
func (d *Runtime) AwaitPromise(ctx context.Context, args *cdpcmd.RuntimeAwaitPromiseArgs) (reply *cdpcmd.RuntimeAwaitPromiseReply, err error) {
	reply = new(cdpcmd.RuntimeAwaitPromiseReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeAwaitPromise.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeAwaitPromise.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "AwaitPromise", Err: err}
	}
	return
}

// CallFunctionOn invokes the Runtime method. Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
func (d *Runtime) CallFunctionOn(ctx context.Context, args *cdpcmd.RuntimeCallFunctionOnArgs) (reply *cdpcmd.RuntimeCallFunctionOnReply, err error) {
	reply = new(cdpcmd.RuntimeCallFunctionOnReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeCallFunctionOn.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeCallFunctionOn.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "CallFunctionOn", Err: err}
	}
	return
}

// GetProperties invokes the Runtime method. Returns properties of a given object. Object group of the result is inherited from the target object.
func (d *Runtime) GetProperties(ctx context.Context, args *cdpcmd.RuntimeGetPropertiesArgs) (reply *cdpcmd.RuntimeGetPropertiesReply, err error) {
	reply = new(cdpcmd.RuntimeGetPropertiesReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeGetProperties.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeGetProperties.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "GetProperties", Err: err}
	}
	return
}

// ReleaseObject invokes the Runtime method. Releases remote object with given id.
func (d *Runtime) ReleaseObject(ctx context.Context, args *cdpcmd.RuntimeReleaseObjectArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObject.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObject.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "ReleaseObject", Err: err}
	}
	return
}

// ReleaseObjectGroup invokes the Runtime method. Releases all remote objects that belong to a given group.
func (d *Runtime) ReleaseObjectGroup(ctx context.Context, args *cdpcmd.RuntimeReleaseObjectGroupArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObjectGroup.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeReleaseObjectGroup.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "ReleaseObjectGroup", Err: err}
	}
	return
}

// RunIfWaitingForDebugger invokes the Runtime method. Tells inspected instance to run if it was waiting for debugger to attach.
func (d *Runtime) RunIfWaitingForDebugger(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.RuntimeRunIfWaitingForDebugger.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "RunIfWaitingForDebugger", Err: err}
	}
	return
}

// Enable invokes the Runtime method. Enables reporting of execution contexts creation by means of executionContextCreated event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
func (d *Runtime) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.RuntimeEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Runtime method. Disables reporting of execution contexts creation.
func (d *Runtime) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.RuntimeDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "Disable", Err: err}
	}
	return
}

// DiscardConsoleEntries invokes the Runtime method. Discards collected exceptions and console API calls.
func (d *Runtime) DiscardConsoleEntries(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.RuntimeDiscardConsoleEntries.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "DiscardConsoleEntries", Err: err}
	}
	return
}

// SetCustomObjectFormatterEnabled invokes the Runtime method.
func (d *Runtime) SetCustomObjectFormatterEnabled(ctx context.Context, args *cdpcmd.RuntimeSetCustomObjectFormatterEnabledArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeSetCustomObjectFormatterEnabled.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeSetCustomObjectFormatterEnabled.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "SetCustomObjectFormatterEnabled", Err: err}
	}
	return
}

// CompileScript invokes the Runtime method. Compiles expression.
func (d *Runtime) CompileScript(ctx context.Context, args *cdpcmd.RuntimeCompileScriptArgs) (reply *cdpcmd.RuntimeCompileScriptReply, err error) {
	reply = new(cdpcmd.RuntimeCompileScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeCompileScript.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeCompileScript.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "CompileScript", Err: err}
	}
	return
}

// RunScript invokes the Runtime method. Runs script with given id in a given context.
func (d *Runtime) RunScript(ctx context.Context, args *cdpcmd.RuntimeRunScriptArgs) (reply *cdpcmd.RuntimeRunScriptReply, err error) {
	reply = new(cdpcmd.RuntimeRunScriptReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeRunScript.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.RuntimeRunScript.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Runtime", Op: "RunScript", Err: err}
	}
	return
}

// ExecutionContextCreated creates the event client. Issued when new execution context is created.
func (d *Runtime) ExecutionContextCreated(ctx context.Context) (cdpevent.RuntimeExecutionContextCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeExecutionContextCreatedClient{Stream: s}, nil
}

// RuntimeExecutionContextCreatedClient implements cdpevent.RuntimeExecutionContextCreatedClient.
type RuntimeExecutionContextCreatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeExecutionContextCreatedClient) Recv() (*cdpevent.RuntimeExecutionContextCreatedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ExecutionContextCreated Recv", Err: err}
	}
	return event, nil
}

// ExecutionContextDestroyed creates the event client. Issued when execution context is destroyed.
func (d *Runtime) ExecutionContextDestroyed(ctx context.Context) (cdpevent.RuntimeExecutionContextDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextDestroyed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeExecutionContextDestroyedClient{Stream: s}, nil
}

// RuntimeExecutionContextDestroyedClient implements cdpevent.RuntimeExecutionContextDestroyedClient.
type RuntimeExecutionContextDestroyedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeExecutionContextDestroyedClient) Recv() (*cdpevent.RuntimeExecutionContextDestroyedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ExecutionContextDestroyed Recv", Err: err}
	}
	return event, nil
}

// ExecutionContextsCleared creates the event client. Issued when all executionContexts were cleared in browser
func (d *Runtime) ExecutionContextsCleared(ctx context.Context) (cdpevent.RuntimeExecutionContextsClearedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExecutionContextsCleared.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeExecutionContextsClearedClient{Stream: s}, nil
}

// RuntimeExecutionContextsClearedClient implements cdpevent.RuntimeExecutionContextsClearedClient.
type RuntimeExecutionContextsClearedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeExecutionContextsClearedClient) Recv() (*cdpevent.RuntimeExecutionContextsClearedReply, error) {
	event := new(cdpevent.RuntimeExecutionContextsClearedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ExecutionContextsCleared Recv", Err: err}
	}
	return event, nil
}

// ExceptionThrown creates the event client. Issued when exception was thrown and unhandled.
func (d *Runtime) ExceptionThrown(ctx context.Context) (cdpevent.RuntimeExceptionThrownClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExceptionThrown.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeExceptionThrownClient{Stream: s}, nil
}

// RuntimeExceptionThrownClient implements cdpevent.RuntimeExceptionThrownClient.
type RuntimeExceptionThrownClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeExceptionThrownClient) Recv() (*cdpevent.RuntimeExceptionThrownReply, error) {
	event := new(cdpevent.RuntimeExceptionThrownReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ExceptionThrown Recv", Err: err}
	}
	return event, nil
}

// ExceptionRevoked creates the event client. Issued when unhandled exception was revoked.
func (d *Runtime) ExceptionRevoked(ctx context.Context) (cdpevent.RuntimeExceptionRevokedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeExceptionRevoked.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeExceptionRevokedClient{Stream: s}, nil
}

// RuntimeExceptionRevokedClient implements cdpevent.RuntimeExceptionRevokedClient.
type RuntimeExceptionRevokedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeExceptionRevokedClient) Recv() (*cdpevent.RuntimeExceptionRevokedReply, error) {
	event := new(cdpevent.RuntimeExceptionRevokedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ExceptionRevoked Recv", Err: err}
	}
	return event, nil
}

// ConsoleAPICalled creates the event client. Issued when console API was called.
func (d *Runtime) ConsoleAPICalled(ctx context.Context) (cdpevent.RuntimeConsoleAPICalledClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeConsoleAPICalled.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeConsoleAPICalledClient{Stream: s}, nil
}

// RuntimeConsoleAPICalledClient implements cdpevent.RuntimeConsoleAPICalledClient.
type RuntimeConsoleAPICalledClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeConsoleAPICalledClient) Recv() (*cdpevent.RuntimeConsoleAPICalledReply, error) {
	event := new(cdpevent.RuntimeConsoleAPICalledReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "ConsoleAPICalled Recv", Err: err}
	}
	return event, nil
}

// InspectRequested creates the event client. Issued when object should be inspected (for example, as a result of inspect() command line API call).
func (d *Runtime) InspectRequested(ctx context.Context) (cdpevent.RuntimeInspectRequestedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.RuntimeInspectRequested.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &RuntimeInspectRequestedClient{Stream: s}, nil
}

// RuntimeInspectRequestedClient implements cdpevent.RuntimeInspectRequestedClient.
type RuntimeInspectRequestedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *RuntimeInspectRequestedClient) Recv() (*cdpevent.RuntimeInspectRequestedReply, error) {
	event := new(cdpevent.RuntimeInspectRequestedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Runtime", Op: "InspectRequested Recv", Err: err}
	}
	return event, nil
}

// The Schema domain. Provides information about the protocol schema.
type Schema struct{ conn *rpcc.Conn }

// NewSchema returns the domain with the connection set to conn.
func NewSchema(conn *rpcc.Conn) *Schema {
	return &Schema{conn: conn}
}

// GetDomains invokes the Schema method. Returns supported domains.
func (d *Schema) GetDomains(ctx context.Context) (reply *cdpcmd.SchemaGetDomainsReply, err error) {
	reply = new(cdpcmd.SchemaGetDomainsReply)
	err = rpcc.Invoke(ctx, cdpcmd.SchemaGetDomains.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Schema", Op: "GetDomains", Err: err}
	}
	return
}

// The Security domain. Security
type Security struct{ conn *rpcc.Conn }

// NewSecurity returns the domain with the connection set to conn.
func NewSecurity(conn *rpcc.Conn) *Security {
	return &Security{conn: conn}
}

// Enable invokes the Security method. Enables tracking security state changes.
func (d *Security) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.SecurityEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Security", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the Security method. Disables tracking security state changes.
func (d *Security) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.SecurityDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Security", Op: "Disable", Err: err}
	}
	return
}

// ShowCertificateViewer invokes the Security method. Displays native dialog with the certificate details.
func (d *Security) ShowCertificateViewer(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.SecurityShowCertificateViewer.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Security", Op: "ShowCertificateViewer", Err: err}
	}
	return
}

// HandleCertificateError invokes the Security method. Handles a certificate error that fired a certificateError event.
func (d *Security) HandleCertificateError(ctx context.Context, args *cdpcmd.SecurityHandleCertificateErrorArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.SecurityHandleCertificateError.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.SecurityHandleCertificateError.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Security", Op: "HandleCertificateError", Err: err}
	}
	return
}

// SetOverrideCertificateErrors invokes the Security method. Enable/disable overriding certificate errors. If enabled, all certificate error events need to be handled by the DevTools client and should be answered with handleCertificateError commands.
func (d *Security) SetOverrideCertificateErrors(ctx context.Context, args *cdpcmd.SecuritySetOverrideCertificateErrorsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.SecuritySetOverrideCertificateErrors.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.SecuritySetOverrideCertificateErrors.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Security", Op: "SetOverrideCertificateErrors", Err: err}
	}
	return
}

// SecurityStateChanged creates the event client. The security state of the page changed.
func (d *Security) SecurityStateChanged(ctx context.Context) (cdpevent.SecurityStateChangedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.SecurityStateChanged.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &SecurityStateChangedClient{Stream: s}, nil
}

// SecurityStateChangedClient implements cdpevent.SecurityStateChangedClient.
type SecurityStateChangedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *SecurityStateChangedClient) Recv() (*cdpevent.SecurityStateChangedReply, error) {
	event := new(cdpevent.SecurityStateChangedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Security", Op: "SecurityStateChanged Recv", Err: err}
	}
	return event, nil
}

// CertificateError creates the event client. There is a certificate error. If overriding certificate errors is enabled, then it should be handled with the handleCertificateError command. Note: this event does not fire if the certificate error has been allowed internally.
func (d *Security) CertificateError(ctx context.Context) (cdpevent.SecurityCertificateErrorClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.SecurityCertificateError.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &SecurityCertificateErrorClient{Stream: s}, nil
}

// SecurityCertificateErrorClient implements cdpevent.SecurityCertificateErrorClient.
type SecurityCertificateErrorClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *SecurityCertificateErrorClient) Recv() (*cdpevent.SecurityCertificateErrorReply, error) {
	event := new(cdpevent.SecurityCertificateErrorReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Security", Op: "CertificateError Recv", Err: err}
	}
	return event, nil
}

// The ServiceWorker domain.
type ServiceWorker struct{ conn *rpcc.Conn }

// NewServiceWorker returns the domain with the connection set to conn.
func NewServiceWorker(conn *rpcc.Conn) *ServiceWorker {
	return &ServiceWorker{conn: conn}
}

// Enable invokes the ServiceWorker method.
func (d *ServiceWorker) Enable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerEnable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "Enable", Err: err}
	}
	return
}

// Disable invokes the ServiceWorker method.
func (d *ServiceWorker) Disable(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDisable.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "Disable", Err: err}
	}
	return
}

// Unregister invokes the ServiceWorker method.
func (d *ServiceWorker) Unregister(ctx context.Context, args *cdpcmd.ServiceWorkerUnregisterArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUnregister.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUnregister.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "Unregister", Err: err}
	}
	return
}

// UpdateRegistration invokes the ServiceWorker method.
func (d *ServiceWorker) UpdateRegistration(ctx context.Context, args *cdpcmd.ServiceWorkerUpdateRegistrationArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUpdateRegistration.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerUpdateRegistration.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "UpdateRegistration", Err: err}
	}
	return
}

// StartWorker invokes the ServiceWorker method.
func (d *ServiceWorker) StartWorker(ctx context.Context, args *cdpcmd.ServiceWorkerStartWorkerArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStartWorker.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStartWorker.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "StartWorker", Err: err}
	}
	return
}

// SkipWaiting invokes the ServiceWorker method.
func (d *ServiceWorker) SkipWaiting(ctx context.Context, args *cdpcmd.ServiceWorkerSkipWaitingArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSkipWaiting.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSkipWaiting.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "SkipWaiting", Err: err}
	}
	return
}

// StopWorker invokes the ServiceWorker method.
func (d *ServiceWorker) StopWorker(ctx context.Context, args *cdpcmd.ServiceWorkerStopWorkerArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStopWorker.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerStopWorker.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "StopWorker", Err: err}
	}
	return
}

// InspectWorker invokes the ServiceWorker method.
func (d *ServiceWorker) InspectWorker(ctx context.Context, args *cdpcmd.ServiceWorkerInspectWorkerArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerInspectWorker.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerInspectWorker.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "InspectWorker", Err: err}
	}
	return
}

// SetForceUpdateOnPageLoad invokes the ServiceWorker method.
func (d *ServiceWorker) SetForceUpdateOnPageLoad(ctx context.Context, args *cdpcmd.ServiceWorkerSetForceUpdateOnPageLoadArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSetForceUpdateOnPageLoad.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerSetForceUpdateOnPageLoad.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "SetForceUpdateOnPageLoad", Err: err}
	}
	return
}

// DeliverPushMessage invokes the ServiceWorker method.
func (d *ServiceWorker) DeliverPushMessage(ctx context.Context, args *cdpcmd.ServiceWorkerDeliverPushMessageArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDeliverPushMessage.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDeliverPushMessage.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "DeliverPushMessage", Err: err}
	}
	return
}

// DispatchSyncEvent invokes the ServiceWorker method.
func (d *ServiceWorker) DispatchSyncEvent(ctx context.Context, args *cdpcmd.ServiceWorkerDispatchSyncEventArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDispatchSyncEvent.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.ServiceWorkerDispatchSyncEvent.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "ServiceWorker", Op: "DispatchSyncEvent", Err: err}
	}
	return
}

// WorkerRegistrationUpdated creates the event client.
func (d *ServiceWorker) WorkerRegistrationUpdated(ctx context.Context) (cdpevent.ServiceWorkerWorkerRegistrationUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerRegistrationUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ServiceWorkerWorkerRegistrationUpdatedClient{Stream: s}, nil
}

// ServiceWorkerWorkerRegistrationUpdatedClient implements cdpevent.ServiceWorkerWorkerRegistrationUpdatedClient.
type ServiceWorkerWorkerRegistrationUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ServiceWorkerWorkerRegistrationUpdatedClient) Recv() (*cdpevent.ServiceWorkerWorkerRegistrationUpdatedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerRegistrationUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "ServiceWorker", Op: "WorkerRegistrationUpdated Recv", Err: err}
	}
	return event, nil
}

// WorkerVersionUpdated creates the event client.
func (d *ServiceWorker) WorkerVersionUpdated(ctx context.Context) (cdpevent.ServiceWorkerWorkerVersionUpdatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerVersionUpdated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ServiceWorkerWorkerVersionUpdatedClient{Stream: s}, nil
}

// ServiceWorkerWorkerVersionUpdatedClient implements cdpevent.ServiceWorkerWorkerVersionUpdatedClient.
type ServiceWorkerWorkerVersionUpdatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ServiceWorkerWorkerVersionUpdatedClient) Recv() (*cdpevent.ServiceWorkerWorkerVersionUpdatedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerVersionUpdatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "ServiceWorker", Op: "WorkerVersionUpdated Recv", Err: err}
	}
	return event, nil
}

// WorkerErrorReported creates the event client.
func (d *ServiceWorker) WorkerErrorReported(ctx context.Context) (cdpevent.ServiceWorkerWorkerErrorReportedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.ServiceWorkerWorkerErrorReported.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &ServiceWorkerWorkerErrorReportedClient{Stream: s}, nil
}

// ServiceWorkerWorkerErrorReportedClient implements cdpevent.ServiceWorkerWorkerErrorReportedClient.
type ServiceWorkerWorkerErrorReportedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *ServiceWorkerWorkerErrorReportedClient) Recv() (*cdpevent.ServiceWorkerWorkerErrorReportedReply, error) {
	event := new(cdpevent.ServiceWorkerWorkerErrorReportedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "ServiceWorker", Op: "WorkerErrorReported Recv", Err: err}
	}
	return event, nil
}

// The Storage domain.
type Storage struct{ conn *rpcc.Conn }

// NewStorage returns the domain with the connection set to conn.
func NewStorage(conn *rpcc.Conn) *Storage {
	return &Storage{conn: conn}
}

// ClearDataForOrigin invokes the Storage method. Clears storage for origin.
func (d *Storage) ClearDataForOrigin(ctx context.Context, args *cdpcmd.StorageClearDataForOriginArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.StorageClearDataForOrigin.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.StorageClearDataForOrigin.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Storage", Op: "ClearDataForOrigin", Err: err}
	}
	return
}

// The SystemInfo domain. The SystemInfo domain defines methods and events for querying low-level system information.
type SystemInfo struct{ conn *rpcc.Conn }

// NewSystemInfo returns the domain with the connection set to conn.
func NewSystemInfo(conn *rpcc.Conn) *SystemInfo {
	return &SystemInfo{conn: conn}
}

// GetInfo invokes the SystemInfo method. Returns information about the system.
func (d *SystemInfo) GetInfo(ctx context.Context) (reply *cdpcmd.SystemInfoGetInfoReply, err error) {
	reply = new(cdpcmd.SystemInfoGetInfoReply)
	err = rpcc.Invoke(ctx, cdpcmd.SystemInfoGetInfo.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "SystemInfo", Op: "GetInfo", Err: err}
	}
	return
}

// The Target domain. Supports additional targets discovery and allows to attach to them.
type Target struct{ conn *rpcc.Conn }

// NewTarget returns the domain with the connection set to conn.
func NewTarget(conn *rpcc.Conn) *Target {
	return &Target{conn: conn}
}

// SetDiscoverTargets invokes the Target method. Controls whether to discover available targets and notify via targetCreated/targetDestroyed events.
func (d *Target) SetDiscoverTargets(ctx context.Context, args *cdpcmd.TargetSetDiscoverTargetsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetDiscoverTargets.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetDiscoverTargets.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "SetDiscoverTargets", Err: err}
	}
	return
}

// SetAutoAttach invokes the Target method. Controls whether to automatically attach to new targets which are considered to be related to this one. When turned on, attaches to all existing related targets as well. When turned off, automatically detaches from all currently attached targets.
func (d *Target) SetAutoAttach(ctx context.Context, args *cdpcmd.TargetSetAutoAttachArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetAutoAttach.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetAutoAttach.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "SetAutoAttach", Err: err}
	}
	return
}

// SetAttachToFrames invokes the Target method.
func (d *Target) SetAttachToFrames(ctx context.Context, args *cdpcmd.TargetSetAttachToFramesArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetAttachToFrames.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetAttachToFrames.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "SetAttachToFrames", Err: err}
	}
	return
}

// SetRemoteLocations invokes the Target method. Enables target discovery for the specified locations, when setDiscoverTargets was set to true.
func (d *Target) SetRemoteLocations(ctx context.Context, args *cdpcmd.TargetSetRemoteLocationsArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetRemoteLocations.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSetRemoteLocations.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "SetRemoteLocations", Err: err}
	}
	return
}

// SendMessageToTarget invokes the Target method. Sends protocol message to the target with given id.
func (d *Target) SendMessageToTarget(ctx context.Context, args *cdpcmd.TargetSendMessageToTargetArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSendMessageToTarget.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetSendMessageToTarget.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "SendMessageToTarget", Err: err}
	}
	return
}

// GetTargetInfo invokes the Target method. Returns information about a target.
func (d *Target) GetTargetInfo(ctx context.Context, args *cdpcmd.TargetGetTargetInfoArgs) (reply *cdpcmd.TargetGetTargetInfoReply, err error) {
	reply = new(cdpcmd.TargetGetTargetInfoReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetGetTargetInfo.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetGetTargetInfo.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "GetTargetInfo", Err: err}
	}
	return
}

// ActivateTarget invokes the Target method. Activates (focuses) the target.
func (d *Target) ActivateTarget(ctx context.Context, args *cdpcmd.TargetActivateTargetArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetActivateTarget.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetActivateTarget.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "ActivateTarget", Err: err}
	}
	return
}

// CloseTarget invokes the Target method. Closes the target. If the target is a page that gets closed too.
func (d *Target) CloseTarget(ctx context.Context, args *cdpcmd.TargetCloseTargetArgs) (reply *cdpcmd.TargetCloseTargetReply, err error) {
	reply = new(cdpcmd.TargetCloseTargetReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetCloseTarget.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetCloseTarget.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "CloseTarget", Err: err}
	}
	return
}

// AttachToTarget invokes the Target method. Attaches to the target with given id.
func (d *Target) AttachToTarget(ctx context.Context, args *cdpcmd.TargetAttachToTargetArgs) (reply *cdpcmd.TargetAttachToTargetReply, err error) {
	reply = new(cdpcmd.TargetAttachToTargetReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetAttachToTarget.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetAttachToTarget.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "AttachToTarget", Err: err}
	}
	return
}

// DetachFromTarget invokes the Target method. Detaches from the target with given id.
func (d *Target) DetachFromTarget(ctx context.Context, args *cdpcmd.TargetDetachFromTargetArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetDetachFromTarget.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetDetachFromTarget.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "DetachFromTarget", Err: err}
	}
	return
}

// CreateBrowserContext invokes the Target method. Creates a new empty BrowserContext. Similar to an incognito profile but you can have more than one.
func (d *Target) CreateBrowserContext(ctx context.Context) (reply *cdpcmd.TargetCreateBrowserContextReply, err error) {
	reply = new(cdpcmd.TargetCreateBrowserContextReply)
	err = rpcc.Invoke(ctx, cdpcmd.TargetCreateBrowserContext.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Target", Op: "CreateBrowserContext", Err: err}
	}
	return
}

// DisposeBrowserContext invokes the Target method. Deletes a BrowserContext, will fail of any open page uses it.
func (d *Target) DisposeBrowserContext(ctx context.Context, args *cdpcmd.TargetDisposeBrowserContextArgs) (reply *cdpcmd.TargetDisposeBrowserContextReply, err error) {
	reply = new(cdpcmd.TargetDisposeBrowserContextReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetDisposeBrowserContext.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetDisposeBrowserContext.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "DisposeBrowserContext", Err: err}
	}
	return
}

// CreateTarget invokes the Target method. Creates a new page.
func (d *Target) CreateTarget(ctx context.Context, args *cdpcmd.TargetCreateTargetArgs) (reply *cdpcmd.TargetCreateTargetReply, err error) {
	reply = new(cdpcmd.TargetCreateTargetReply)
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TargetCreateTarget.String(), args, reply, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TargetCreateTarget.String(), nil, reply, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Target", Op: "CreateTarget", Err: err}
	}
	return
}

// GetTargets invokes the Target method. Retrieves a list of available targets.
func (d *Target) GetTargets(ctx context.Context) (reply *cdpcmd.TargetGetTargetsReply, err error) {
	reply = new(cdpcmd.TargetGetTargetsReply)
	err = rpcc.Invoke(ctx, cdpcmd.TargetGetTargets.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Target", Op: "GetTargets", Err: err}
	}
	return
}

// TargetCreated creates the event client. Issued when a possible inspection target is created.
func (d *Target) TargetCreated(ctx context.Context) (cdpevent.TargetCreatedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetCreated.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TargetCreatedClient{Stream: s}, nil
}

// TargetCreatedClient implements cdpevent.TargetCreatedClient.
type TargetCreatedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TargetCreatedClient) Recv() (*cdpevent.TargetCreatedReply, error) {
	event := new(cdpevent.TargetCreatedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Target", Op: "TargetCreated Recv", Err: err}
	}
	return event, nil
}

// TargetDestroyed creates the event client. Issued when a target is destroyed.
func (d *Target) TargetDestroyed(ctx context.Context) (cdpevent.TargetDestroyedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetDestroyed.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TargetDestroyedClient{Stream: s}, nil
}

// TargetDestroyedClient implements cdpevent.TargetDestroyedClient.
type TargetDestroyedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TargetDestroyedClient) Recv() (*cdpevent.TargetDestroyedReply, error) {
	event := new(cdpevent.TargetDestroyedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Target", Op: "TargetDestroyed Recv", Err: err}
	}
	return event, nil
}

// AttachedToTarget creates the event client. Issued when attached to target because of auto-attach or attachToTarget command.
func (d *Target) AttachedToTarget(ctx context.Context) (cdpevent.TargetAttachedToTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetAttachedToTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TargetAttachedToTargetClient{Stream: s}, nil
}

// TargetAttachedToTargetClient implements cdpevent.TargetAttachedToTargetClient.
type TargetAttachedToTargetClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TargetAttachedToTargetClient) Recv() (*cdpevent.TargetAttachedToTargetReply, error) {
	event := new(cdpevent.TargetAttachedToTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Target", Op: "AttachedToTarget Recv", Err: err}
	}
	return event, nil
}

// DetachedFromTarget creates the event client. Issued when detached from target for any reason (including detachFromTarget command).
func (d *Target) DetachedFromTarget(ctx context.Context) (cdpevent.TargetDetachedFromTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetDetachedFromTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TargetDetachedFromTargetClient{Stream: s}, nil
}

// TargetDetachedFromTargetClient implements cdpevent.TargetDetachedFromTargetClient.
type TargetDetachedFromTargetClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TargetDetachedFromTargetClient) Recv() (*cdpevent.TargetDetachedFromTargetReply, error) {
	event := new(cdpevent.TargetDetachedFromTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Target", Op: "DetachedFromTarget Recv", Err: err}
	}
	return event, nil
}

// ReceivedMessageFromTarget creates the event client. Notifies about new protocol message from attached target.
func (d *Target) ReceivedMessageFromTarget(ctx context.Context) (cdpevent.TargetReceivedMessageFromTargetClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TargetReceivedMessageFromTarget.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TargetReceivedMessageFromTargetClient{Stream: s}, nil
}

// TargetReceivedMessageFromTargetClient implements cdpevent.TargetReceivedMessageFromTargetClient.
type TargetReceivedMessageFromTargetClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TargetReceivedMessageFromTargetClient) Recv() (*cdpevent.TargetReceivedMessageFromTargetReply, error) {
	event := new(cdpevent.TargetReceivedMessageFromTargetReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Target", Op: "ReceivedMessageFromTarget Recv", Err: err}
	}
	return event, nil
}

// The Tethering domain. The Tethering domain defines methods and events for browser port binding.
type Tethering struct{ conn *rpcc.Conn }

// NewTethering returns the domain with the connection set to conn.
func NewTethering(conn *rpcc.Conn) *Tethering {
	return &Tethering{conn: conn}
}

// Bind invokes the Tethering method. Request browser port binding.
func (d *Tethering) Bind(ctx context.Context, args *cdpcmd.TetheringBindArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TetheringBind.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TetheringBind.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Tethering", Op: "Bind", Err: err}
	}
	return
}

// Unbind invokes the Tethering method. Request browser port unbinding.
func (d *Tethering) Unbind(ctx context.Context, args *cdpcmd.TetheringUnbindArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TetheringUnbind.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TetheringUnbind.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Tethering", Op: "Unbind", Err: err}
	}
	return
}

// Accepted creates the event client. Informs that port was successfully bound and got a specified connection id.
func (d *Tethering) Accepted(ctx context.Context) (cdpevent.TetheringAcceptedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TetheringAccepted.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TetheringAcceptedClient{Stream: s}, nil
}

// TetheringAcceptedClient implements cdpevent.TetheringAcceptedClient.
type TetheringAcceptedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TetheringAcceptedClient) Recv() (*cdpevent.TetheringAcceptedReply, error) {
	event := new(cdpevent.TetheringAcceptedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Tethering", Op: "Accepted Recv", Err: err}
	}
	return event, nil
}

// The Tracing domain.
type Tracing struct{ conn *rpcc.Conn }

// NewTracing returns the domain with the connection set to conn.
func NewTracing(conn *rpcc.Conn) *Tracing {
	return &Tracing{conn: conn}
}

// Start invokes the Tracing method. Start trace events collection.
func (d *Tracing) Start(ctx context.Context, args *cdpcmd.TracingStartArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TracingStart.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TracingStart.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Tracing", Op: "Start", Err: err}
	}
	return
}

// End invokes the Tracing method. Stop trace events collection.
func (d *Tracing) End(ctx context.Context) (err error) {
	err = rpcc.Invoke(ctx, cdpcmd.TracingEnd.String(), nil, nil, d.conn)
	if err != nil {
		err = &opError{Domain: "Tracing", Op: "End", Err: err}
	}
	return
}

// GetCategories invokes the Tracing method. Gets supported tracing categories.
func (d *Tracing) GetCategories(ctx context.Context) (reply *cdpcmd.TracingGetCategoriesReply, err error) {
	reply = new(cdpcmd.TracingGetCategoriesReply)
	err = rpcc.Invoke(ctx, cdpcmd.TracingGetCategories.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Tracing", Op: "GetCategories", Err: err}
	}
	return
}

// RequestMemoryDump invokes the Tracing method. Request a global memory dump.
func (d *Tracing) RequestMemoryDump(ctx context.Context) (reply *cdpcmd.TracingRequestMemoryDumpReply, err error) {
	reply = new(cdpcmd.TracingRequestMemoryDumpReply)
	err = rpcc.Invoke(ctx, cdpcmd.TracingRequestMemoryDump.String(), nil, reply, d.conn)
	if err != nil {
		err = &opError{Domain: "Tracing", Op: "RequestMemoryDump", Err: err}
	}
	return
}

// RecordClockSyncMarker invokes the Tracing method. Record a clock sync marker in the trace.
func (d *Tracing) RecordClockSyncMarker(ctx context.Context, args *cdpcmd.TracingRecordClockSyncMarkerArgs) (err error) {
	if args != nil {
		err = rpcc.Invoke(ctx, cdpcmd.TracingRecordClockSyncMarker.String(), args, nil, d.conn)
	} else {
		err = rpcc.Invoke(ctx, cdpcmd.TracingRecordClockSyncMarker.String(), nil, nil, d.conn)
	}
	if err != nil {
		err = &opError{Domain: "Tracing", Op: "RecordClockSyncMarker", Err: err}
	}
	return
}

// DataCollected creates the event client. Contains an bucket of collected trace events. When tracing is stopped collected events will be send as a sequence of dataCollected events followed by tracingComplete event.
func (d *Tracing) DataCollected(ctx context.Context) (cdpevent.TracingDataCollectedClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingDataCollected.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TracingDataCollectedClient{Stream: s}, nil
}

// TracingDataCollectedClient implements cdpevent.TracingDataCollectedClient.
type TracingDataCollectedClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TracingDataCollectedClient) Recv() (*cdpevent.TracingDataCollectedReply, error) {
	event := new(cdpevent.TracingDataCollectedReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Tracing", Op: "DataCollected Recv", Err: err}
	}
	return event, nil
}

// TracingComplete creates the event client. Signals that tracing is stopped and there is no trace buffers pending flush, all data were delivered via dataCollected events.
func (d *Tracing) TracingComplete(ctx context.Context) (cdpevent.TracingCompleteClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingComplete.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TracingCompleteClient{Stream: s}, nil
}

// TracingCompleteClient implements cdpevent.TracingCompleteClient.
type TracingCompleteClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TracingCompleteClient) Recv() (*cdpevent.TracingCompleteReply, error) {
	event := new(cdpevent.TracingCompleteReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Tracing", Op: "TracingComplete Recv", Err: err}
	}
	return event, nil
}

// BufferUsage creates the event client.
func (d *Tracing) BufferUsage(ctx context.Context) (cdpevent.TracingBufferUsageClient, error) {
	s, err := rpcc.NewStream(ctx, cdpevent.TracingBufferUsage.String(), d.conn)
	if err != nil {
		return nil, err
	}
	return &TracingBufferUsageClient{Stream: s}, nil
}

// TracingBufferUsageClient implements cdpevent.TracingBufferUsageClient.
type TracingBufferUsageClient struct{ rpcc.Stream }

// Recv calls RecvMsg on rpcc.Stream, blocks until the event is
// triggered, context canceled or connection closed.
func (c *TracingBufferUsageClient) Recv() (*cdpevent.TracingBufferUsageReply, error) {
	event := new(cdpevent.TracingBufferUsageReply)
	if err := c.RecvMsg(event); err != nil {
		return nil, &opError{Domain: "Tracing", Op: "BufferUsage Recv", Err: err}
	}
	return event, nil
}
